TITLE	FILIO	DISK SERVICE ROUTINE

	STOPCD(,ENTRY,FILIO)	;All stopcodes in FILIO start with "SWP"

	ND	FTDPAG,0	;Must match COMMOD,RMXKON,APXKON,BPXKON
IF2,<IFE FTDPAG,<PRINTX :    FTDPAG set for blocks>
     IFN FTDPAG,<PRINTX :    FTDPAG set for pages>>

IOSUPR==100000	;SUPER USETI/USETO DONE ON THIS CHAN


;THE FOLLOWING S BITS ARE DEFINED IN COMMON.MOD
;BECAUSE THEY WANT TO BE IN THE SAME POSITION IN S AS IN RIB STATUS WORD
;IOSHRE==100	;HARD READ ERROR ENCOUNTERED
;IOSHWE==200	;HARD WRITE ERROR ENCOUNTERED
;IOSSCE==400	;SOFTWARE CHECKSUM ERROR ENCOUNTERED
;IOSERR==IOSHRE+IOSHWE+IOSSCE
;IOSMER==-IOSERR
DEFINE DSKOFF <WRPI DSKPIF>
DEFINE DSKON  <WRPI DSKPIN>
EXTERN ALR620,CPOPJ,CPOPJ1,DEVBLK,DSKPIF,DSKPIN
EXTERN GETOPR,INLMES,IOSHRE,IOSHWE,PRNAME
EXTERN PTNUNI,PTSUNI,PWAIT1
EXTERN REMLST,SATONC,SYSUNI,UNTTBL,PIOMOD

EXTERN PGYPNO,PGYFPL,PGYBPL,PGYSTS,PGPDER,PGPDTE,PGYSIO,PGYADR
EXTERN PGYDRT,PGYUNI
IFCPU (KL),<EXTERN PGYCSH>

EXTERN RBYUNI,RBYPNO,RBREAL,RBINDX,RBSPAR


EXTERN KONPOS,KONRED,KONWRT,KONRCL,KONSTP,KONCPY
EXTERN KONCHN,KONLTM,KONPTR,KONADD,KONFIN,CHNBSY
EXTERN KONOFS,KONHRD,KONSFT

EXTERN UNISTS,UNICHN,UNPOFL
EXTERN UNISTT,UNIERR,UNYPGL,UNYPAC
EXTERN UNIKON,UNISTR,UNITAL,UNISYS
EXTERN UNIDES,UNINAM,UNYLUN,UNISOF,UNIHBN
EXTERN UNIBRC,UNIDRC,UNIMSC,UNIUSC,UNISBN,UNIICT,UNIBWC,UNIDWC
EXTERN UNIHCT,UNISCT,UNICYL,UNIONC
EXTERN UNIHNG,UNISDI,UNIECT,UNIRCT,UNIRC1
EXTERN UNIHDI,UNPFUS,UNIDIR,UNIFCT,UNYTIM
EXTERN UNICDA,UNYRCL,UNYRRT,UNYRTY,UNPDEV,UNYOCV,UNYRTO,UNYRCO
IFE FTDPAG,<EXTERN UNIBLK,UNYBPY,UNYPPL>
IFN FTDPAG,<EXTERN UNIPAG,UNYPPY>

EXTERN KCMOFL,KCMFUS,KCMRER,KCMERR,KCMDTA,KCMIOS,KCMPOS

EXTERN LSTLST,PGYPNO,PGYLST,PGYSOP,SID.N,SOD.N,SPR.N,%UPT
EXTERN MAXPCB,FINPCB,MINPCB,MEMSZP
EXTERN PICLK,JOB,CLKFLG

EXTERN ADRDUM
EXTERN CTLFND,PGYLMA,%SAT.C

IFCPU (KL),<EXTERN CSUCNT,CSVCNT,CSHSAV>
REPEAT	0,<
NOTE ABOUT STATES OF CHANNELS, KONTROLLERS, UNITS, FILES:

			C	J	U	F
IDLE		I	I	I	I	I
SEEK WAIT	SW			SW
SEEK		S			S
POSITION WAIT	PW			PW	PW
POSITION	P			P	P
TRANSFER WAIT	TW			TW	TW
TRANSFER(BUSY)	T1 OR B	B	B	T1	T1

NOTE ABOUT QUEUES:
THERE ARE 2 QUEUES OF FILES
	SW/PW QUEUE FOR EACH UNIT
	TW QUEUE FOR CHANNEL
A FILE IS ONE AND ONLY ONE OF THE FOLLOWING CONDITIONS:WITH RESPECT TO QUEUES
	A.THE ONLY FILE IN SW/PW QUEUE FOR A UNIT (UNIT IN SW STATE)
	B.ONE OF PERHAPS MANY FILES IN PW QUEUE FOR A UNIT(UNIT IN PW,P,TW,OR T1 STATE)
	C.ONE OF PERHAPS MANY IN TW QUEUE FOR CHANNEL(CHAN AND KONTROL IN B STATE)
	D.NONE OF THE ABOVE (FILE IN I,P, OR T1 STATE)

NOTE:	#MEANS INSTRUCTION IS EXECUTED WITH ALL DISK PI CHANNELS OFF
	%MEANS INSTRUCTION IS EXECUTED WHILE JOB HAS CB RESOURCE
	*MEANS INSTRUCTION MAY BE EXECUTED AT INTERRUPT LEVEL
	(TO SAVE TYPING USED ONLY FOR INSTRUCTIONS NOT IN INTERRUPT MODULE ITSELF)

THE FOLLOWING TECO MACRO WILL PRODUCE A LISTING OF ONLY THE SUBROUTINE
NAMES AND COMMENTS PRIOR TO THEM:
ERDEV1:FILIO.MAC$EWDEV2:FILIO.SUB$
<_;SUBROUT$;0L.U1  !NTST! :S:$"GA ONTST$'.U20L1A-59"E LONTST$' Q2JI

$Q1,.PW 0,.K>EF

>
SUBTTL UUO LEVEL MODULE
;UUO LEVEL IO(F ALREADY SET TO DDB FOR FILE DOING IO)

;HERE TO START A SEEK  (CALLI 56)
UUOSEK::PUSHJ	P,SEKPTR	;GET POINTER TO NEXT BLOCK IN T2
	  POPJ	P,		;CAN'T DO IT
	SKIPL	KONPOS(J)	;DOES CONTROLLER POSITION?
	SKIPE	T1,UNISTS(U)	;YES. IS UNIT IDLE?
	 POPJ	P,		;NO. IGNORE SEEK REQUEST
	DSKOFF			;SINCE WE ARE DIDDLING QUEUES
	DPB	T1,UNYPAC	;ALSO PAGE POINTER (0 FROM ABOVE)
IFE FTDPAG,<
	MOVEM	T2,UNIBLK(U)	;Save desired block address
	LDB	T3,UNYBPY	;Convert to desired cylinder number
>
IFN FTDPAG,<
	LSH	T2,B2PLSH	;Convert blocks to pages
	MOVEM	T2,UNIPAG(U)	;Save desired page address
	LDB	T3,UNYPPY	;Convert to desired cylinder number
>
	IDIV	T2,T3		; (to see if SEEK needs to be done)
	CAMN	T2,UNICYL(U)	;ALREADY ON CYL?
	 PJRST	ONPOPJ		;YES, TURN ON PI AND GO
	MOVEI	T1,SWCOD	;SET TO SEEK WAIT
	MOVEM	T1,UNISTS(U)
	SKIPGE	KONLTM(J)	;Need to worry about latency optimization?
	 JRST	UUOSK1		;No, start IOSEL for SA10
	MOVEI	T1,SCOD
	MOVEM	T1,UNISTS(U)	;CHAN NOT REQUIRED, START SEEK
	AOS	UNIUSC(U)	;COUNT SEEK
	PUSHJ	P,@KONPOS(J)	;Start seek to page in UNIPAG(U)
ONPOPJ:	DSKON
	POPJ	P,

UUOSK1:	PUSH	P,F		;Save F from IOSEL
	PUSHJ	P,IOSEL
	POP	P,F
	JRST	ONPOPJ		;Turn on PI and go
;ROUTINE TO GET NEXT BLOCK FOR SEEK.
; CALL WITH DEVPOS(F) POINTING TO NEXT BLOCK,
; RETURNS WITH T2 NEXT ABSOLUTE BLOCK ON DISK,
; U AND J SETUP WITH UDB AND KDB. SKIP IF SUCCESSFUL.

EXTERNAL USETST,ATYBSZ,RBMASK,RELRIB,UNLFIL,RBYUNI
EXTERNAL DEVSUP,DEVPOS,DEVATB,DEVRET
EXTERNAL STRDDB,STRPPU,STRUNI,STRBTS,SRPNDS
EXTERNAL LOKUNM

SEKPTR:	MOVE	M,DEVPOS(F)	;GET NEXT BLOCK
	TLZ	M,(1B0)		;CLEAR POSSIBLE CHANGE FLAG.
	TLNE	S,IOSUPR	;SUPER I/O?
	 JRST	SEKPTS		;YES, DO IT DIFFERENTLY

	HRRZ	T2,DEVATB(F)	;GET ATB
	JUMPE	T2,CPOPJ	;CAN'T DO IT IF NO FILE.
	LDB	T1,ATYBSZ	;GET SIZE IN BLOCKS
	CAMLE	M,T1		;EOF?
	 POPJ	P,		;YES, CAN'T DO IT.
	ADDI	M,3		;ROUND UP TO NEAREST PAGE.
	LSH	M,B2PLSH	;CONVERT TO PAGES FOR USETST
	JUMPE	M,CPOPJ		;BETTER NOT BE PAGE 0
	PUSHJ	P,LOKUNM	;LOCK FILE UNMODIFIED.
	PUSHJ	P,USETST	;SETUP DEVRET
	  JRST	[MOVEM S,DEVIOS(F) ;STORE STATUS
		POPJ P,]
	MOVE	T2,@DEVRET(F)	;GET POINTER WE WORKED SO HARD FOR
	PUSH	P,T2		;SAVE T2 FROM THESE GUYS
	PUSHJ	P,RELRIB
	PUSHJ	P,UNLFIL	;RELEASE RIB AND FILE
	POP	P,T2		;RESTORE T2.
	TLNN	T2,RBREAL	;IS NEXT THING A HOLE?
	 POPJ	P,		;YES, ALL THAT FOR NOTHING.
	LDB	U,RBYUNI	;GET UNIT NUMBER
	MOVE	U,UNTTBL(U)	;GET UDB ADDRESS
	TLZ	T2,RBMASK	;GET RID OF XTRA BITS
	LSH	T2,P2BLSH	;CONVERT TO BLOCK
				;(ALWAYS OK TO POSITION TO 1ST BLOCK OF PAGE.)
	JRST	SEKPT1		;RETURN U AND J SET UP, T2 HAS PAGE #

;HERE IF IT WAS SUPER I/O

SEKPTS:	MOVE	T2,M		;GET BLOCK # IN CASE ITS A UNIT
	HRRZ	U,DEVSUP(F)	;MAYBE HE INITED UNIT
	JUMPN	U,SEKPT1	;IF SO, JUST USE DEVPOS (BLOCK # IN T2)
	MOVE	T1,M		;NO, MUST COMPUTE BLOCK WITHIN UNIT
	LSH	T1,B2PLSH	;CONVERT TO PAGES
PRINTF(<[SEKPTS+5: Check need to use DRBSTR instead of STRDDB]>)
	MOVEI	U,STRDDB	;Get current structure
PRINTF(<[SEKPTS+6: Uses STRPPU as divisor - all units must be same size!!!]>)
	IDIV	T1,STRPPU(U)	;GET UNIT # IN T1, PAGE # IN T2
	LSH	T2,P2BLSH	;CONVERT BACK TO BLOCKS
	MOVEI	U,STRUNI-UNISTR(U) ;START WITH THIS
	HLRZ	U,UNISTR(U)	;GET NEXT UNIT IN STR
	SOJGE	T1,.-1		;KEEP GOING TILL GET THE RIGHT ONE

SEKPT1:	MOVE	J,UNIKON(U)	;GET KDB ADDRESS
	JRST	CPOPJ1		;RETURN FROM SEKPTR WITH BLOCK # IN T2
SUBTTL	READ AND RESET BUFFERED LOG
IFNCPU(<KI,KL>),<RRSETB==:CPOPJ> ;There is no buffered log on F3 or KS
IFCPU (<KI,KL>),< ;Read error log from disk control unit via SA10
RRSETB::DSKOFF
	SKIPE	UNISTS(U)	;IS UNIT DOING ANYTHING?
	 JRST	RRSETF		;YES, JUST FLAG FOR RESET
	MOVEI	T1,RSCOD	;NO, FLAG THE OPERATION
	MOVEM	T1,UNISTS(U)
	PUSHJ	P,SETTIM
	PUSHJ	P,@KONLTM(J)	;READ BUFFERED LOG (INSTEAD OF LATENCY ROUTINE)
	DSKON
	JRST	CPOPJ1

RRSETF:	MOVSI	T1,UNPRRS##
	IORM	T1,UNIDES(U)	;UNIT CURRENTLY BUSY, FLAG FOR LATER
	DSKON
	JRST	CPOPJ1
>  ;IFCPU(KI,KL)
SUBTTL	FILINT  - INTERRUPT HANDLING MODULE

COMMENT !
Called from device dependent interrupt routine (disk drivers)
T3 contains the DATAI (or fake DATAI) from the device
T2 contains the CONI (or fake CONI) from the device
T1 is the Kontroller CoMmunications word
  Bits 0-7 are attention bits (for DPXKON,RMXKON,APXKON)
  KCMPOS (1B7) IBM disk controller gets position interrupt (BPXKON)
  KCMRER (1B8) Recovered data error (corrected using ECC)
  KCMFUS (1B9) File unsafe
  KCMERR (1B10) Unrecoverable error in data transfer
  KCMDTA (1B11) Successful data transfer (RH must be nonzero)
  KCMIOS (1B12) I/O select needed (internal to FILIO only)
  KCMOFL (1B13) Unit is off-line
        (17B17) unused
IFE FTDPAG,<Bits 18-35 contain the number of blocks transfered>
IFN FTDPAG,<Bits 18-35 contain the number of pages transfered>
The device driver sets J to Kontroller DB and U to Unit DB
!

FILINT::PUSH	P,T3		;Software generated DATAI
	PUSH	P,T2		;Software generated CONI
	PUSH	P,T1		;LH=error bits, RH=blocks or pages
	TLNE	T1,KCMOFL!KCMFUS
	 PUSHJ	P,SETOFL	;Set unit off-line
	TLNE	T1,776000!KCMPOS
	 PUSHJ	P,POSSAT	;Position interrupt
	TLNE	T1,KCMRER
	 PUSHJ	P,ERRRCV	;Recovered error
	TLNE	T1,KCMDTA
	 PUSHJ	P,DTASAT	;Data transfer completed (errors possible)
	TLNE	T1,KCMIOS
	 PUSHJ	P,IOSEL		;Start I/O
	POP	P,T1
	POP	P,T2
	POP	P,T3
	POPJ	P,
;Set unit off line - called with KCMOFL or KCMFUS set in T1
SETOFL:	MOVE	T2,UNISTS(U)
	CAIN	T2,CCOD		;Doing capacity test?
	 JRST	CPYOFL
	CAIE	T2,TCOD		;Was this unit in the middle of a transfer?
	 JRST	SETOF1		;If not, do not free KON and CHN
	PUSHJ	P,SETID2L	;Set KON and CHN idle
	MOVSI	T1,KCMIOS	;
	IORB	T1,-1(P)	;Set IOS bit to restart the transfer
SETOF1:	MOVEI	T2,OWCOD
	MOVEM	T2,UNISTS(U)	;Waiting for on-line interrupt
	MOVSI	T2,UNPOFL
	TLNE	T1,KCMFUS
	 TLO	T2,UNPFUS
	IORM	T2,UNIDES(U)	;Remember off-line and possible unsafe
	HLLM	T2,LSTBDU	;Save last bad status
	HRRM	U,LSTBDU	; and unit
	MOVEI	T2,1
	DPB	T2,UNYTIM	;Set timer to go off now
	MOVE	T1,-1(P)	;Go get KMCIOS again
	POPJ	P,

LSTBDU:	0			;Last bad status and unit (for crash ais)

CPYOFL:	HRROS	UNIONC(U)	;Negative to signify off-line
CPYFIN:	SETZM	UNISTS(U)	;End of capacity test
	PJRST	ZERTIM		;Clear hung timer and return
;Positioning done interrupt - Bits 0-7 set for non-IBM, KMCPOS for IBM disks
POSSAT:	PUSH	P,U		;Save unit of data transfer if any
	MOVSI	P2,776000	;Get just the attention bits
	AND	P2,-2(P)	; from device CONI
IFCPU(<KI,KL>),<
	TLNE	T1,KCMPOS	;Position done on an IBM disk?
	 TDZA	P2,P2		;Yes, zero P2 and got to POSTS1
	  TDZA	P4,P4		;No, zero P4 and go to POSTST
	JRST	POSTS1		;U is already set up for IBM disk
>  ;End IFCPU(KI,KL)
IFNCPU(<KI,KL>),<SETZ	P4,>	;Clear offset
POSTST:	JFFO	P2,.+2		;Any attention bits left on?
	 JRST	POSDON		;No, finished
	LSH	P2,1(P3)	;Get rid of bit
	ADDB	P4,P3		;Set unit index
	SKIPN	U,@KONPTR(J)	;Doing I/O?
	 AOJA	P4,POSTST	;Extraneous interrupt, check next unit
POSTS1:	MOVE	T1,UNISTS(U)	;Get wait code
	XCT	PSTTBL(T1)	;Process position done interrupt
	AOJA	P4,POSTST	;Go do next one

PSTTBL:	PHASE	0
ICOD:!	SETOM	UNICYL(U)	;JUST MARK SO FORCES SEEK
PWCOD:!	SETOM	UNICYL(U)
PCOD:!	PUSHJ	P,POSFIN	;FINISHED A POSITION OPERATION
SWCOD:!	SETOM	UNICYL(U)
SCOD:!	PUSHJ	P,SEKFIN	;FINISHED A SEEK
RSCOD:!	PUSHJ	P,SEKFIN	;READ AND RESET BUFFERED LOG, TREAT LIKE SEEK
CWCOD::!SETOM	UNICYL(U)
CCOD::!	PUSHJ	P,CPYFIN	;CAPACITY TEST FINISHED
TWCOD:!	 STOPCD			;ONLY FIXED HEAD DISKS ARE IN TW
TWFCOD:!PUSHJ	P,RESEK		;MUST BE OFF THEN ON, RESET FOR POS
TCOD:!	SETOM	UNICYL(U)	;SHOULD HAVE BEEN AN OFF-LINE INT FIRST
RCOD:!	PUSHJ	P,RCLFIN	;FINISHED RECAL, SET TO POS
OWCOD:!	PUSHJ	P,UNIONL	;UNIT BACK ONLINE
	DEPHASE

POSDON:	POP	P,U		;Position done.  Do nothing
	MOVE	T1,-1(P)	;Reset COM word
	POPJ	P,

SEKFN1:	SETOM	UNICYL(U)
	TDZA	T1,T1		;GO TO IDLE
POSFIN:	MOVEI	T1,TWFCOD	;BUT IF POS FINISHED, TO TWF
COMFIN:	MOVEM	T1,UNISTS(U)	;SET STATUS
	PUSHJ	P,ZERTIM	;Zero hung timer
	MOVSI	T1,KCMIOS
	IORM	T1,-3(P)	;NEED I/O SELECTION
	SKIPN	-1(P)
	HRRM	U,-1(P)		;SAVE UNIT IN CASE ONLY POS INTERUPT
	POPJ	P,

RESEK:
RCLFIN:	SETOM	UNICYL(U)	;MUST HAVE BEEN OFF-LINE
RCLFN2:	MOVEI	T1,PWCOD	;OR FINISHED RECAL, FORCE SEEK
	SKIPGE	KONLTM(J)	;If no latency optimization,
	 MOVEI	T1,TWFCOD	; set TWF to go to T (no seek wait for SA10)
	JRST	COMFIN

UNIONL:	MOVSI	T1,UNPOFL!UNPFUS
	ANDCAM	T1,UNIDES(U)	;Clear off-line and unsafe bits
	LDB	T1,UNYPAC	;OTHER KIND OF WAITER
	JUMPN	T1,RCLFIN
	JRST	SEKFN1		;ELSE NO ONE WAITING, JUST SET IDLE

SEKFIN:	PUSH	P,P2		;NEED TO SAVE THIS AC
	PUSHJ	P,PIKPOS	;SEE WHAT POSITION NEED DOING
	  JRST	SEKFN2		;NO REQUESTS, GO TO IDLE
	JUMPE	P2,SEKFN3	;NO POSITION NEEDED, TO TWF
	POP	P,P2
	JRST	RCLFN2		;GO TO PW

SEKFN2:	TDZA	T1,T1		;NO REQUEST, GO IDLE
SEKFN3:	MOVEI	T1,TWFCOD	;NO POSITION NEEDED, TO TWF
	POP	P,P2
	JRST	COMFIN
;Recoverable error interrupt - KCMRER is set
ERRRCV:	AOS	UNISCT(U)	;Call it a soft error
	PUSHJ	P,@KONSFT(J)	;Save error status if necessary
	MOVE	T2,-2(P)	;Device CONI
	MOVEM	T2,UNISOF(U)
	MOVE	T2,-3(P)	;Device DATAI
	MOVEM	T2,UNISDI(U)
	HRRZ	T2,-1(P)	;Get number of blocks or pages
IFN FTDPAG,<
	LSH	T2,P2BLSH	;Convert to blocks for UNISBN
>
	SUBI	T2,1		;Last block did not transfer OK
	MOVEM	T2,UNISBN(U)	;PUT THIS IN SOFT BLOCK FOR NOW
	LDB	PG,UNYPAC	;GET PAGE INFO POINTER
	LDB	T2,PGYPNO	;AND ADDRESS
	LSH	T2,P2BLSH	;CONVERT TO BLOCKS
	ADDM	T2,UNISBN(U)	;Disk block address of error
IFE FTDPAG,<
	LDB	T2,UNYPPL	;ALSO GET OFFSET
	ADDM	T2,UNISBN(U)	;FINISH SETTING BLOCK NUMBER
>
IFN FTDPAG,<
	LSH	T2,B2PLSH	;Convert back to page number
>
	POPJ	P,

;Data transfered interrupt - KCMDTA is set, RH must nonzero if KCMERR off

DTASAT:	LDB	PG,UNYPAC	;GET ACTIVE PAGE NUMBER
	LDB	S,PGYSIO	;MAKE SURE PAGE HAS I/O GOING
	SKIPN	S		;NO?
	 STOPCD (.,STOP,SWPNIO,,<Swap done: No I/O in progress>) ;;DTASAT+3
	LDB	S,PGYSOP
	JUMPE	S,DTAST2	;IN
	MOVSI	S,IO		;OUT
DTAST2:	TLNN	T1,KCMERR	;IS THERE AN ERROR?
	 JRST	DTAOK		;NO, TRANSFER IS OK
	MOVSI	T2,UNPDEV
	MOVEI	P3,IODERR
	TDNN	T2,UNIRCT(U)
	 MOVEI	P3,IODTER	;SET DATA OR DEVICE ERROR
	TRNE	S,IONRCK
	 JRST	DTAOK1		;IGNORE ERROR IF NO RETRY REQUESTED
	HRRZ	P4,-1(P)	;Get number of blocks or pages
IFN FTDPAG,<
	LSH	P4,P2BLSH	;Convert pages to blocks
>
	LDB	T2,PGYPNO	;Disk page number
	LSH	T2,P2BLSH	;Convert to disk block address
	ADD	P4,T2		;Block address where error was detected
IFE FTDPAG,<
	LDB	T2,UNYPPL
	ADD	P4,T2		;PLUS BLOCK WITHIN PAGE
>
	SUBI	P4,1		;Last block successfully transferred
DTAST3:	SKIPG	UNIRCT(U)	;IS THE ERROR THE FIRST ONE?
	 JRST	DTRSEC		;NO
	MOVEM	P4,UNISBN(U)	;SAVE SOFT BLOCK NUMBER
	MOVE	T2,-2(P)	;Device CONI
	MOVEM	T2,UNISOF(U)	;STORE THE SOFT ERROR STATUS
	MOVE	T1,-3(P)	;Device DATAI
	MOVEM	T1,UNISDI(U)
	SETZM	UNIECT(U)	;RESET ERROR COUNT
	MOVSI	T1,(1B0)
	IORM	T1,UNIRCT(U)	;AND RESET BIT 0 (NOT FIRST)
DTRSEC:	LDB	T1,UNYRTY	;CHECK NUMBER OF RETRYS REMAINING
	SOJGE	T1,DTRRTY	;GO RETRY
	LDB	T1,UNYRCL	;OUT OF RETRYS, TRY RECAL
	SOJGE	T1,DTRRCL
	LDB	T1,UNYOCV	;TRY OFFSET NEXT.
	SOJGE	T1,DTROFS
	MOVEM	P4,UNIHBN(U)	;SET HARD DATA ERROR BLOCK NUMBER
	MOVE	T1,-2(P)	;Device CONI
	MOVEM	T1,UNIERR(U)	;STILL FAILS AFTER E.R.: CALL IT HARD ERROR.
	MOVE	T1,-3(P)	;Device DATAI
	MOVEM	T1,UNIHDI(U)
	MOVEI	T1,1		;READY TO COUNT ERROR
	TRNN	P3,IODTER
	 JRST	[MOVSS T1	;DEVICE ERROR
		JRST   DTRSC1]
	TLNE	S,IO
	 TLOA	P3,IOSHWE	;Hard write error
	  TLO	P3,IOSHRE	;Hard read error
DTRSC1:	ADDM	T1,UNIHCT(U)	;# of IODERRs ,, # of IODTERs
	MOVE	P4,UNIHBN(U)	;SAVE HARD BLOCK NUMBER
	PUSHJ	P,@KONHRD(J)	;CALL DEVICE DEPENDENT HARD ERROR DATA SAVER.
	JRST	DTAOK1
;Device retry
DTRRTY:	DPB	T1,UNYRTY	;REST COUNT
	AOS	UNIECT(U)	;COUNT 1 RECOVERY TRY
	MOVEI	T1,TWFCOD	;SET TRANSFER FIXED (RETRY)
	PUSHJ	P,IDL1		;SET IDLE AND STORE STATUS
KCIPOP:	MOVSI	T1,KCMIOS	;NEED TO DO I/O SELECT
	POPJ	P,

DTRRCL:	DPB	T1,UNYRCL	;RESET COUNT
	LDB	T1,UNYRRT	;SET RETRY COUNT AFTER RECAL
	DPB	T1,UNYRTY
	MOVEI	T1,RCOD
	PUSHJ	P,IDL1
	PUSHJ	P,SETTIM	;MAKE SURE IT HAPPENS EVENTUALLY
	PUSHJ	P,@KONRCL(J)	;ISSUE RECAL
	JRST	KCIPOP

DTROFS:	DPB	T1,UNYOCV	;STORE UPDATED COUNT.
	LDB	T1,UNYRTO	;RETRY COUNT AFTER OFFSET.
	DPB	T1,UNYRTY
	LDB	T1,UNYRCO	;RECAL COUNT AFTER OFFSET.
	DPB	T1,UNYRCL
	PUSHJ	P,@KONOFS(J)	;SETUP FOR OFFSET, STATE IN UNYOCV
	JRST	DTRSEC		;AND TRY AGAIN.


IDL1:	MOVEM	T1,UNISTS(U)
	PUSHJ	P,ZERTIM
SETID2:	LDB	PG,UNYPAC
	LDB	T1,PGYPNO	;Physical page number on disk
IFE FTDPAG,<
	LSH	T1,P2BLSH	;CONVERT TO BLOCKS
	LDB	T3,UNYPPL	;NUMBER OF BLOCKS IN PARTIAL PAGE TRANSFER
	ADD	T1,T3		;INCLUDE OFFSET IN ADDRESS
	MOVEM	T1,UNIBLK(U)
>
IFN FTDPAG,<
	MOVEM	T1,UNIPAG(U)	;Store for KONRED and KONWRT
>
SETIDL:	MOVSI	T1,(1B0)
	ANDCAM	T1,KONPTR(J)	;Clear busy flag for this kontroller
	HRRZ	T3,KONCHN(J)
	ANDCAM	T1,CHNBSY(T3)	;Clear busy flag for its channel
	POPJ	P,
SUBTTL	Data transfer OK
DTAOK:	MOVEI	P3,0		;NO ERRORS
	SKIPL	UNIRCT(U)	;WAS THERE AN ERROR?
	 JRST	DTAOK1		;NO
	MOVEI	T1,1
	MOVSI	T2,UNPDEV
	TDNE	T2,UNIRCT(U)	;DEVICE OR DATA?
	 MOVSS	T1		;DEVICE
	ADDM	T1,UNISCT(U)
	PUSHJ	P,@KONSFT(J)	;TELL DRIVER THAT SOFT ERROR HAS OCCURRED, MAYBE HAS TO SAVE SOME STATUS.
DTAOK1:	PUSHJ	P,ZERTIM	;Clear hung timer
	PUSHJ	P,SETIDL	;KON AND CHN ARE NOW IDLE
	SETZM	UNISTS(U)	;UNIT IS NOW IDLE
	SETZM	UNIRCT(U)	;ZERO THIS FOR NEXT TIME
	SETZM	UNIRC1(U)	;ZERO SECOND E.R. STORAGE CELL.

SWPFIN:	HRRZ	P4,-1(P)	;Get number of blocks or pages
IFN FTDPAG,<
	LSH	P4,P2BLSH	;Convert to number of blocks
>
	MOVEI	T1,UNIICT(U)	;GET POINTER TO BLOCKS TRANS
	PUSHJ	P,UPSTAT	;AND UPDATE
	JUMPE	P3,NOSWPR	;No swap errors (P4 has # of blocks xfer'd)

;   The following path was used to get here:
;1) Disk interrupt to BPXINT, APXINT, or RMXINT
;2) Disk driver jumps to FILINT with bits in T1
;3) KCMERR was set in T1 when tested at DTASAT
;4) Jump to DTAOK1 at either DTRSEC+16 or DTAST2+7, which set P3 nonzero

	TLNN	S,IO		;INPUT OR OUTPUT ERROR?
	 JRST	SWPFIE		;INPUT
	LDB	T2,PGYADR	;OUTPUT, GET DISK ADDRESS
	CAMLE	PG,MAXPCB	;Is page a PCB?
	 JRST	SWPFNP		;No
	MOVEM	PG,SAVEPG
	LDB	T2,PGYLMA	;Yes, get address of page
	PUSHJ	P,CTLFND	;Determine PCB type
	CAIN	PG,%SAT.C	;Is it a SAT?
	 STOPCD (.+1,INFO,WRTSAT,WRTST1,<Disk output error writing SAT>);;SWPFIN+15
	MOVE	PG,SAVEPG
	JRST	SWPFNP		;Go put page in error hash table (INSOH3+1)

SAVEPG:	0			;Saved contents of PG

;This routine called by STOPCD processor (see also CPLSAT in SWAMP)
WRTST1:	PUSHJ	P,DSKCLN##	;Output "Requesting FULL DSKCLN" and continue
WRTST2:	MOVE	PG,SAVEPG
	PFALL	PRTPGY		;Output info from PGY table for this PG

PRTPGY::PUSHJ	P,INLMES##
	 ASCIZ /Core page /
	MOVE	T1,PG
	PUSHJ	P,OCTPNT##
	PUSHJ	P,INLMES##
	 ASCIZ / associated with disk unit /
	LDB	T1,PGYUNI	;Get disk unit part of PGYADR
	PUSHJ	P,OCTPNT##	;Print unit
	PUSHJ	P,INLMES##
	 ASCIZ	/ page /
	LDB	T1,PGYPNO	;Get disk page number part of PGYADR
	PUSHJ	P,PRT22A##	;Print page address (6 or 7 octal digits)
	PJRST	CRLF##

PRINTF(<[SWPFNP Checking DSKCLN done should use DRBSTR for file]>)
SWPFNP:	MOVEI	T1,SRPNDS	;    If DSKCLN has not run to completion,
	TDNE	T1,STRDDB+STRBTS; then output message, don't put in OHT
	 STOPCD (NOSWPR,EVENT,WRTDSK,WRTST2,<Disk write error>);;SWPFNP+2
	PUSHJ	P,INSOHT	;PUT INTO OUTPUT ERROR HASH TABLE
	MOVE	T1,P3		;COPY ERROR BITS
	ANDI	T1,IODERR!IODTER ;JUST THESE
	LSH	T1,^L<IODTER>-^L<OHTDTE>+^D18	;POSITION IT FOR OHT IORM
	IORM	T1,OHTTAB(T4)	;PUT BITS INTO OHT
	JRST	NOSWPR		;REJOIN CODE.

;Disk read error

SWPFIE:	LDB	T1,PGYSTS	;GET STATUS BITS
	ADDI	P4,3		;FORCE TO END OF THIS PAGE
	TRZE	P3,IODERR
	 TRO	T1,PGPDER
	TRZE	P3,IODTER
	 TRO	T1,PGPDTE
	DPB	T1,PGYSTS	;SET ERROR BITS.

NOSWPR:		;Here with # of blocks transferred in P4 (even IFN FTDPAG)
IFE FTDPAG,<
	CAIGE	P4,4		;THIS MIGHT BE TRUE ON RECOVERABLE ERROR
	 JRST	SWPPPL		;YES, MUST TAKE SPECIAL PAINS
>
SWPPLD:	LDB	PG,UNYPAC	;GET FIRST PAGE DONE
	LSH	P4,B2PLSH	;Convert # of blocks done to pages
	SKIPG	P4		;MUST BE AT LEAST ONE
	 STOPCD (.,INFO,SWPZER,PRTPGY,<Swapped zero pages>) ;;SWPPLD+2 (PGEZER)
	ADDM	P4,DSKAPC	;UPDATE SYSTEM-WIDE COUNTER
	SKIPE	JOB		;IF NULL JOB RUNNING
	 JRST	SWPFI0		;NOT
	SETOM	CLKFLG		;GET TO SCHED EARLY SO
	WRPI	PICLK		;HE DOESN'T HAVE TO WAIT TILL NEXT TICK.
SWPFI0:	MOVEI	F,SOD.N		;ASSUME SWAP OUT DONE
	TLNN	S,IO		;IS IT?
	 MOVEI	F,SID.N		;NO, SWAP IN DONE
	CAIA			;SKIP OVER FIRST LDB
	 LDB	PG,PGYFPL	;GET NEXT PAGE
	SOJG	P4,.-1		;JUMP IF THIS IS NOT THE LAST

;HERE WITH LIST NUMBER IN F, FIRST PAGE DONE IN UNYPAC,
; LAST PAGE DONE IN PG.

;FIRST TAKE THE PAGES THAT HAVE BEEN COMPLETED OFF THE I/O LIST.

	LDB	P4,UNYPAC	;P4 GETS FIRST DONE.
	MOVE	P3,PG		;P3 GETS LAST DONE.
	LDB	T3,PGYFPL	;GET FIRST NOT DONE, IF ANY, IN T3
	MOVE	PG,P4		;ADDRESS FIRST DONE
	LDB	PG,PGYBPL	;GET PREVIOUS IN PG
	JUMPE	PG,[DPB T3,UNYPGL ;IN NO PREVIOUS, FIRST NOT DONE, IF ANY,
				; IS NEW FIRST ON I/O LIST
		    JRST .+2]	;SKIP OVER THE DPB
	DPB	T3,PGYFPL	;PREVIOUS POINTS FORWARD TO 1ST NOT DONE
	EXCH	PG,T3		;ADDRESS 1ST NOT DONE IF ANY, T3
				; HAS PREVIOUS
	SKIPE	PG		;IF NO 1ST NOT DONE, NOTHING TO POINT BACK
	 DPB	T3,PGYBPL	;1ST NOT DONE POINTS BACK TO PREVIOUS

;NOW TAKE PAGES THAT HAVE COMPLETED I/O AND PUT THEM ALL TOGETHER
; ONTO THE CORRECT DONE LIST.

	SKIPN	T3,LSTLST(F)	;ANYONE AT ALL ON DONE LIST?
	 JRST	NEWDON		;NO, JUST MAKE THIS THE DONE LIST
	HLRZ	PG,T3		;ADDRESS LAST IN DONE LIST
	DPB	P4,PGYFPL	;LAST IN LIST POINTS FORWARD TO FIRST DONE
	EXCH	P4,PG		;ADDR. FIRST DONE, P4/LAST IN DONE LIST
	DPB	P4,PGYBPL	;FIRST DONE POINTS BACK TO LAST IN DONE LIST
	EXCH	PG,P3		;ADDRESS LAST DONE, FIRST DONE IN P3.
	HRLM	PG,LSTLST(F)	;THIS IS THE NEW LAST IN DONE LIST
	SETZ	T1,		;LAST IN DONE LIST POINTS TO 0
	DPB	T1,PGYFPL
	JRST	SWPFI1		;RETURN

;HERE WHEN DONE LIST WAS EMPTY. T3 CONTAINS 0.

NEWDON:	HRL	P4,P3		;LAST DONE,,FIRST DONE
	MOVEM	P4,LSTLST(F)	;NEW DONE LIST
	HRRZ	PG,P4		;ADDRESS FIRST DONE
	DPB	T3,PGYBPL	;POINTS BACK TO A 0
	EXCH	PG,P3		;ADDRESS LAST DONE, FIRST DONE IN P3.
	DPB	T3,PGYFPL	;POINTS FORWARD TO A ZERO

;HERE AFTER PAGES ARE PUT ONTO THE DONE LIST. STORE NEW
; LIST NUMBER AND CALL FINPCB IF THIS IS A PCB, WHICH
; MAY CALL SWPENQ (SO PAGE HAS TO BE ON DONE LIST).
; P3 HAS FIRST PAGE DONE, LAST PAGE DONE IS LAST ON DONE LIST.

SWPFI1:	MOVE	PG,P3		;GET FIRST DONE IN PG.

SWPFI2:	DPB	F,PGYLST	;THIS PAGE NOW ON DONE LIST
	CAMGE	PG,MINPCB	;MUST BE AT LEAST FIRST PCB PAGE
	 STOPCD (,XCT,SWPOOR)	;PAGE NUMBER TOO LOW    ;;SWPFI2+2
	LDB	P3,PGYFPL	;SAVE NEXT MEMBER IN CASE FINPCB
				; CALLS SWPENQ TO START IT AGAIN.
	CAMG	PG,MAXPCB	;IS IT A PCB?
	 PUSHJ	P,FINPCB	;YES, DO SPECIAL STUFF
	SKIPE	PG,P3		;GET NEXT PAGE IF ANY
	 JRST	SWPFI2		;AND DO IT
	JRST	KCIPOP		;RETURN.

IFE FTDPAG,<;Here if less than a full page was transfered
SWPPPL:	LDB	T2,UNYPPL	;SEE IF ANY LEFT FROM BEFORE
	ADD	P4,T2		;TOTAL TRANSFERED SO FAR
	DPB	P4,UNYPPL	;SAVE AMOUNT DONE NOW
	CAIL	P4,4		;IF NOT, IT IS 4, WE SAVE THE 2 LOW 0 BITS
	 JRST	SWPPLD		;FINALLY FINISHED THAT PAGE
	LDB	PG,UNYPAC
	LDB	T2,PGYPNO	;RESET ADDRESS
	LSH	T2,P2BLSH	;CONVERT TO BLOCKS
	ADD	T2,P4
	MOVEM	T2,UNIBLK(U)	;RESTART I/O AT THIS BLOCK
	MOVEI	T2,PWCOD	;PW for positioning and need channel
	SKIPL	KONLTM(J)	;If cannot do latency optimization
	SKIPGE	KONPOS(J)	; or fixed head disk that does not position
	 MOVEI	T2,TWFCOD	;  then set to TWF to go to T
	MOVEM	T2,UNISTS(U)
	JRST	KCIPOP
>  ;End IFE FTDPAG
SUBTTL	FILIO SUBROUTINES
COMMENT ;@@SUBROUTINE SWPENQ
@@PURPOSE ADD ONE PAGE TO THE SWAP I/O REQUEST LIST
@@ENTRY PG CONTAINS CORE PAGE TO ADD TO LIST. PGYSOP IS 1
IF PAGE IS TO BE SWAPPED OUT, 0 OTHERWISE (PGYSIP IS ASSUMED
TO BE ON IF PGYSOP IS OFF). PGYADR CONTAINS UNIT
(PGYUNI) AND PAGE WITHIN UNIT (PGYPNO) THAT THE SWAP
I/O IS TO BE DONE TO/FROM.
@@ACCUM USES T1-T4, PG, F, U, J, P1-P4, S
@@EXIT PAGE NUMBER IS NOT RETURNED IN PG, CALLER MUST SAVE.
@@CALLS IOSEL, WHICH CALLS KONTROLLER DEPENDENT ROUTINES, STRTIO
@@RESTRICTIONS CORE PAGE MUST NOT HAVE SWAP I/O IN PROGRESS
ALREADY BEFORE CALLING. CALLER IS RESPONSIBLE FOR
HANDLING ALL INFO REGARDING THE PAGE'S TRANSITION TO THE
SWAP IN PROGRESS STATE (E.G. MARKING PAGE CLEAN, PUTTING
JOBS INTO WAIT FOR THE PAGE, ETC.)
CORE PAGE MUST BE GREATER THAN OR EQUAL TO THE FIRST PCB
CORE PAGE IN THE SYSTEM, AND MUST BE LESS THAN OR
EQUAL TO THE LAST CORE PAGE IN THE SYSTEM.
@@FUNCTION TAKE PAGE OFF LIST IT WAS ON.  INSERT REQUEST ON
UNIT'S I/O QUEUE SOAS TO KEEP I/O QUEUE SORTED
WITH RESPECT TO UNIT PAGE NUMBERS. CALL IOSEL TO START I/O
IF NOT ALREADY STARTED, AND RETURN.
@@;


SWPENQ::CAML	PG,MINPCB	;IS PAGE IN BOUNDS?
	CAML	PG,MEMSZP	;ONLY THESE PAGES CAN SWAP
SWPOOR:: STOPCD (.,STOP,SWPOOR,,<Swapper: Out of range>)   ;;SWPENQ+2
	LDB	T1,PGYADR	;GET ADDRESS
	CAMN	T1,ADRDUM	;THIS REALLY HAVE A DISK PAGE?
	 STOPCD (.,STOP,SWPNDP,,<Swapper: Not a disk page>);;SWPENQ+5
	DSKOFF			;LET NO ONE CHANGE THINGS. DO THIS
				; BEFORE REMLST, SINCE IF THIS IS
				; A PCB PAGE, COULD GO FROM SWAP DONE
				; LIST TO SPR LIST AT INTERRUPT LEVEL.
	PUSHJ	P,REMLST	;TAKE CORE PAGE OFF OLD LIST
	LDB	U,PGYUNI	;GET UNIT NUMBER FROM REQUEST
	CAILE	U,UNTLEN##	;Don't exceed size of UNTTBL
SWPUOR:: STOPCD (.,STOP,SWPUOR,PRTPGY,<Swapper: Unit out of range>)
	MOVE	U,UNTTBL(U)	;GET UNIT DATA BLOCK
	JUMPE	U,SWPUOR	;Cannot do I/O to off-line drive
	MOVEI	T1,SPR.N	;LIST PAGE WILL BE GOING ON
	DPB	T1,PGYLST	;PUT IT THERE.
IFCPU (KL),<LDB	T1,PGYSOP	;GET DIRECTION
	MOVE	T1,@[CSUCNT
		     CSVCNT](T1) ;GET PROPER COUNT
	MOVEM	T1,@PGYCSH	;REMEMBER SWEEP NUMBER
>;END IFCPU (KL)
	LDB	F,UNYPGL
	JUMPE	F,SWPEN0	;NO REQUEST WAITING, QUE THIS
	MOVEI	T3,0		;THIS IS THE 'PREVIOUS PAGE'
	LDB	T1,PGYPNO	;GET THE DESIRED ADDRESS
	EXCH	F,PG		;SAVE REQUEST PAGE IN F
SQLP:	LDB T2,PGYPNO		;GET ADDRESS OF REQUEST IN QUE
	CAMG	T1,T2		;SEARCH TILL ONE GREATER
	JRST	SWPQFD		;THIS IS IT
	MOVE	T3,PG
	LDB	PG,PGYFPL	;GET NEXT
	JUMPN	PG,SQLP		;CONTINUE SEARCH
SWPQFD:	SKIPE PG
	DPB	F,PGYBPL	;LINK IN BACK POINTER
	EXCH	F,PG
	DPB	F,PGYFPL	;AND FORWAR LINK
	DPB	T3,PGYBPL	;SET BACK LINK
	EXCH	PG,T3
	JUMPE	PG,[DPB T3,UNYPGL	;SET UP LIST IF PREVIOUS=0
		JRST .+2]
	DPB	T3,PGYFPL	;ELSE SET FORWARD LINK IN OLD
	MOVE	PG,T3		;RESTORE PG
SQENT:	SOS	DSKAPC		;NEW PG ON QUEUES
	HRRZ	J,UNIKON(U)	;J/ KONTROLLER ADDRESS
	PUSHJ	P,IOSEL
	DSKON
	POPJ	P,

SWPEN0:	DPB	F,PGYFPL	;REQUEST IS FIRST AND LAST
	DPB	F,PGYBPL	;ON THE UNIT'S SWAP IN PROGRESS LIST
	DPB	PG,UNYPGL	;REQUEST IS FIRST ON LIST
	JRST	SQENT		;AND GET THINGS STARTED

DSKAPC:: Z		;SYSTEM-WIDE ACTIVE-PAGE COUNT ON ALL UNITS
			;KEPT AS -(NUMBER OUTSTANDING PAGES)
;SWPSTR ACTUALLY STARTS THE I/O PROCESS FOR THE LIST IN UNYPAC

STRTIO:
SWPSTR:	LDB PG,UNYPAC
	LDB S,PGYSOP
IFCPU (KL),<
	MOVE	T1,@PGYCSH	;START WITH SWEEP NUMBER FOR PAGE WE KNOW WE'LL DO
	MOVEM	T1,CSNSAV
>;END IFCPU (KL)
	SKIPN	S
	 SKIPA	T1,KONRED(J)	;IN  = APXRED,BPXRED,RMXRED
	MOVE	T1,KONWRT(J)	;OUT = APXWRT,BPXWRT,RMXWRT
	PUSHJ	P,(T1)		;Set up for I/O, UNIPAG has disk page address
	PUSHJ	P,SETTIM
SWPGL1:
IFE FTDPAG,<
	LDB	T2,UNYPPL	;SEE IF FINISHING UP FROM ERROR
	JUMPN	T2,SWPPST	;NONZERO IF SO
>
	LDB	T3,PGYPNO	;GET THE STARTING ADDRESS
	MOVE	T2,PG		;THE FIRST PAGE
	MOVE	T1,PG		;TO BOTH (T1 WILL INC AS WE FIND MORE)

SWPGLP:	LDB	PG,PGYFPL	;GET THE NEXT PAGE
	JUMPE	PG,SWPST1	;START IT UP, OUT OF LIST
	LDB	T4,PGYSOP
	CAME	T4,S
	 JRST	SWPST1		;DIFFERENT DIR, START IT
	LDB	T4,PGYPNO	;GET PAGE NUMBER
	ADDI	T3,1
	CAME	T3,T4
	 JRST	SWPST1		;DISCONTINUOUS ADDRESS, START IT
	CAIN	PG,1(T1)	;DISCONTINUOUS CORE ADDRESS?
	 AOJA	T1,SWPST0	;NO, INCREMENT AND CONTINUE
	SUBI	T1,-1(T2)	;CORE IS DISCONTINUOUS, GET NUMBER OF PAGES
IFE FTDPAG,<
	LSH	T1,P2WLSH	;CONVERT TO WORDS
	LSH	T2,P2WLSH	;CONVERT ADDRESS
>
;P034/P05 Changed to use pages instead of words.  UNIPAG has disk address.
;	  T1 has number of pages to transfer, T2 has physical page number.
	PUSHJ	P,@KONADD(J)	;ADD TO SWAP LIST
	 PJRST	SWPSTD		;OUT OF ROOM OR SOMETHING.
IFCPU (KL),<
	MOVE	T4,@PGYCSH	;GET SWEEP NUMBER FOR THIS REQUEST
	CAMLE	T4,CSNSAV	;IF LARGER THAN LARGEST SEEN
	 MOVEM	T4,CSNSAV	;THEN THIS IS LARGEST SEEN.
>;END IFCPU (KL)
	JRST	SWPGL1		;START UP AGAIN, MORE TO DO

IFCPU (KL),<
SWPST0:	MOVE	T4,@PGYCSH	;GET SWEEP NUMBER FOR THIS PAGE.
	CAMLE	T4,CSNSAV	;IS THIS BIGGER THAN HIGHEST WE'VE SEEN?
	 MOVEM	T4,CSNSAV	;YES, THIS IS NEW SWEEP NUMBER
	JRST	SWPGLP		;GO SEE IF CAN ADD ANOTHER.
>;END IFCPU (KL)

IFNCPU (KL),<SWPST0==SWPGLP>

SWPST1:	SUBI	T1,-1(T2)	;END OF LIST OR DISK IS DISCONT.
IFE FTDPAG,<
	LSH	T1,P2WLSH	;# OF WORDS TO TRANSFER
	LSH	T2,P2WLSH	;WORD ADDRESS OF START
SWPST2:				;HERE TO RETRY A PARTIAL PAGE TRANSFER
>
;P034/P05 Changed to use pages instead of words.
;	  T1 has number of pages to transfer, T2 has physical page number
	PUSHJ	P,@KONADD(J)	;ADD TRANSFER TO THE LIST
	  JFCL			;LIKE ABOVE BUT CAN NOT CONTINUE
	PFALL	SWPSTD		;SWAP START DONE

SWPSTD:			;Here when contiguous disk transfer is set up
IFCPU (KL),<
	MOVE	T3,S		;GET DIRECTION OF IO
	MOVE	T4,CSNSAV	;GET LARGEST SWEEP NUMBER
	CAME	T4,@[CSUCNT
		     CSVCNT](T3) ;NEED A SWEEP?
	 PJRST	[AOS CSHSAV	;NO, COUNT A SAVED SWEEP
		 PJRST @KONFIN(J)] ;AND START TRANSFER UP.
	JUMPN	T3,SWPCSV	;DO VALIDATE IF ITS OUTPUT
	CSHUNL			;INPUT, START AN UNLOAD.
	CAMN	T1,CSUCNT	;SWEEP NUMBER CHANGE YET?
	 JRST	.-1		;NO, WAIT FOR APR INTERRUPT
	PJRST	@KONFIN(J)	;YES, CAN START I/O NOW.

SWPCSV:	CSHVAL			;IT WAS AN OUTPUT, DON'T UNLOAD CACHE
	CAMN	T1,CSVCNT	;WAIT UNTIL VALIDATE COMPLETES
	 JRST	.-1
>;END IFCPU (KL)
IFCPU (KS),<
	SKIPN	S		;SKIP IF OUTPUT
	 CSHIVL			;ON INPUT INVALIDATE CACHE
>;END IFCPU (KS)
	PJRST	@KONFIN(J)	;GO START UP I/O

IFCPU (KL),<
CSNSAV:	BLOCK	1	;HIGHEST SWEEP NUMBER SEEN IN CURRENT GROUP OF I/O REQUESTS
>;END IFCPU (KL)

IFE FTDPAG,<
SWPPST:	LSH	T2,B2WLSH	;FIND NUMBER OF WORDS ALREADY TRANSFERED
	MOVEI	T1,1000
	SUB	T1,T2		;THIS IS THE NUMBER LEFT TO DO
	LSH	PG,P2WLSH
	ADD	T2,PG		;THIS IS THE ADDRESS
	JRST	SWPST2		;GO
>  ;End IFE FTDPAG
;SELECT THE I/O TRANSFER TO BE STARTED. CALLED AT INTERUPT
;LEVEL OR AT UUO LEVEL WITH DSKOFF IN EFFECT

;I	Idle - UNISTS=0
;PW	Position wait - start monitor seek when kontroller is free
;P	Positioning - when seek done, select best XFR and go to TWF
;SW	Seek wait - user has issued a SEEK uuo, wait for kontroller
;S	Seek - when seek done, calculate best XFR and go to P or I
;RS	Read status - when done, return sense bytes to user
;CW	Capacity wait - determine size of disk when kontroller is free
;C	Capacity test in progress - when done, inform ONCDSK
;TW	Transfer wait - start XFR on fixed head disk when kontroller is free
;TWF	Transfer wait fixed - position done or retry needed, start current XFR
;T	Transfer - go to I if XFR OK, go to TWF if retry needed
;R	RECAL in progress - go to PW (go to TWF if SA10 which avoids PW and P)
;OW	Operator wait - human intervention required (drive off-line)

IOSEL::	PUSH	P,U
	SKIPN	UNISTS(U)
	 JRST	IOIDLE		;The unit is currently idle
	SKIPGE	KONPOS(J)	;Does this unit position?
	 JRST	IOCHN		;No, no seeks needed for fixed head disks
	SKIPGE	KONLTM(J)	;Need to do latency optimization?
	 JRST	IOINC1		;No, skip all this for disks on SA10

;Start multiple overlapping seeks on the units on this kontroller

IOKON:	SKIPGE	KONPTR(J)	;Is the kontroller busy?
	 JRST	UXPOPJ		;Cannot proceed until it is free
IOKON0:	MOVE	T1,UNISTS(U)
	CAIN	T1,CWCOD	;Part of the capacity test involves seeks
	 PUSHJ	P,CPYKON	;Start up capacity test if in CW
	CAIE	T1,SWCOD
	CAIN	T1,PWCOD
	 SKIPA			;Start position of SW or PW
	  JRST	IOKON1		;See if next unit needs a position operation
	AOS	UNISTS(U)	;Set to S or P
	CAIN	T1,SWCOD	;Is this a user request (SEEK UUO)
USRSEK:	 AOSA	UNIUSC(U)	;Count user
MONSEK:	AOS	UNIMSC(U)	; or monitor seek
	PUSHJ	P,SETTIM	;Set 3 second timer
	PUSHJ	P,@KONPOS(J)	;Start the position
IOKON1:	HLRZ	U,UNIKON(U)	;Get next unit on kontroller
	CAME	U,(P)		;Is it the one we started with?
	 JRST	IOKON0		;No, check it

;Start

IOCHN:	HRRZ	P1,KONCHN(J)	;POINTER TO CHANNEL
	SKIPGE	CHNBSY(P1)	;IS IT IDLE
	 JRST	UXPOPJ		;NO, DONE
	MOVEI	P1,0		;THE "BEST" UNIT
	MOVEI	P2,1		;JUST TO MAKE IT NON-ZERO
IOCHN0:	MOVE	T1,UNISTS(U)
	CAIN	T1,CWCOD	;Part of the capacity test is a read transfer
	 PUSHJ	P,CPYKON	;START CAPACITY TEST
	CAIN	T1,TWFCOD	;TWF if already on cylinder or retry needed
	 JRST	IOCHNF		;Use selected position in UNIPAG/UNIBLK
	CAIN	T1,TWCOD	;Only fixed head disks are ever in TW
	 PUSHJ	P,PIKTRN	;TW, pick best transfer for drum
IOCHN1:	HLRZ	U,UNICHN(U)
	CAME	U,(P)		;BACK WHERE WE STARTED?
	 JUMPN	P2,IOCHN0	;THIS IS WHY WE MADE IT NON-ZERO, IDEAL TRANS?
	SKIPN	U,P1		;DID WE SEE A TRANSFER
	 JRST	UXPOPJ		;NO
	HRRZ	J,UNIKON(U)	;POINT TO CORRECT KONTROLER
	MOVEI	T1,TCOD
	MOVEM	T1,UNISTS(U)
	MOVSI	T1,(1B0)
	HRRZ	P1,KONCHN(J)	;POINTER TO CHANNEL
	IORM	T1,CHNBSY(P1)	;Mark channel busy
	IORM	T1,KONPTR(J)	;Mark kontroller busy
STRTIU:	PUSHJ	P,STRTIO	;START I/O TRANSFER
UXPOPJ:	POP	P,U
	HRRZ	J,UNIKON(U)
	POPJ	P,
;HERE IF THE UNIT IS IDLE

IOIDLE:	SKIPGE	KONPOS(J)	;DOES UNIT POSITION?
	 JRST	IOINPS		;No, fixed head disks do not seek
	SKIPGE	KONLTM(J)	;Ignore latency optimization?
	 JRST	IOINCH		;Yes, avoid PW or TWF on SA10, go to T
	PUSHJ	P,PIKPOS	;PICK THE BEST POSITION
	  JRST	IOKON		;NO TRANSFERS WAITING
	MOVEI	T1,PWCOD
	SKIPN	P2		;P2 HAS CYL DIFF, WAS IT 0
	 MOVEI	T1,TWFCOD	;IF YES, TWF NOT PW
	MOVEM	T1,UNISTS(U)
	JRST	IOKON		;GO SEE IF KON IS FREE

;IOIDLE - No Position Seek required (for FH disks)

IOINPS:	MOVEI	T1,TWCOD	;Set TW (fixed head disks only)
	LDB	P1,UNYPGL	;IS THERE A TRANSFER WAITING?
	JUMPE	P1,IOCHN	;NO, LEAVE IDLE.
	MOVEM	T1,UNISTS(U)	;YES, SET TO TW
	JRST	IOCHN		;AND SEE IF CHANNEL IS READY

;IOIDLE - No Channel needed (for IBM disks on SA10)

IOINCH:
IFCPU(<KI,KL>),<;BPXKON only - Controllers on SA10 keep an error log
	MOVSI	T1,UNPRRS##
	TDNE	T1,UNIDES(U)	;Need to read buffered log?
	 JRST	RDRST		;YES
	SKIPE	UNIOLV##(U)	;Is there an other logical volume?
	 SKIPN	@UNIOLV##(U)	;Yes, if it is not idle, don't start this unit
>  ;End IFCPU(KI,KL)
	PUSHJ	P,PIKPOS	;Pick best unit to start (IBM disks)
	  JRST	UXPOPJ		;No transfers, must be done
IOINC2:	MOVEI	T1,TCOD		;Go directly to T (bypass TWF)
	MOVEM	T1,UNISTS(U)
	JRST	STRTIU		;AND GO START IT UP

IOCHNF:	HRRZ	J,UNIKON(U)	;Here if was in TWF (happens on retry)
IFE FTDPAG,<
	MOVE	T1,UNIBLK(U)	;CHECK LATENCY FOR REQUESTED BLOCK
>
IFN FTDPAG,<
	MOVE	T1,UNIPAG(U)	;CHECK LATENCY FOR REQUESTED PAGE
>
IFCPU(<KI,KL>),<;KONLTM is read buffered log on SA10
	PUSHJ	P,@KONLTM(J)	;Get # of microseconds until sector arrives
>
	SKIPE	P1		;FIRST ONE IS ALWAYS BEST
	CAMGE	T1,P2
	 PUSHJ	P,SAVBST	;BEST SO FAR
	JRST	IOCHN1		;UNICDA ALREADY SET

IOINC1:	MOVEI	T1,TWFCOD
	CAME	T1,UNISTS(U)	;IS IT IN TWF?
	 JRST	UXPOPJ		;NO, NOTHING TO DO
	JRST	IOINC2		;YES, BACK ON LINE OR RECAL FINISHED

CPYKON:	AOS	UNISTS(U)	;Increment CW to C
	HRRZ	T1,KONCPY(J)	;NOTE: LH of KONCPY has 16 unit bits
	PUSHJ	P,(T1)		;Go to capacity test
	MOVE	T1,UNISTS(U)	;Restore T1
	POPJ	P,		;Continue down skip chain

IFCPU(<KI,KL>),<;SAX only
RDRST:	ANDCAM T1,UNIDES(U)	;RESET FLAG
	MOVEI T1,RSCOD
	MOVEM T1,UNISTS(U)
	HRRZ J,UNIKON(U)	;JUST TO MAKE SURE
	PUSHJ P,SETTIM
	PUSHJ P,@KONLTM(J)	;READ BUFFERED LOG (instead of latency)
	JRST UXPOPJ
>  ;End IFCPU(KI,KL)

COMMENT ! PIKPOS & PIKCYL
PURPOSE: PICK THE BEST POSITION & CYLINDER TO DO NEXT
EXPECTS: U/UNIT
DESTROYS:  T1-T3,P1-P3,PG
RETURNS:
  NOSKIP: NO PAGES ON UNYPGL,NOTHING TO DO. T3/BLOCKS PER CYL
  SKIP: P1/ 1ST BLK OF NEXT CYL
	P2/ NUMBER OF CYLS TO MOVE
	P3/ PG/ OPTIMUM PG
	T3/ BLOCKS PER CYL
FUNCTION: CHAIN DOWN UNYPGL LOOKING FOR LARGEST DSK PAGE
 NUMBER .LE. UNICYL(U).  (IF ONE FOUND ON SAME CYL
 AS UNICYL(U), SOSLE FAIRNESS COUNT AND USE THIS ONE
 IF LARGER THAN LAST PAGE DONE ON THIS CYL AND FAIRNESS CNT
 NOT EXHAUSTED). AT THE POINT WE ENCOUNTER A DSK PAGE NUMBER
 WHOSE CYL IS > UNICYL, RESET FAIRNESS, CHECK
 WHICH DIRECTION WE'RE GOING. IF WE ARE GOING TOWARDS LARGER
 DISK PAGE NOS., EXIT WITH THIS AS THE OPTIMUM PAGE. IF
 WE WERE GOING TOWARDS SMALLER PAGES, USE THE LARGEST PAGE
 SMALLER THAN UNICYL WHICH WE ALREADY FOUND, IF ANY; OTHERWISE
 SET DIRECTION TOWARDS LARGER PAGES (="FORWARD") AND EXIT WITH THIS
 ONE AS OPTIMUM PAGE.

 IF ALL PAGES ON UNYPGL HAVE CYL < UNICYL, SET DIRECTION
 TOWARDS SMALLER (="BACKWARDS") AND USE LARGEST FOUND.

CAVEAT:  THIS IS A ROUGH DESCRIPTION OF THE DSK ALGORITHM,
 AND I DON'T GUARANTEE IT TO BE EXACT; MOREOVER, SOME
 BEING MAY CHANGE THE CODE WITHOUT CHANGING THIS COMMENT.
 IT IS INTENDED AS AN INTRODUCTORY GUIDE ONLY, TO THOSE WISHING
 TO PENETRATE THIS MYSTERIOUS REALM, AS I HAVE.
 GOOD LUCK.  MAGIC IS SAID TO WORK HERE. /AA
!
;THIS IS THE FAMOUS "ELEVATOR" ALGORITHM


PIKPOS:	MOVNI	P1,1		;INITIALIZE TO -1 FOR FIRST REQ SELECTED
	MOVEI	P3,0		;NONE SAVED
IFE FTDPAG,<
	LDB	T3,UNYBPY	;BLOCKS PER CYLINDER (ELEVATOR ALGORIGTHM)
>
IFN FTDPAG,<
	LDB	T3,UNYPPY	;PAGES PER CYLINDER (ELEVATOR ALGORIGTHM)
>
	LDB	PG,UNYPGL	;PAGES TO TRANSFER
	JUMPE	PG,CPOPJ	;IF NO DDB'S AND NOT PAGES, EXIT
PIKPSL:	LDB	T1,PGYPNO	;GET ADDRESS FOR PAGE
IFE FTDPAG,<
	LSH	T1,P2BLSH	;CONVERT TO BLOCKS
>
PKPSP:	CAML	T1,P1		;CHECK AT ALL?
	 JSP	P2,PIKCYL	;YES, DO THE WORK
	LDB	PG,PGYFPL	;NEXT
	JUMPN	PG,PIKPSL	;MORE PAGES, CONTINUE

;BACK HERE FROM PIKCYL TO USE SAVED BEST-SO-FAR PAGE.

PKPSB:	MOVE	PG,P3		;OUT OF PAGES. GET SAVED PAGE.
	MOVSI	T2,(1B0)	;CHANGE DIRECTION TO BACKWARDS.
	IORM	T2,UNIDIR(U)	;THIS IS A NORMAL WAY OUT IN BACKUP MODE
PIKPS2:	LDB	T1,PGYPNO	;FOR A PAGE, GET ADDRESS
IFE FTDPAG,<
	LSH	T1,P2BLSH	;CONVERT TO BLOCKS
	MOVEM	T1,UNIBLK(U)	;SET DESIRED BLOCK
>
IFN FTDPAG,<
	MOVEM	T1,UNIPAG(U)	;Tell BPXKON/APXKON/RMXKON the disk address
>
	IDIV	T1,T3		;FIND THE CYL
	SUB	T1,UNICYL(U)	;DIFF IS ENOUGH
	JUMPE	T1,PIKPC1	;SET UNICDA AND UNYPAC FOR SELECTED RQ
	PUSHJ	P,SETFCT	;DIFFERENT CYL, RESET FAIRNESS
PIKPC1:	MOVM	P2,T1		;GET MAGNITUDE OF CHANGE FOR CALLERS
	DPB	PG,UNYPAC	;AND PAGE NUMBER (F=0 FOR PAGE RQ)
	PJRST	CPOPJ1		;SKIP RETURN
;PIKCYL DOES THE REAL WORK FOR EACH CYL FOUND
;THE CALL IS JSP P2,PIKCYL
;IS GOES TO PIKPS2 TO USE CURRENT REQUEST
;IT RETURNS TO CALL+1 TO CONTINUE SCAN
;IT RETURNS TO PKPSB TO USE SAVE  BEST REQUEST

PIKCYL:	IDIV	T1,T3		;GET CYL OF REQUEST
	CAML	T1,UNICYL(U)	;SMALLER THAN CURRENT?
	 JRST	PIKCY1	;NO
PIKCYH:	MOVE	P3,PG		;SAVE PG, CLOSEST REQUEST SO FAR BELOW UNICYL
PIKCYB:	MOVEI	P1,1(T1)	;SET BLOCK FOR NEXT CYL
	IMUL	P1,T3
	JRST	(P2)		;RETURN

PIKCY1:	SUB	T1,UNICYL(U)	;SAME?
	JUMPE	T1,PIKSMC	;YES, SPECIAL PROCESSING
	PUSHJ	P,SETFCT	;RESET FAIRNESS COUNT (DIFF CYL)
	SKIPL	UNIDIR(U)	;WHICH WAY?
	JRST	PIKPS2		;FORWARD, USE THIS ONE
	JUMPN	P3,PKPSB	;BACKWARD, IF ONE SAVED, USE IT
	MOVSI	T2,(1B0)
	XORM	T2,UNIDIR(U)	;RESET DIRECTION TO FORWARD SCAN
	JRST	PIKPS2		;AND USE THIS ONE

PIKCYS:	SOSLE	UNIFCT(U)	;SAME CYL, FAIRNESS EXAUSTED?
	 JRST	PIKPS2		;NO, USE THIS ONE
	JUMPE	P3,PIKCY0	;NONE SAVED, SET DIR=FORWARD
	SKIPL	UNIDIR(U)	;WHICH WAY
	 JRST	PIKCYB		;FORWARD, JUST SET FOR NEW SEARCH CYL
	PUSHJ	P,SETFCT	;BACKWARDS, USED HELD REQUEST
	JRST	PKPSB

PIKCY0:	MOVSI	T2,(1B0)
	ANDCAM	T2,UNIDIR(U)	;RESET DIR=FORWARD IN CASE ONE THERE
	JRST	PIKCYH		;AND REMEMBER THIS IN CASE NONE

SETFCT:	MOVE	T2,T3
	LSH	T2,-5		;GET A MORE REASONABLE NUMBER
	MOVEM	T2,UNIFCT(U)
	POPJ	P,

PIKSMC:	LDB	T2,PGYPNO	;GET ADDRESS BACK
IFE FTDPAG,<
	LSH	T2,P2BLSH	;CONVERT TO BLOCKS
	CAMLE	T2,UNIBLK(U)
>
IFN FTDPAG,<
	CAMLE	T2,UNIPAG(U)	;Compare with requested disk page address
>
	 JRST	PIKCYS		;STILL GOING UP, CONTIMUE
	AOS	P1,T2		;JUST LOOK A LITTLE HIGHER
	JUMPN	P3,PKPSB	;ALREADY GOT ONE SAVED, GO
	MOVSI	T2,(1B0)
	ANDCAM	T2,UNIDIR(U)
	MOVE	P3,PG		;SAVE THIS
	SOS	UNIFCT(U)	;JUST IN CASE
	JRST	(P2)		;AND CONTINUE SCAN
;SUBROUTINE TO UPDATE UNIT STATISTICS AFTER IO
;ENTER WITH P4=NUMBER OF BLOCKS,  T1=UNIXRC(U)   (X=M,B OR D)
UPSTAT:	TLNE	S,IO		;WRITING?
	 ADDI	T1,1		;YES. UNIXWC=UNIXRC+1
	ADDM	P4,(T1)		;UPDATE WORD IN UNIT BLOCK
	POPJ	P,		;AND RETURN

COMMENT;@@SUBROUTINE SMSTAT
@@PURPOSE UPDATE UNIT DATA BLOCK COUNTS (INCREMENT BY "N" BLOCKS)
@@ENTRY T1/ NUMBER OF BLOCKS DONE
	T2/ RETRIEVAL POINTER FOR BLOCKS
	S/  I/O STATUS (MODE AND IO BIT)
@@ACCUM USES T1-T3, U
@@EXIT ALWAYS NON-SKIP.
@@FUNCTION INCREMENT APPROPRIATE UNIT DATA BLOCK COUNT.
@@;

SMSTAT::LDB	U,RBYUNI	;GET UNIT NUMBER
	MOVE	U,UNTTBL(U)	;GET UNIT DATA BLOCK ADDRESS
	LDB	T3,PIOMOD	;GET MODE
	CAIL	T3,SD		;SKIP IF NOT DUMP MODE
	 JRST	SMSTA1		;DO DUMP MODE

	MOVEI	T3,UNIBRC(U)	;ASSUME READ
	TLNE	S,IO		;SKIP IF READ
	 MOVEI	T3,UNIBWC(U)	;NO, WRITE.
	ADDM	T1,(T3)		;BUMP COUNT AND
	POPJ	P,		;RETURN

SMSTA1:	MOVEI	T3,UNIDRC(U)	;ASSUME READ
	TLNE	S,IO		;SKIP IF READ
	 MOVEI	T3,UNIDWC(U)	;WRITE
	ADDM	T1,(T3)		;INCREMENT
	POPJ	P,		;AND RETURN.
SUBTTL	PICK THE BEST TRANSFER

;P1 HAS BEST UNIT, P2 ITS LATENCY TIME

PIKTRN:	MOVEI P3,0	;NO F FOUND
	HRRZ J,UNIKON(U)	;GET CORRECT KON
	LDB PG,UNYPGL	;START LOOKING FOR PAGE TRANSFERS
	JUMPE PG,CPOPJ	;NONE
PIKTP1:	LDB T1,PGYPNO
IFE FTDPAG,<
	LSH T1,P2BLSH	;CONVERT TO BLOCKS
>
IFNCPU(<KI,KL>),<	;Can't do latency with block multiplexor
	PUSHJ P,@KONLTM(J)	;CALCULATE TIME TO REACH THIS RECORD
>
	SKIPE P1
	CAMGE T1,P2
	 PUSHJ P,SAVBST
	JUMPE P2,PIKTP0	;BEST POSSIBLE FOUND
	LDB PG,PGYFPL	;GET NEXT PAGE
	JUMPN PG,PIKTP1
	JUMPE P3,CPOPJ	;NONE FOUND
	MOVE PG,P3	;GET BEST BACK
PIKTP0:	DPB PG,UNYPAC
	LDB T1,PGYPNO
IFE FTDPAG,<
	LSH	T1,P2BLSH	;CONVERT TO BLOCKS
	MOVEM	T1,UNIBLK(U)
>
IFN FTDPAG,<
	MOVEM	T1,UNIPAG(U)	;Set physical page address
>
	POPJ P,
SAVBST:	MOVE	P3,PG		;BEST PAGE
	MOVE P1,U
	MOVE P2,T1
	POPJ P,

ZERTIM:	TDZA T1,T1
SETTIM:	MOVEI T1,3	;SET TIMER FOR 3 SECONDS
	DPB T1,UNYTIM
	POPJ P,
SUBTTL	ONCE A SECOND TO CHECK FOR UNITS THAT ARE HUNG

UNISEC::HLRZ U,SYSUNI
	DSKOFF	;NO INTERUPTS WHILE CODE IN PROGRESS
USCLP:	LDB T1,UNYTIM
	SOJE T1,USCLP1	;ONLY IF COUNTS DOWN TO ZERO
	SKIPL T1
	DPB T1,UNYTIM	;PUT BACK IF WAS NOT ZERO
USCLP2:	HLRZ U,UNISYS(U)
	JUMPN U,USCLP
	DSKON
	PUSHJ	P,SATONC
	POPJ P,

USCLP1:	MOVE T1,UNISTS(U)
	XCT HNGCOD(T1)	;DO APPROPRIATE ACTION
	JRST USCLP2	;AND GET BACK TO THE CHECK

HNGCOD:	PHASE 0
ICOD:!	PUSHJ P,ZERTIM
PWCOD:!	PUSHJ P,ZERTIM	;THESE ARE MISTAKES, TIMER SHOULD NOT BE SET
PCOD:!	PUSHJ P,HNGPS	;POSITION OR SEEK HUNG
SWCOD:!	PUSHJ P,ZERTIM
SCOD:!	PUSHJ P,HNGPS
RSCOD:!	PUSHJ P,HNGRS
CWCOD::	PUSHJ P,ZERTIM
CCOD::	PUSHJ P,ZERTIM
TWCOD:!	PUSHJ P,ZERTIM
TWFCOD:!PUSHJ P,ZERTIM
TCOD:!	PUSHJ P,HNGT	;HUNG IN TRANSFER
RCOD:!	PUSHJ P,HNGR	;RUNG IN RECAL
OWCOD:!	PUSHJ P,OFLUNI	;UNIT IS OFF-LINE
	DEPHASE

HNGR:	MOVEI T1,PCOD	;SET TO PCOD SO GET TO TRANSFER WAIT
HNGPS:	SUBI T1,1
	HRRZ J,UNIKON(U)
	PUSHJ P,@KONSTP(J)	;TRY TO STOP IT
	 SKIPA			;STOPPED, NOW RESTART
	JRST SETTIM		;STOPPD AND RESTARTED, RETIME
	MOVEM T1,UNISTS(U)
	AOS UNIHNG(U)		;RECORD HUNG RECOV FROM POS
	PUSHJ	P,HNGUNI	;Tell OPR about hung unit
HNGCOM:	PUSHJ	P,ZERTIM	;RESET TIMER
	PJRST	IOSEL		;AND START I/O IF POSSIBLE

HNGT:	MOVSI T1,1
	ADDM T1,UNIHNG(U)	;RECORD HUNG RECOV FROM TRANS
	PUSHJ	P,HNGUNI	;Tell OPR about hung unit
	HRRZ J,UNIKON(U)
	PUSHJ P,@KONSTP(J)	;TRY TO STOP
	  SKIPA		;OK
	JRST SETTIM		;STOPPED AND RESTARTED, RETIME
	MOVEI T1,TWFCOD
	PUSHJ P,IDL1	;AND MARK IDLE
	JRST HNGCOM	;SEE ABOVE

HNGRS:	AOS UNIHNG(U)
	PUSHJ	P,HNGUNI	;Tell OPR about hung unit
	HRRZ J,UNIKON(U)
	PUSHJ P,@KONSTP(J)
	PUSHJ P,SETTIM
IFCPU (<KI,KL>),<PJRST @KONLTM(J)>	;READ BUFFERRED LOG
IFNCPU(<KI,KL>),<POPJ  P,>
;Unit is off line
OFLUNI:	MOVEI T1,ALRACT
	IORM T1,ALR620	;SET ALARM CELL
	PUSH P,U
	PUSHJ P,GETOPR
	PUSHJ P,INLMES
	BYTE (7) 7,7,7,7,7	;SOME BELLS
	ASCIZ /
UNIT /
	MOVE T2,(P)	;RESTORE U
	MOVE T2,UNINAM(T2)
	PUSHJ P,PRNAME
	PUSHJ P,INLMES
	ASCIZ / WENT OFF-LINE/
	MOVE T2,(P)
	MOVE T2,UNIDES(T2)
	TLNN T2,UNPFUS	;CHECK UNSAFE
	JRST TELOP4
	PUSHJ P,INLMES
	ASCIZ / (FILE UNSAFE)/
TELOP4:	PUSHJ P,INLMES
	ASCIZ /
PLEASE POWER IT DOWN, THEN TURN IT ON AGAIN.
/

	POP P,U
	MOVEI T1,^D60	;RESET TIME TO 1 MINUTE
	DPB T1,UNYTIM
	POPJ P,

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;								;;
;;	This routine is called to report the occurrence of	;;
;;	a true "hung" state to the system operator.  It does	;;
;;	not matter if the hung condition is immediately		;;
;;	corrected, only that it occurred at all.		;;
;;								;;
;;	Entered with U - Unit Data Block address (preserved)	;;
;;								;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

HNGUNI:	MOVEI	T1,ALRACT	;It's the Accounting flag, but who's perfect?
	IORM	T1,ALR620	;Irritate the operator
	PUSH	P,U		;Save from typeout routines
	PUSHJ	P,GETOPR	;Grab the operator's Line Data Block
	PUSHJ	P,INLMES	;In-line message
	BYTE (7) 7,7,7,7,7	;Bells (Clangor and Alarum)
	ASCIZ	/
Unit /
	MOVE	T2,(P)		;Get back Unit Data Block address
	MOVE	T2,UNINAM(T2)	;Get this unit's SIXBIT name
	PUSHJ	P,PRNAME	;Type it out
	PUSHJ	P,INLMES	;In-line message
	ASCIZ	/ Hung
/
	PJRST	UXPOPJ		;Restore UDB and return
SUBTTL OHT (OUTPUT ERROR HASH TABLE)
COMMENT;@@ SUBROUTINE INSOHT
@@PURPOSE INSERT A DP ADDRESS IN THE OUTPUT ERROR HASH TABLE (OHT)
@@ENTRY T2 HAS DP ADDRESS. 1B0-1B8 MUST BE ZERO.
@@ PG has Core Page Number of Disk Page in T2.
@@ACCUM PRESERVES DP ADDRESS IN T2, CLEARS 1B0-1B8 IN T2,
SMASHES T1,T3,T4.
@@EXIT T2 HAS DP ADDRESS. T4 HAS INDEX, SO CALLER CAN SET BITS. ALWAYS RETURN NON-SKIP.
@@RESTRICTIONS CALL AT DISK INTERRUPT LEVEL OR DSK PI OFF ONLY,
ELSE CAN'T LOOK AT HEADER DATA (MAY BE CHANGED BY INSOHT, AND
THIS ROUTINE IS NOT REENTRANT.)
@@FUNCTION IF DP IS ALREADY IN OHT, RETURN.
OTHERWISE PUT DP IN OHT, INCREMENT OHTNUM, RETURN.
@@;

INSOHT::PUSHJ	P,SRCOHT	;SEE IF ITS THERE ALREADY
	  AOSA	OHTNUM		;NO, GOING TO PUT IT IN, INCREMENT
	JRST	INSOH2		;Count multiple calls for same DP,
				; overwrite OHTCPN entry, exit w/T4=index
	MOVSI	T4,-OHTLEN	;SET TO SEARCH OHTTAB FOR FREE CELL
INSOH1:	SETCM	T1,OHTTAB(T4)	;GET COMPLEMENT OF DATA
	TRNN	T1,-1		;IF ALL ZERO, THEN ITS FREE.
	  TLNE	T1,777		;SKIP IF FREE
	  JRST	INSOH3		;NOT FREE.
	LDB	T1,T3		;FREE. GET OLD FIRST
	DPB	T4,T3		;HEADER GETS NEW FIRST
	DPB	T1,[POINT OHTLNS,T2,OHTLNP]
	MOVEM	T2,OHTTAB(T4)	;STORE NEW DATA OVER THE -1
	TLZA	T2,777000	;CLEAR ALL BUT DISK ADDRESS.
INSOH2:	  AOS	OHTREP		;# times called gtr once for same DP
	TLZ	T4,-1		;Clear out crap
	ROT	T4,-1		;Make low-order bit the sign bit
	SKIPGE	T4
	 JRST	.+3
	HRLM	PG,OHTCPN(T4)	;Write CPN into even-numbered table entry
	SKIPA
	  HRRM	PG,OHTCPN(T4)	;Or odd-numbered entry
	ROT	T4,1		;Restore OHTTAB index
	POPJ	P,		;AND RETURN.

INSOH3:	AOBJN	T4,INSOH1	;NOT FREE, LOOK FOR ANOTHER, CRASH WHEN FULL
	 STOPCD (.,STOP,OHTFUL,,<Output Hash Table Full - Too many DP errors>);;INSOH3+1
COMMENT;@@SUBROUTINE REMOHT
@@PURPOSE REMOVE DP ADDRESS FROM OHT. CALLED BY REMOVE VP.
@@ENTRY T2 CONTAINS DP ADDRESS
@@ACCUM PRESERVES T2, SMASHES T1,T3,T4
@@EXIT  ALWAYS NON-SKIP.  DSK PI CHANNEL STATE DESTROYED.
@@RESTRICTIONS DP MUST BE IN OHT. CALL ONLY AT UUO LEVEL,
REMOHT CAN HAVE ONLY ONE CALLER AT A TIME.
@@FUNCTION CALL SRCOHT TO FIND THE ENTRY TO BE REMOVED.
TURN DSK PI CHANNEL OFF. IF PREVIOUS POINTER IS NOT THE HEADER
POINTER, JUST REMOVE THE ENTRY BY POINTING PREVIOUS POINTER
TO NEXT ENTRY, SET REMOVED ENTRY DATA TO -1. IF PREVIOUS WAS THE
HEADER, MAY HAVE BEEN CHANGED AFTER RETURN FROM SRCOHT
AND BEFORE DSKPIF. CHECK TO SEE THAT PREVIOUS POINTER
STILL POINTS TO FOUND ENTRY. IF NOT (NEW ENTRY SNUCK IN AT HEADER)
CHAIN THRU HASH CHAIN UNTIL FIND THE POINTER THAT POINTS TO
ENTRY TO BE REMOVED. CRASH IF CANNOT FIND REMOVED ENTRY
AGAIN. THEN REMOVE ENTRY NORMALLY.
@@;


REMOHT::PUSHJ	P,SRCOHT	;FIND THE ENTRY, MUST BE HERE OR CRASH
OHTENF:: STOPCD (.,STOP,OHTENF,,<Output error Hash Table - Entry not found>);;REMOHT+1
	DSKOFF			;TURN OFF DSK PI
	CAME	T1,T3		;DID SRCOHT GIVE US HEADER PTR?
	  JRST	REMOH2		;NO, ITS SAFE, ENTRIES ONLY ADDED AT HEAD
				; OF CHAIN, AND ONLY REMOVED AT UUO LEVEL.
REMOH1:	LDB	T1,T3		;HEADER. GET WHAT IT POINTS TO.
	CAMN	T1,T4		;MOST OF THE TIME, ITS OK.
	  JRST	REMOH2		;THIS IS STILL THE FIRST ENTRY
	CAIN	T1,ENDOHT	;MAKE SURE ENTRY DIDN'T VANISH
	 STOPCD (,XCT,OHTENF)	;; It did!  So, CRASH   ;;REMOH1+4
	MOVEI	T3,OHTTAB(T1)	;GET ADDRESS OF ENTRY
	HRLI	T3,(POINT OHTLNS,0,OHTLNP)	;FRESH BYTE POINTER
	JRST	REMOH1		;AND GIVE THAT IF WHAT IT POINTS TO IS ENTRY
				; THAT IS GOING AWAY.

REMOH2:	SOS	OHTNUM		;ONE LESS NOW.
	LDB	T1,[POINT OHTLNS,OHTTAB(T4),OHTLNP] ;GET NEW NEXT MEMBER
	DPB	T1,T3		;PREVIOUS POINTER POINTS TO NEXT
	SETOM	OHTTAB(T4)	;THIS WORD NOW FREE.
	DSKON		;ALLOW INSERTIONS AGAIN.
	POPJ	P,		;RETURN.
COMMENT;@@SUBROUTINE SRCOHT
@@PURPOSE USED WHEN SEARCHING OHT OR WHEN INSERTING OR DELETING
AN ENTRY FROM OHT. CALLERS SHOULD DO SKIPN OHTNUM BEFORE
CALLING TO SAVE TIME.
@@ENTRY T2 CONTAINS DP ADDRESS TO SEARCH FOR.
CAN CALL BOTH AT INTERRUPT AND UUO LEVEL.
@@ACCUM USES T1,T3,T4. PRESERVES T2.
@@EXIT IF DP NOT FOUND, NON-SKIP RETURN WITH
	T3/ BYTE POINTER TO HEADER FIELD.
	     (USE ONLY IF CALLING AT DSK IRP LEVEL OR DSKPIF)
IF DP IS FOUND, SKIP RETURN WITH
	T1/ HEADER POINTER (FOR VALIDITY CHECK OF T3).
	T3/ BYTE POINTER TO LAST LINK FIELD (MUST BE CHECKED, SEE
	     RESTRICTIONS)
	T4/ INDEX OF DP'S CELL.
@@RESTRICTIONS CALLER MUST CHECK VALIDITY OF LAST LINK POINTER

IF IT POINTS TO THE HEADER BYTE BY TURNING OFF DSK PI CHANNEL

AND MAKING SURE A NEW ENTRY DID NOT SNEAK IN IF ENTRY IS FOUND.

IF ENTRY IS NOT FOUND, CALLER MUST NOT USE BYTE POINTER TO HEADER FIELD
UNLESS DSK PI IS OFF OR AT DSK PI LEVEL, ELSE DATA COULD CHANGE.
@@FUNCTION COMPUTE HASH INDEX FOR DP. GET BYTE POINTER TO PROPER
HEADER BYTE FOR HASH CODE. IF CONTENTS OF HEADER IS ENDOHT,
RETURN WITH THE BYTE POINTER TO THE HEADER. ELSE, SAVE THE
POINTER TO THE HEADER. LOOK FOR THE DP. IF FOUND, GIVE SKIP
RETURN WITH BYTE POINTER TO PREVIOUS MEMBER (OR HEADER)
IN T3, INDEX IN T4. IF NOT FOUND, RETURN WITH BYTE
POINTER TO HEADER BYTE IN T3.  NOTE THAT A NEW ENTRY CAN SNEAK IN
WHILE SEARCHING, BUT NEW ENTRIES ARE ADDED TO BEGINNING OF
CHAIN ONLY, SO WORST THAT CAN HAPPEN IS THAT SEARCH WILL FAIL
TO FIND ENTRY THAT SNUCK IN, BUT THIS IS NO WORSE
THAN IF ENTRY SNUCK IN AFTER RETURN FROM SRCOHT.
CHAIN IS ALWAYS INTACT, REMOHT ONLY CALLED AT UUO LEVEL.
@@;

SRCOHT::MOVE	T3,T2		;COPY SO DON'T DESTROY T2
	IDIVI	T3,OHTLEN	;GET DP'S HASH INDEX IN T4
	MOVE	T3,T4		;GET INTO T3 FOR IDIVI AGAIN
	IDIVI	T3,OHTHPW	;INDEX TO OHTBYT IN T4, TO OHTHED IN T3.
	ADD	T3,OHTBYT(T4)	;GET POINTER TO HEADER FIELD.
	LDB	T4,T3		;GET FIRST ENTRY INDEX
	CAIN	T4,ENDOHT	;CHAIN EMPTY?
	POPJ	P,		;YES, RETURN WITH T3 POINTER TO HEADER BYTE
	PUSH	P,T3		;REMEMBER POINTER TO HEADER IN CASE SEARCH FAILS
SRCOH1:	MOVE	T1,T2		;COPY DP ADDRESS
	XOR	T1,OHTTAB(T4)	;T1 HAS INDEX IN 1B0-8, XOR IN THE REST
	TRNN	T1,-1		;SKIP IF ANY DIFFERENT BITS IN RH
	TLNE	T1,ENDOHT	;SKIP IF ALL BITS THE SAME IN RH OF LH
	JRST	SRCOH2		;NO MATCH.
	TLNN	T3,-1		;IF NOT THE HEADER POINTER,
	ADD	T3,[POINT OHTLNS,OHTTAB,OHTLNP] ;TURN T3 INTO POINTER TO LINK.
	POP	P,T1		;THROW AWAY HEADER POINTER
	JRST	CPOPJ1		;MATCHING CELL IN T4. SKIP RETURN.

SRCOH2:	LDB	T1,[POINT OHTLNS,T1,OHTLNP] ;GET INDEX.
	CAIN	T1,ENDOHT	;THIS THE LAST CELL?
	JRST	[POP P,T3	;GET HEADER POINTER IN T3 TO RETURN
		 POPJ P,]	;AND GIVE FAIL RETURN.
	MOVE	T3,T4		;NOT DONE, REMEMBER LAST INDEX
	MOVE	T4,T1		;GET NEXT TO DO IN T4
	JRST	SRCOH1		;AND GO CHECK FOR A MATCH
;ROUTINE TO INIT OHT. PRESERVES T2-T4, SMASHES ONLY T1.

OHTINI::SETOM	OHTHED		;HEADER BYTES ALL ONES, ALL SLOTS -1.
	MOVE	T1,[OHTHED,,OHTHED+1]
	BLT	T1,OHTTAB+OHTMAX
	SETZM	OHTNUM
	POPJ	P,

IFNDEF OHTLEN,<OHTLEN==77>
IFGE <OHTLEN-100>,<PRINTX OHTLEN MUST BE LESS THAN 100 OCTAL>

OHTMAX==OHTLEN-1		;MAX INDEX POSSIBLE


	ENDOHT==1B<^L<OHTMAX>-1>-1	; ALL ONES IN FIELD IS END SIGNAL.

;BITS IN OHT

XP OHTDER,(1B0)		;DEVICE ERROR
XP OHTDTE,(1B1)		;DATA ERROR
XP OHTPAR,(1B2)		;PARITY ERROR ON DIRTY CORE PAGE.

OHTLNM==<ENDOHT>B8	;MASK FOR LINK FIELD
OHTLNP==^L<OHTLNM&-OHTLNM> ;RIGHTMOST BIT OF FIELD
OHTLNS==OHTLNP-^L<OHTLNM>+1

OHTDPM==777,,777777	;FOR THE RECORD, DISK PAGE MASK.

OHTHPW==^D36/OHTLNS	;NUMBER OF HEADER POINTERS PER WORD.
OHTNUM::0
OHTREP:	0		;Count of repeat calls for same DP

OHTBYT:

	ZZ==OHTLNS
REPEAT OHTHPW,<
	POINT OHTLNS,OHTHED,ZZ-1
	ZZ==ZZ+OHTLNS>
OHTHED:	BLOCK	<OHTLEN+OHTHPW-1>/OHTHPW ;HEADER BYTES.
OHTTAB::BLOCK	OHTLEN
OHTCPN:	BLOCK	<OHTLEN+1>/2	;Halfword Core Page Number entries

FIOLIT:	LIT
FIOEND:	END
      c|IC