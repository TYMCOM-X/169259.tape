TITLE REFSTR - ROUTINE TO REFRESH A FILE STRUCTURE

INTERN REFSTT,REFLNP,REFLNR

EXTERN RIBALP,RIBCOD,RIBUNM,RIBRPS,RBYPNO,RBYUNI,RIBUN1
EXTERN RIBEXT,RIBNAM,RIBPPN,RIBQTF,RIBQTO,RIBSIZ
EXTERN RIBSLF,RIBSTS,RIBUSD,RIBVER,RIPDIR,RIPNDL,RIPNFS
EXTERN RIBLST,RIBSNM,RIBSFS,RIBRIB,CODRIB
EXTERN RBREAL,RIBSZS,RIBPFS,RBLVPR,RBLVSP,RIBMXA,RBSPAR,RIBPRV

EXTERN UNISTT,UNISTR,UNIPPU
EXTERN UNYPPY,UNYSPU,UNYLUN

EXTERN HOMFEP,HOMTAB,HOMREF,HOMHSH,HOMRAN

EXTERN STRREF,STRP4C,STRUNI,STRUNM,STRHSH,STRDDB

EXTERN STTAOB,STTLEN,STTPTR,STTFPC,STTSTS

EXTERN %HOM.P,%HMR.P,%STR.P,%STA.P,%BAT.P,%TMP.P,%T2P.P

EXTERN CPOPJ1,REFLAG,SAVT,MFDRIB,CORZER,CORONZ
EXTERN RIBEX1,RIBEX2,RIBEX3,RIBEX4
EXTERN BATFIR,BAYNBB,SPLPPN,FSFPPN,MFDPPN,MFDPRV
EXTERN OPAGIN,OPAGOT,WTBOTH,GETBAT,GETHOM
EXTERN SAVE1,SAVE4,OCONM,OPOUT
EXTERN SYNRPR,SYRDPR,SYSPPN,SYSPRV,UNTTBL,UFDHSI


IFNDEF FTSPAG,<XP FTSPAG,-1>	;; -1 == FT Spare Pages on CYL 1 and 2

REFSTT:
PHASE %REF

	STOPCD(,ENTRY,REFSTR)
	ENTRY	REFRSH,PAKREF
SUBTTL	REFSTR definitions
;*;STNVER:	XWD	0,1	;STANDARD VERSION NUMBER.

;QUOTAS FOR UFD'S WE CREATE

ND QF,377777777777	;FIRST COME, FIRST SERVED QUOTA.
ND QO,377777777777	;LOGGED OUT QUOTA.
QUOTAF: EXP QF
QUOTAO: EXP QO

;SOME DEFINITIONS FOR HOME AND BAT PAGES AND BOOTS AND SAT.SYS RIB:
;(ALL MUST BE IN THE 1ST SAT ON THE UNIT.).

XP LPNHOM,1		;LOG. PAGE NO. OF FIRST HOME PAGE.
XP LPNBAT,2		; " OF FIRST BAT PAGE.
XP FBOOTB,3		; " OF FIRST PAGE OF BOOTS. (SEE BOTLOD AND MONBTS)
XP NBOOTP,3		;NO. OF PAGES IN BOOTS.
XP LP2HOM,6		;LOG. PAGE NO. OF SECOND HOME PAGE.
XP LP2BAT,7		; " OF SECOND BAT PAGE.
XP LPNSAT,10		;LOG. PAGE # OF PRIME RIB OF SAT.SYS.

IFN FTSPAG,<
; XP LPNSPG,<CYL*1>	;START OF SPARE PAGES AREA (CYL 1 & 2)
; XP SPGLEN,<CYL*2>	;LENGTH IN PAGES OF SPARE PAGES AREA
> ; End IFN FTSPAG

IFCPU(KS),<
IFE FTSPAG,<
; XP LPNFEF,<CYL*1>	;START OF FE FILE/BOOTSTRAP AREA
> ; End IFE FTSPAG
IFN FTSPAG,<
; XP LPNFEF,<CYL*3>	;START OF FE FILE/BOOTSTRAP AREA
> ; End IFN FTSPAG
  XP FEFLEN,100		;LENGTH IN PAGES OF FE FILE AREA
> ; End IFCPU(KS)


;SOME INTERNS FOR ONCDSK.

IFN FTSPAG,<
XP RB1UN,7		;REFSTR CREATES 7 RIBS ON FIRST UNIT (OF MFD,
> ; End IFN FTSPAG	;SYS UFD, SAT.SYS, SPAGES.SYS, HOME.SYS,
IFE FTSPAG,<		;PRINT UFD, AND CRASH.SAV.).
XP RB1UN,6		;REFSTR CREATES AS ABOVE, BUT NOT SPAGES.SYS
> ; End IFE FTSPAG
XP NMUFDS,3		;REFSTR CREATES 3 UFDS (MFD, SYS UFD, AND
			;PRINT.UFD) ON THE FIRST UNIT.
XP HBBPGS,4+NBOOTP	;NO. OF PAGES TAKEN UP BY HOME AND BAT
			;PAGES AND BOOTS AND PAGE 0.
DEFINE MSGDIE (A)
<PUSHJ P,[MOVEI T1,A
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	STOPCD ()]>

DEFINE MSGSFE (A)
<PUSHJ P,[MOVEI T1,A
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	MOVEI T1,SOFERR
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	STOPCD ()]>

DEFINE MSGLIV (A)
<PUSHJ P,[MOVEI T1,A
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	POP P,T2
	POPJ P,]>

IOFAL:	ASCIZ /
ERROR ON DISK TRANSFER.
/

OGTPG: ASCIZ /
OUT OF ROOM ON DISK.
/

BATBAD:	ASCIZ /
BAT PAGE CONSISTENCY ERROR.
/

RBNOUT:	ASCIZ /
OUT OF RETRIEVAL POINTER SPACE IN NON-EXTENDED FILE.
/

RBEOUT:	ASCIZ /
OUT OF RETRIEVAL POINTER SPACE IN EXTENDED FILE.
/

UFDERR:	ASCIZ /
OUT OF ROOM IN A ONE PAGE UFD.
/

NOTAVL:	ASCIZ /
RESERVED PAGE HAS ALREADY BEEN ALLOCATED.
/

RIBFAL:	ASCIZ/
FAULTY RIB STRUCTURE.
/

SOFERR:	ASCIZ /
SOFTWARE ERROR.
CALL PDP-10 OPERATING SYSTEMS GROUP.
/
SUBTTL	REFRSH - Refresh a complete file structure
;ARGS	P2=ADDR OF STR DATA BLOCK
;	F=ADDR OF DDB

REFRSH::JSP	T4,SAVE4	;SAVE PERMANENT ACS
	HLRZ	U,STRUNI(P2)	;U=ADDR OF FIRST UNIT IN STR
	MOVEM	U,FSTUNI	;REMEMBER FIRST UNIT.
	SETZM  FSTPG		;ZERO OUT LOCS RECORDING FIRST PAGE NOS.
	MOVE	T1,[XWD FSTPG,FSTPG+1] ;NEVER ON PAGE 0 SO WE KNOW
	BLT	T1,FSTPG+LSTPGL-1 ;IF REALLY SET UP.
	MOVEI	T1,SYRDPR	;STANDARD ACCESS CODE FOR HOME,
	MOVEM	T1,CURPRT	;AND SAT
	MOVEM	T1,SATPRT	;(NEEDED BY
	MOVEM	T1,HOMPRT	;RIBSET.).
IFN FTSPAG,<
	MOVEM	T1,SPGPRT	;SPARE PAGES
> ; End IFN FTSPAG
	MOVSI	T1,-LSTALP	;CLEAR NO. OF
	SETZM	FSTALP(T1)	;PAGES ALLOCATED FOR
	AOBJN	T1,.-1		;EACH FILE OF INTEREST.
	SETZM	SATDSK		;MARK NO SAT IN CORE IN %STA.

;HERE TO SET UP RIB IN CORE FOR HOME.SYS.

	MOVE	T1,HOMFNM	;NAME OF HOME.SYS FILE
	MOVSI	T2,(SIXBIT .SYS.)
	MOVE	T3,SYSPPN	;IN SYS UFD
	MOVEI	T4,%HMR		;PNTR TO HOME.SYS RIB IN CORE.
	MOVEI	P4,RIPNDL!RIPNFS ;NO DELETE, NO CHANGE NAME, NO FAILSAFE BITS
	PUSHJ	P,RIBSET	;SET UP RIB FOR HOME.SYS.
	HRLI	T1,-RBLVPR-1	;SET UP AOBJN WORD TO
	HRRI	T1,%HMR+RIBPFS-1
	MOVEM	T1,HOMRBP	;RETREVIAL AREA.

;HERE TO SET UP RIB IN CORE FOR SAT.SYS.

	MOVE	T1,SATFNM	;NAME OF SAT.SYS FILE
	MOVSI	T2,(SIXBIT .SYS.)
	MOVE	T3,SYSPPN	;IN SYS UFD
	MOVEI	T4,%STR		;PNTR TO SAT.SYS RIB IN CORE.
	MOVEI	P4,RIPNDL!RIPNFS ;ALL STATUS BITS
	PUSHJ	P,RIBSET	;SET UP RIB FOR SAT.SYS.
	HRLI	T1,-RBLVPR-1	;SET UP AOBJN WORD TO
	HRRI	T1,%STR+RIBPFS-1
	MOVEM	T1,SATRBP	;RETREVIAL POINTER AREA+1.
;HERE IS THE LOOP FOR EACH UNIT IN THE STR.

NXUNIT:	PUSHJ	P,GETBAT	;READ BAT PAGE(S).
	  JRST	REFFAL
	PUSHJ	P,SATCLC	;SET BEGSAT, SVSBTL, LPGSAT, AND SATIND.

;HERE IS THE LOOP FOR EACH SAT ON THE UNIT.

NXTSAT:	PUSHJ	P,INISAT	;INIT SAT BITS (0=BAD,HOME,ETC)
	  JRST	REFFAL

	PUSHJ	P,NXCLC		;ANOTHER SAT FOR THIS UNIT?
	JRST	NXTSAT		;YES, GO DO IT.

	HLRZ	U,UNISTR(U)	;NEXT UNIT IN STR.
	JUMPN	U,NXUNIT	;LOOP FOR ALL UNITS IN STR.

;HERE AFTER ALL SATS ON ALL UNITS ARE WRITTEN.

	MOVE	U,FSTUNI	;RESET TO FIRST UNIT IN STR
;HERE TO WRITE RIBS FOR SAT.SYS AND HOME.SYS ON FIRST UNIT.

    ;ALLOCATE RIB FOR SAT.SYS.
	MOVEI	T1,%STR		;
	PUSHJ	P,CNVSIZ	;
	SETZ	T2,		;STORE THE EOF AND
	PUSHJ	P,SATRBS	;COUNT THE PRIME RIB IN ALP.
	MOVEI	T2,LPNSAT	;BUILD THE RETRIEVAL POINTER TO
	TLO	T2,RBREAL	;THE SAT.SYS RIB AND
	MOVEM	T2,%STR+RIBSLF	;STORE IT.
	MOVEI	T4,LPNSAT	;T4/ LOG. PAGE NO. OF RIB.
	TLO	T4,RBREAL
	MOVEM	T4,SATRBD	;REMEMBER LOGICAL PAGE NUMBER OF SAT.SYS RIB
	TLZ	T4,RBREAL
	MOVEI	PG,%STR.P	;WRITE OUT THE RIB OF
	PUSHJ	P,OPAGOT	;SAT.SYS.
	  JRST	REFFAL
	MOVE	T1,%STR+RIBALP
	MOVEM	T1,SATALP

    ;ALLOCATE RIB FOR HOME.SYS.
	MOVEI	T1,%HMR		;
	PUSHJ	P,CNVSIZ	;
	SETZ	T2,		;STORE THE EOF AND
	PUSHJ	P,HOMRBS	;COUNT THE PRIME RIB IN ALP.
	PUSHJ	P,OGETPG	;ALLOCATE A PAGE FOR HOME.SYS RIB.
	  JRST	REFFAL
	MOVEM	T2,%HMR+RIBSLF
	MOVEM	T2,HOMRBD	;REMEMBER LOG. PAGE NUMBER OF RIB FOR HOME.SYS.
	LDB	T4,RBYPNO	;PAGE NO. OF RIB.
	MOVEI	PG,%HMR.P	;WRITE OUT THE RIB OF
	PUSHJ	P,OPAGOT	;HOME.SYS.
	  JRST	REFFAL
	MOVE	T1,%HMR+RIBALP	;
	MOVEM	T1,HOMALP	;
; HERE TO ALLOCATE SPACE FOR SPAGES.SYS - SPECIAL/SPARE PAGES CYL 1 & 2

IFN FTSPAG,<	;; HERE TO SET UP RIB IN CORE FOR SPAGES.SYS.
	MOVE	U,FSTUNI	;USE FIRST UNIT FOR RIB
	MOVE	T1,SPGFNM	;NAME OF SPAGES.SYS FILE
	MOVSI	T2,(SIXBIT .SYS.)
	MOVE	T3,SYSPPN	;IN SYS UFD
	MOVEI	T4,%TMP		;ADDRESS OF RIB IN MEMORY.
	MOVEI	P4,RIPNDL!RIPNFS ;NO DELETE, NO FAILSAFE BITS
	PUSHJ	P,RIBSET	;SET UP RIB IN MEMORY.

	HRLI	T1,-RBLVPR-1	;SET UP AOBJN WORD
	HRRI	T1,%TMP+RIBPFS-1 ; TO RETREVIAL
	MOVEM	T1,TMPRBP	; AREA FOR PTREXT.

	PUSHJ	P,OGETPG	;ALLOCATE A PAGE FOR SPAGES.SYS RIB.
	  JRST	REFFAL
	MOVEM	T2,%TMP+RIBSLF	;REMEMBER LOG. PAGE # OF RIB
	MOVEM	T2,SPGRBD	; FOR SPAGES.SYS IN HOM PAGE.
	LDB	T1,UNYPPY	;GET # PAGES PER CYLINDER
	LSH	T1,1		; 2 cylinders each unit
	HRRZ	P3,UNISTR(U)	; Up pointer to STR
	HRRZ	P3,STRUNM(P3)	; Number of units on structure
	IMUL	T1,P3		;Calculate number of pages
	MOVEM	T1,%TMP+RIBALP	;Set current pages
	AOS	%TMP+RIBALP	; plus 1 for prime rib
	LSH	T1,P2WLSH	;Convert to words
	MOVEM	T1,%TMP+RIBSIZ	;Store

	SETZM	PGSRIB		;CLEAR # OF SPARE RIBS
SPGCRE:	LDB	T1,UNYPPY	;GET # PAGES PER CYLINDER	(REMEMBER
	MOVN	P3,T1		; NEGATE AND POSITION		 THESE WERE
	LSH	P3,^D19		; FOR AOBJN LENGTH (-n*2,,0)	 RESERVED
	HRR	P3,T1		;GET FIRST PAGE AS POINTER	 BY INISAT).

SPGCR1:	HRRZ	T1,P3		;GET THIS PAGE NEXT
	PUSHJ	P,MAKPAG	; CONVERT T1 TO RETRIEVAL POINTER
	PUSHJ	P,PTREXT	;PUT THE PAGE IN THE RIB
	  JRST	REFFAL
	AOBJN	P3,SPGCR1	;LOOP FOR ALL PAGES THIS UNIT
	HLRZ	U,UNISTR(U)	;ANOTHER UNIT?
	JUMPN	U,SPGCRE	;YES, GO TO IT

	MOVE	U,FSTUNI	;RETRIEVE THE UNIT POINTER
	MOVEI	T1,%TMP		;POINT TO RIB PAGE
	PUSHJ	P,RBNFL9	;STORE EOF, ADJUST RIBALP, WRITE RIB
	  JRST	REFFAL
	MOVE	T1,%TMP+RIBALP	;REMEMBER ALLOCATED PAGES
	MOVEM	T1,SPGALP	;FOR LATER
> ; End IFN FTSPAG
; HERE TO ALLOCATE SPACE FOR FEFILE.SYS ON KS-10s ONLY (for now)

IFCPU(KS),<			;; KS-10 HAS FE-FILE AREA FOR 8080
	MOVE	U,FSTUNI	;USE FIRST UNIT FOR RIB
	MOVE	T1,FEFFNM	;NAME OF FEFILE.SYS FILE
	MOVSI	T2,(SIXBIT .SYS.)
	MOVE	T3,SYSPPN	;IN SYS UFD
	MOVEI	T4,%TMP		;ADDRESS OF RIB IN MEMORY.
	MOVEI	P4,RIPNDL!RIPNFS ;NO DELETE, NO FAILSAFE BITS
	PUSHJ	P,RIBSET	;SET UP RIB IN MEMORY.

	HRLI	T1,-RBLVPR-1	;SET UP AOBJN WORD
	HRRI	T1,%TMP+RIBPFS-1 ; TO RETREVIAL
	MOVEM	T1,TMPRBP	; AREA FOR PTREXT.

	PUSHJ	P,OGETPG	;ALLOCATE A PAGE FOR FEFILE.SYS RIB.
	  JRST	REFFAL
	MOVEM	T2,%TMP+RIBSLF	;REMEMBER LOG. PAGE # OF RIB
	MOVEM	T2,FEFRBD	; FOR FEFILE.SYS (IN HOM PAGE?).
	LDB	T1,UNYPPY	;GET # PAGES PER CYLINDER
	HRRZ	P3,UNISTR(U)	; Up pointer to STR
	HRRZ	P3,STRUNM(P3)	; Number of units on structure
	IMUL	T1,P3		ulate number of pages
	MOVEM	T1,%TMP+RIBALP	;Set current pages
	AOS	%TMP+RIBALP	; plus 1 for prime rib
	LSH	T1,P2WLSH	;Convert to words
	MOVEM	T1,%TMP+RIBSIZ	;Store

	SETZM	PGSRIB		;CLEAR # OF SPARE RIBS
FEFCRE:	LDB	P3,UNYPPY	;GET # PAGES PER CYLINDER	(REMEMBER
IFN FTSPAG,<	;IF SPAGES EXISTS START ON CYL 3 ELSE CYL 1	 THESE WERE
	IMULI	P3,3		; MAKE FIRST PAGE ON CYLINDER 3	 RESERVED
> ; End IFN FTSPAG
	HRLI	P3,-FEFLEN	;GET LENGTH OF FE AREA		 BY INISAT).

FEFCR1:	HRRZ	T1,P3		;GET THIS PAGE NEXT
	PUSHJ	P,MAKPAG	; CONVERT T1 TO RETRIEVAL POINTER
	PUSHJ	P,PTREXT	;PUT THE PAGE IN THE RIB
	  JRST	REFFAL
	AOBJN	P3,FEFCR1	;LOOP FOR ALL PAGES THIS UNIT
	HLRZ	U,UNISTR(U)	;ANOTHER UNIT?
	JUMPN	U,FEFCRE	;YES, GO TO IT

	MOVE	U,FSTUNI	;RESET TO FIRST UNIT
	MOVEI	T1,%TMP		;POINT TO RIB PAGE
	PUSHJ	P,RBNFL9	;STORE EOF, ADJUST RIBALP, WRITE RIB
	  JRST	REFFAL
	MOVE	T1,%TMP+RIBALP	;REMEMBER ALLOCATED PAGES
	MOVEM	T1,FEFALP	;FOR LATER
> ; End IFCPU(KS)
;HERE TO ALLOCATE SPACE FOR CRASH.SAV - SPACE TO WRITE OUT A CRASH FILE.

CRSCRE:	MOVE	P2,UNISTR(U)	;SEE IF A
	HRRZ	T4,STRP4C(P2)	;  CRASH FILE
	SKIPN	T4		;  ON THIS STR.
	  JRST	NORCV		;NO
	MOVEI	T1,SYNRPR	;STANDARD ACCESS CODE
	MOVEM	T1,CURPRT	;FOR
	MOVEM	T1,CRSPRT	;CRASH.SYS.
	MOVE	U,FSTUNI	;PUT IT ON FIRST UNIT.
	MOVE	T1,CRSFNM	;ARGS
	MOVSI	T2,(SIXBIT .SAV.) ;FOR
	MOVE	T3,SYSPPN	;RBNFIL.
	MOVEI	P4,RIPNDL!RIPNFS ;SET UP THE RIB IN %TMP AND
	PUSHJ	P,RBNFIL	;THE FILE.
	  JRST	REFFAL		;
	MOVE	T2,%TMP+RIBALP	;SAVE THE NO. OF PAGES IN THIS
	MOVEM	T2,CRSALP	;FILE + RIB PAGES FOR RIBUSD.
	MOVE	T2,%TMP+RIBSLF	;
	MOVEM	T2,CRSRBD	;


;HERE TO CREATE PRINT UFD.

NORCV:	MOVE	U,FSTUNI	;
	MOVEI	T1,754000	;INFINITLY WRITEABLE PRIVILEGES
	MOVEM	T1,CURPRT
	MOVEM	T1,PRTPRT
	SETZ	P2,		;NO FILES= SUM OF ALPS=0.
	MOVE	T1,SPLPPN	;PRINT UFD
	MOVEM	T1,PRTUFD
	SETZ	P1,		;
	PUSHJ	P,UFDSET	;
	  JRST	REFFAL		;
	MOVEM	T2,PRTRBD	;SAVE LOGICAL PAGE NUM OF RIB.
	MOVE	T4,%TMP+RIBALP
	MOVEM	T4,PRTALP	;PAGES ALLOCATED TO (SPOOLING).UFD
;HERE TO CREATE SYS UFD AND ITS RIB.

	MOVEI	T1,SYSPRV	;SET ACCESS CODE FOR
	MOVEM	T1,CURPRT	;SYS UFD.
	MOVEM	T1,SYSPRT
	MOVE	U,FSTUNI	;FIRST UNIT ON STR
	SETZ	P2,
	MOVSI	T1,-LSTFL	;FIND SUM OF
	ADD	P2,FSTALP(T1)	;ALPS FOR
	AOBJN	T1,.-1		;ITS FILES.
	MOVE	T1,SYSPPN
	MOVEM	T1,SYSUFD	;SAVE IN NAME PAGE.
	MOVSI	P1,-LSTFL	;
	HRRI	P1,FSTFL	;
	PUSHJ	P,UFDSET	;SET UP & WRITE OUT INFO IN THE RIB FOR SYS.UFD.
	  JRST	REFFAL
	MOVEM	T2,SYSRBD	;
	MOVE	T4,%TMP+RIBALP
	MOVEM	T4,SYSALP
	SETZ	P3,		;MAKE THE UFD ENTRIES AND
	MOVSI	P1,-LSTFL	;
	HRRI	P1,FSTFL	;
	PUSHJ	P,SETUFD	;SET UP AND WRITE OUT THE UFD ITSELF.
	  JRST	REFFAL


;HERE TO CREATE (1,1).UFD (MFD) AND ITS RIB.

	MOVEI	T1,MFDPRV	;SET ACCESS CODE FOR
	MOVEM	T1,CURPRT	;MFD.
	MOVEM	T1,MFDPRT	;
	SETZ	P2,		;
	MOVSI	T1,-LSTUF+1	;SUM OF THE
	ADD	P2,FSTALP+LSTFL(T1) ;ALPS
	AOBJN	T1,.-1		;FOR ITS FILES FOR RIBUFD.
	ADDI	P2,2		;COUNT MFDALP ALSO.
	MOVE	T1,MFDPPN	;NAME OF MFD
	MOVEM	T1,MFDUFD	;SAVE IN NAME PAGE.
	MOVE	P1,[XWD -LSTUF,SYSUFD]
	PUSHJ	P,UFDSET	;SET UP AND WRITE OUT INFO IN THE RIB FOR MFD.
	  JRST	REFFAL
	MOVEM	T2,MFDRBD	;
	MOVEM	T2,MFDRIB	;
	MOVE	T4,%TMP+RIBALP	;
	MOVEM	T4,MFDALP
	MOVEI	P3,LSTFL	;NOW DO UFD'S IN MFD
	MOVE	P1,[XWD -LSTUF,SYSUFD]
	PUSHJ	P,SETUFD	;SET UP AND WRITE OUT THE UFD ITSELF.
	  JRST	REFFAL
	PUSHJ	P,CNDSWT	;IF THERE IS A SAT IN CORE, WRITE IT.
	  JRST	REFFAL

;HERE TO UPDATE THE HOME PAGES ON EACH UNIT OF THE STR.

	INTERN	RANNO		;Set at GETRAN in ONCDSK

	MOVE	U,FSTUNI	;START WITH THE FIRST UNIT.
HOMUPD:	PUSHJ	P,GETHOM	;READ HOME PAGES.
	  JRST	REFFAL
	SETZM	%HOM+HOMREF	;CLEAR NEEDS REFRESHING FLAG
IFCPU(KS),<
	LDB	T1,UNYPPY	;GET # PAGES PER CYL
IFN FTSPAG,<	;; Use CYL 1 if no special/spare pages ELSE use CYL 3
	IMULI	T1,3		; STARTS AT CYL 3
> ; End IFN FTSPAG
	HRLI	T1,FEFLEN	; FOR FEFLEN PAGES
	MOVEM	T1,%HOM+HOMFEP	;SET POINTER TO FE FILE
> ; End IFCPU(KS)
	MOVEI	T1,UFDHSI	;RESET HASH
	HRLZM	T1,%HOM+HOMHSH	;AND
	HRRZ	T1,RANNO
	HRRM	T1,%HOM+HOMRAN	;RANDOM PACK-SET MOUNT COUNT TO SAME
	HRRZI	T2,%HOM+HOMTAB	;ADDR OF TABLE OF 1ST LOGICAL PAGES.
	HRLI	T2,FSTPG	;FIRST SUCH WORD
	HRRZI	T3,LSTPGL-1(T2)	;  HOMTAB thru HOMMFD
	BLT	T2,(T3)		;STORE THIS STUFF IN HOME PAGE.
	PUSHJ	P,WTBOTH	;P4 & PG STILL SET UP FROM GETHOM.
	 STOPCD			;WTBOTH HAS TYPED AN ERR MSG.
	HLRZ	U,UNISTR(U)
	JUMPN	U,HOMUPD	;LOOP FOR ALL UNITS IN STR
	PUSHJ	P,CLSAOB

;HERE WHEN ALL DONE

	MOVE	T1,FSFPPN	;FAILSAFE PROJ-R
	MOVEM	T1,REFLAG	;SET REFLAG NON-ZERO
	MOVE	U,FSTUNI	;RESET U TO FIRST UNIT
	HRRZ	P2,UNISTR(U)	;TO RESET P2 WHICH WAS CLOBBERED
	MOVEI	T1,UFDHSI	;  FIXING HOME PAGES.
	HRRM	T1,STRHSH(P2)
	HRRZS	STRREF(P2)	;CLEAR NEEDS REFRESHING FLAG IN CORE
	JRST	CPOPJ1		;SKIP RETURN


REFFAL:	POPJ	P,		;ERROR EXIT.
SUBTTL	PAKREF - Refresh a single pack which is being added to a STR
;ENTER WITH U/ UNIT DB AND P2/ STR DB.

REFUNI:	Z	;STORAGE FOR PAKREF.  (UNIT CURRENTLY BEING REFRESHED)

PAKREF:	MOVEM	U,REFUNI	;SAVE UNIT BEING REFRESHED.
	SETZM	FSTUNI		;FLAG FOR INISAT.
	HRRM	P2,UNISTR(U)	;PUT STR HERE, SOME LOOK FOR IT.
	HLRZ	U,STRUNI(P2)	;GET THE 1ST UNIT IN THE STR.
	SETZM	SATDSK		;MARK NO SAT IN CORE IN %STA.
	PUSHJ	P,GETHOM	;GET HOME PAGES FROM FIRST UNIT.
	  JRST	PAKLEV		;ERROR.
	HRLI	T2,%HOM+HOMTAB	;BUILD THE TABLE OF
	HRRI	T2,FSTPG	;PAGE NOS. OF RIBS FOR
	BLT	T2,FSTPG+LSTPGL-1 ;FILES OF INTEREST.

  ;NOW GET THE CURRENT RIBS FOR HOME AND SAT INTO %HMR AND %STR.
	MOVSI	P4,-PAKFIL	;P4/ LOOP INDEX.
PREF2:	SETZM	FSTPRT(P4)	;Zero until RIB is found
	SKIPN	T4,FSTPG(P4)	;T4/ PAGE NO. OF PRIME RIB FIRST UNIT.
	  JRST	PRFNST		;No big deal if no RIB to SPAGES.SYS (SWAP.SYS)
	TLZ	T4,RBREAL	;

	HRRZ	PG,FSTCTL(P4)	;PG/ %XXX.P.
	HLRZ	P1,FSTCTL(P4)	;P1/ %XXX.
	MOVE	U,REFUNI	;
	HRRZ	P2,UNISTR(U)	;
	HLRZ	U,STRUNI(P2)	;
	PUSHJ	P,OPAGIN	;
	  JRST	PAKLEV
	MOVE	P2,RIBSIZ(P1)	;CALC NO. OF THE LAST PAGE IN
	IDIVI	P2,1000		;FILE. (NB NOT TRUE IN GENERAL.)
PREF3:	MOVE	T3,RIBSZS(P1)	;FOUND RIGHT RIB IF
	CAIE	T3,1		;AT LOWEST LEVEL.
	  JRST	PREF4		;
	ADDI	P2,RIBPFS(P1)	;P2/ ADDR OF EOF PNTR.
	SKIPE	RIBRIB(P1)	;
	  ADDI	P2,RIBSFS-RIBPFS ;
	JRST	PREF11		;
;GO DOWN A LEVEL INTO A SPARE RIB

PREF4:	IDIV	P2,RIBSZS(P1)	;ELSE P2/ #PRECED SPARE PNTRS
	ADDI	P2,RIBPFS(P1)	;P2/ ADDR OF NEXT PNTR.
	SKIPE	RIBRIB(P1)	;
	  ADDI	P2,RIBSFS-RIBPFS ;
	MOVE	T2,(P2)		;IS THE PNTR
	TLNN	T2,RBSPAR	;A SPARE RIB PNTR?
	  JRST	PREF5		;NO, WE ARE IN THIS RIB.
	MOVE	P2,P3		;YES, WE MUST READ
	LDB	U,RBYUNI	;IN
	MOVE	U,UNTTBL(U)	;THE
	LDB	T4,RBYPNO	;LOWER
	PUSHJ	P,OPAGIN	;RIB.
	  JRST	PAKLEV		;
	JRST	PREF3		;
PREF5:	ADDI	P2,(P3)		;

    ;HERE WITH ADDR OF EOF PNTR IN P2.

PREF11:	MOVE	T1,P2		;BUILD
	SUB	P2,P1		;AN
	SUBI	P2,RIBLST+2	;AOBJN
	HRLM	P2,T1		;POINTER
	HRRI	T1,-1(T1)	;IN T1.
	MOVEM	T1,FSTPRT(P4)	;SAVE T1 IN SATPRT,HOMPRT,SPGPRT
PRFNST:	AOBJN	P4,PREF2

    ;READ THE BAT PAGE INTO %BAT.
	MOVE	U,REFUNI	;READ THE
	PUSHJ	P,GETBAT	;BAT PAGE.
	  JRST	PAKLEV		;
;HERE FOR THE SATS FOR THIS UNIT.

	PUSHJ	P,SATCLC	;CALC BEGSAT, SVSBTL, LPGSAT, AND SATIND.
	MOVE	T1,HOMPRT	;SET
	MOVEM	T1,HOMRBP	;THE
	MOVE	T1,SATPRT	;PNTRS WE JUST FOUND
	MOVEM	T1,SATRBP	;TO
IFN FTSPAG,<
	MOVE	T1,SPGPRT	;; and Spare PAGES
	MOVEM	T1,TMPRBP
> ; End IFN FTSPAG

    ;THIS IS THE LOOP FOR EACH SAT.

RFNXST:	PUSHJ	P,INISAT	;SET UP A SAT AND PART OF HOME.SYS.
	 STOPCD

	PUSHJ	P,NXCLC		;CALC INFO FOR NEXT SAT.
	  JRST	RFNXST		;GO.


    ;HERE TO SET NEW RIBSIZ'S IN THE RIBS FOR HOME.SYS AND SAT.SYS

	MOVEI	T1,%HMR		;		HOME
	PUSHJ	P,CNVSZM	;
	SETZ	T2,		;STORE THE
	PUSHJ	P,HOMRBS	;EOF POINTER.

	MOVEI	T1,%STR		;		SAT
	PUSHJ	P,CNVSZM	;
	SETZ	T2,		;
	PUSHJ	P,SATRBS	;

IFN FTSPAG,<    ;HERE TO SET NEW RIBSIZ'S IN THE RIB FOR SPAGES.SYS
	SKIPN	TMPRBP		;Is there a file to be added to?
	 JRST	PAKSP0		;No
	LDB	T1,UNYPPY	;GET # PAGES PER CYLINDER	(REMEMBER
	LSH	T1,1		; 2 cylinders
	ADDM	T1,%TMP+RIBALP	;ADD TO ALLOCATED PAGES
	MOVE	P3,T1		;COPY FOR WORD SIZE
	LSH	P3,P2WLSH	;  CALCULATION
	ADDM	P3,%TMP+RIBSIZ	;  ...
	MOVN	P3,T1		; NEGATE AND POSITION		 THESE WERE
	LSH	P3,^D18		; FOR AOBJN LENGTH (-n*2,,0)	 RESERVED
	HRR	P3,T1		;GET FIRST PAGE AS POINTER	 BY INISAT).

PAKSPG:	HRRZ	T1,P3		;GET THIS PAGE NEXT
	PUSHJ	P,MAKPAG	; CONVERT T1 TO RETRIEVAL POINTER
	PUSHJ	P,PTREXT	;PUT THE PAGE IN THE RIB
	  JRST	PAKLEV
	AOBJN	P3,PAKSPG	;LOOP FOR ALL PAGES THIS UNIT

	SETZ	T2,		;STORE THE
	PUSHJ	P,PTREXT	;NEW EOF POINTER
PAKSP0:
>  ;end IFN FTSPAG
;NOW FIX UP THE HOME PAGES ON THIS UNIT.

FIXHOM:	MOVE	U,REFUNI	;
	PUSHJ	P,GETHOM	;
	 STOPCD
	SETZM	%HOM+HOMREF	;
PRINTF (<[KS-FEFILE not allocated on ADD PACK]>)
	;This will cause problems if added pack is ever moved to RPA0.
IFCPU(KS),<	;; HERE TO ADD FEFILE PAGES  /CARL 20-Feb-86
	SETZM	%HOM+HOMFEP	;; NO FE-FILE AREA ON ADDED PACKS FOR NOW
> ; End IFCPU(KS)
	HRRZ	T1,STRDDB+STRHSH
	HRLZM	T1,%HOM+HOMHSH	;
	HRRZ	T1,RANNO	;
	HRRM	T1,%HOM+HOMRAN	;
	HRLI	T2,FSTPG	;
	HRRI	T2,%HOM+HOMTAB	;
	MOVEI	T1,LSTPGL-1(T2)	;
	BLT	T2,(T1)		;
	PUSHJ	P,WTBOTH	;NOW WRITE THEM OUT.
	 STOPCD
	HRRZ	P2,UNISTR(U)	;
	MOVEI	T1,UFDHSI	;
	HRRM	T1,STRHSH(P2)	;

    ;NOW WRITE OUT THE RIBS FOR HOME AND SAT and maybe SPAGES.

	MOVSI	P4,-PAKFIL	;
PAKRB1:	SKIPN	FSTPRT(P4)	;Was this RIB read in?
	 JRST	PKRB1A		;No, RIB for SPAGES.SYS is missing
	HLRZ	T3,FSTCTL(P4)	;Virtual address
	MOVE	T2,RIBSLF(T3)	;Self pointer says where to write the data
	LDB	T4,RBYPNO	;Page within unit
	LDB	U,RBYUNI	;Unit number
	MOVE	U,UNTTBL(U)	;Unit data block
	HRRZ	PG,FSTCTL(P4)	;Physical address
	PUSHJ	P,OPAGOT	;Write it out
	 STOPCD
PKRB1A:	AOBJN	P4,PAKRB1
	PUSHJ	P,CNDSWT	;Write out SAT if any
	 STOPCD
	PUSHJ	P,CLUAOB	;Clear SATAOB
	AOS	(P)			;SUCCESS RETURN

PAKLEV:	MOVE	U,REFUNI	;Restore U and P2
	HRRZ	P2,UNISTR(U)	;
	POPJ	P,		;End of PAKREF
SUBTTL VARIOUS SUBROUTINES.

COMMENT #
@@SUBROUTINE SCNBAT
@@PURPOSE
SUBR TO SCAN BAT AREA AND EXECUTE AN INSTRUCTION FOR EACH BAD PAGE.
@@ENTRY
EXPECTS T2/ INSTRUCTION TO EXECUTE (AND IF CALLING SETBTS,
T3/ ADDR OF STT ENTRY.).
@@ACCUM
DESTROYS T1, T2, AND T4.
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE NON-SKIP RETURNS.
@@ #

PRINTF(<% BAT conflict - SCNBAT uses page entries, PAKCOPY does not>)
;PAKCOP uses record number, which is logical block number if the pack is formatt
;formatted in blocks, and is page number only if pack is formatted in pages.

SCNBAT::JSP	T4,SAVE4	;SAVE P1-P4
	MOVE	P2,T2		;P2=INSTRUCTION TO EXECUTE.
	MOVEI	P4,%BAT		;P4/ -NO. OF WORDS IN AREA,,
	ADD	P4,%BAT+BATFIR	;ADDR OF 1ST ENTRY.
	SKIPN	T1,(P4)		;AT END?
	  JRST	CPOPJ1		;YES.

    ;HERE FOR EACH ENTRY.
SCNBT2:	MOVE	T2,P4		;ADDR OF BAD REGION PTR FOR LDB.
	LDB	P3,BAYNBB	;NUMBER BAD PAGES-1.
	HRRZ	P1,1(P4)	;P1=1ST BAD PAGE.
	JRST	.+2
    ;HERE FOR EACH BAD PAGE.
SCNBT4:	ADDI	P1,1		;P1=NEXT BAD PAGE.
	MOVE	T1,P1		;ARG FOR INSTRUCTION.
	XCT	P2		;MARK THIS PAGE IN SAT.
	SOJGE	P3,SCNBT4	;LOOP FOR ALL BAD PAGES THIS REGION.
	AOBJN	P4,.+2		;COMPENSATE FOR 2 WORD ENTRIES.
	 MSGLIV	BATBAD
	SKIPE	1(P4)		;END OF NON-ZERO ENTRIES?
	AOBJN	P4,SCNBT2	;LOOP FOR ALL ENTRIES
	JRST	CPOPJ1
COMMENT #
@@SUBROUTINE SETBTS
@@PURPOSE
SUBR TO CLEAR AN F BIT IN %STA AND DECREMENT STTFPC.
@@ENTRY
EXPECTS T1/ PAGE NO. OF BIT AND T3/ ADDR OF STT ENTRY.
@@ACCUM
DESTROYS T1, T2, AND T4.
@@ #

SETBTS:	CAML	T1,BEGSAT	;SKIP IF BEFORE BEGINNING OF CURRENT SAT.
	CAMLE	T1,LPGSAT	;SKIP IF WITHIN CURRENT SAT (NOT PAST END)
	 POPJ	P,		;PAGE NOT IN CURRENT SAT.
	SUB	T1,BEGSAT	;
	IDIVI	T1,^D36		;T1=INDEX IN PAGE OF BIT.
	MOVNS	T2		;T2=BITS TO SHIFT RIGHT
	MOVSI	T4,400000	;SET LEFTMOST BIT
	LSH	T4,(T2)		;POSITION BIT
	TDNN	T4,%STA(T1)	;SKIP IF BIT SET.
	 POPJ	P,		;ALREADY CLEAR, JUST RETURN.
	XORM	T4,%STA(T1)	;SO CLEAR IT.
	SOS	STTFPC(T3)	;NOTE ONE LESS FREE PAGE.
	POPJ	P,
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	INISAT	Set all the bits in %STA to represent available pages,	;;
;;		except for BAD pages, the HOME, BAT and BOOT pages, on	;;
;;		KS-10 the FEFILE pages, the special spare pages on all	;;
;;		disk units, non-existent pages and page 0.		;;
;;		Also, make the STT entry and write out the SAT.		;;
;;									;;
;;		Destroys T1 thru T4, P1 thru P4 and PG.			;;
;;		calls: CORONZ, SCNBAT, SETBTS, GETHMP, SATSRH, SATRBS,	;;
;;		       OPAGOT, TAKPAG and CPOPJ1.			;;
;;									;;
;;	expects	BEGSAT, SVSBTL, LPGSAT and SATIND setup.		;;
;;		U/ UNIT DB						;;
;;		F/ DDB							;;
;;									;;
;;	returns	SKIP if no errors.					;;
;;		NON-SKIP if anything goes wrong.			;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;HERE TO MAKE THE STT ENTRY.
INISAT:	PUSHJ	P,CNDSWT	;WRITE OUT ANY SAT IN CORE BEFORE
	POPJ	P,		;WE WIPE IT OUT.
	AOS	T1,SATIND	;GET INTO T1 THE
	IMULI	T1,STTLEN	;ADDR OF THE
	HRRZ	T2, UNISTT(U)	;STT
	ADDI	T1,(T2)		;ENTRY.
	SETZM	STTAOB(T1)	;CLEAR AOBJN POINTER.
	MOVE	T2,SVSBTL	;SET THE COUNT OF
	MOVEM	T2,STTFPC(T1)	;FREE PAGES.
	SETZM	STTSTS(T1)	;CLEAR THE STATUS.
	PUSH	P,T1		;SAVE ENTRY ADDR FOR BELOW.

    ;HERE TO SET ALL SAT BITS AND THEN CLEAR BITS OF NON-EXISTENT PAGES.
	HRRZI	T1,%STA		;SET THE ENTIRE
	SETOM	%STA		;AREA REPRESENTED IN THIS
	PUSHJ	P,CORONZ	;SAT TO AVAILABLE.
	MOVE	T2,SVSBTL	;ANY NON-EXISTENT PAGES
	CAIL	T2,400*^D36	;AT THE END OF THE SAT?
	JRST	INISA3		;NO.
	SETZ	T1,		;YES, DOES A PARTIAL
	IDIVI	T2,^D36		;WORD IN THE SAT HAVE
	JUMPE	T3,INISA2	;TO BE SET?
	MOVSI	T1,400000	;YES.  SET
	MOVNI	T3,-1(T3)	;THE PARTIAL
	ASH	T1,(T3)		;WORD.
INISA2:	MOVEM	T1,%STA(T2)	;SET PARTIAL WORD OR NEXT WORD.
	CAIL	T2,377		;ANY MORE WORDS TO SET?
	  JRST	INISA3		;NO.
	SETZM	%STA+1(T2)	;YES, PREPARE TO BLT.
	CAIL	T2,376		;BUT NOT IF ONLY ONE
	  JRST	INISA3		;WORD TO DO.
	HRRZI	T2,%STA+2(T2)	;SET THE REST OF
	HRLI	T2,-1(T2)	;THE SAT TO
	BLT	T2,%STA+377	;UNAVAILABLE.
    ;HERE TO SCAN BAT AREA AND MARK BAD PAGES IN SAT.

INISA3:	POP	P,T3		;RESTORE STT ENTRY ADDRESS.
	MOVE T2,[PUSHJ P,SETBTS];INSTRUCTION TO EXECUTE
	PUSHJ	P,SCNBAT	;FOR EACH BAD PAGE.
	  POPJ	P,

INISA5:	SKIPE	BEGSAT		;SKIP IF THIS IS 1ST SAT ON THIS UNIT
	  JRST INISA6

    ;HERE TO ALLOCATE PAGES (HOME, BAT, AND BOOTS) IN HOME.SYS FILE
    ;AND PAGE FOR SAT.SYS RIB.
    ;(DONE ONLY IF THIS IS THE FIRST SAT ON THIS UNIT.).
	MOVSI	P3,-LBNLEN
	MOVE	T1,LBNLST(P3)
	PUSHJ	P,GETHMP	;GET NEXT PAGE IN THE GROUP.
	  POPJ	P,		;CAN'T GET IT.
	AOBJN	P3,.-3		;LOOP FOR ALL OF THE GROUP
	MOVE	P3,[XWD -NBOOTP,FBOOTB]	;P3=-# PAGES FOR BOOTS, 1ST PAGE.
	HRRZ	T1,P3		;NEXT PAGE TO ALLOCATE.
	PUSHJ	P,GETHMP	;ALLOCATE THE PAGE.
	  POPJ	P,
	AOBJN	P3,.-3		;LOOP FOR ALL PAGES TO ALLOCATE FOR BOOTS.
IFN FTSPAG,<	;;Allocate 2 cylinders in SAT even if no RIB for SPAGES.SYS
	LDB	T1,UNYPPY	;GET # PAGES PER CYLINDER
	MOVN	P3,T1		; NEGATE AND POSITION
	LSH	P3,^D19		; FOR AOBJN LENGTH (-N*2,,0)
	HRR	P3,T1		;GET FIRST PAGE AS POINTER
	HRRZ	T1,P3		; NEED TO GET THIS PAGE #
	PUSHJ	P,TAKPAG	;RESERVE THE PAGE SO NOBODY ELSE GETS IT.
	  POPJ	P,
	AOBJN	P3,.-3		;LOOP FOR ALL PAGES ON CYL 1 AND 2
> ; End IFN FTSPAG
IFCPU(KS),<			;; KS-10 HAS FE-FILE AREA FOR 8080
	SKIPE	REFUNI		;; SINGLE UNIT? (ADD PACK)
	  JRST	INISXX		;; DON'T PUT FE AREA ON ADDED PACKS 20-Feb-86
IFE FTSPAG,<	;; *** IF FTSPAG ABOVE, P3 SET TO CYL 3 ELSE USE CYL 1 ***
	LDB	P3,UNYPPY	;GET # PAGES PER CYLINDER
> ; End IFE FTSPAG *** IF NOT SET ABOVE, THIS CODE SETS IT HERE ***
	HRLI	P3,-FEFLEN	;GET LENGTH OF FE AREA
	HRRZ	T1,P3		; NEED TO GET THIS PAGE #
	PUSHJ	P,TAKPAG	;RESERVE THE PAGE SO NOBODY ELSE GETS IT.
	  POPJ	P,
	AOBJN	P3,.-3		;LOOP FOR ALL PAGES TO ALLOCATE FE AREA
INISXX:
> ; End IFCPU(KS)
	CAME	U,FSTUNI	;
	  JRST	INISA6		;
	MOVEI	T1,LPNSAT	;ALLOCATE THE PAGE FOR THE SAT.SYS
	PUSHJ	P,TAKPAG	;RIB, SO NOBODY ELSE GETS IT.
	  POPJ	P,		;
    ;HERE TO WRITE THIS SAT PAGE OUT TO THE DISK.

INISA6:	MOVE	P1,T3		;P1 HAS INDEX FOR SATSRH AND SAFETY.
	SKIPLE	STTFPC(P1)	;ROOM IN THIS SAT FOR ITSELF?
	  JRST	INISA8		;YES.
	HRRZ	T1,UNISTT(U)	;NO.  TRY TO
	CAIN	P1,(T1)		;FIND ROOM
	 MSGLIV	OGTPG		;IN AN EARLIER SAT, IF THERE IS ONE.
	MOVE	T1,[XWD %STA,%T2P] ;MEANWHILE, SAVE US
	BLT	T1,%T2P+777	;IN %T2P.
	SETZM	STTPTR(P1)	;DON'T LET OGETPG GET PAST US.
	PUSHJ	P,OGETPG	;TRY TO GET A PAGE IN AN EARLIER SAT.
	  POPJ	P,		;
	MOVEI	PG,%T2P.P	;REMEMBER WE WANT TO WRITE OUT %T2P.
	JRST	INISA9		;
INISA8:	MOVEI	P2,1		;HERE TO GET A PAGE
	PUSHJ	P,SATSRH	;IN OURSELVES.
	  POPJ	P,
	MOVEI	PG,%STA.P	;REMEMBER WE WANT TO WRITE OUT %STA.
INISA9:	MOVEM	T2,STTPTR(P1)	;STORE THE DISK PNTR TO THE SAT.
	PUSHJ	P,SATRBS	; " IN SAT.SYS RIB.
	LDB	T4,RBYPNO	;WRITE OUT THE
	PJRST	OPAGOT		;SAT PAGE.

LBNLST:	0		;Page 0 is reserved
	LPNHOM		;Primary HOM
	LP2HOM		;Secondary HOM
	LPNBAT		;Primary BAT
	LP2BAT		;Secondary BAT
LBNLEN==.-LBNLST
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	NXCLC	See if this unit needs more SATs than we have already	;;
;;		created.  Destroys T2.					;;
;;									;;
;;	expects	U/ UNIT DB						;;
;;		BEGSAT and SVSBTL setup.				;;
;;									;;
;;	returns	SKIP if no more SATs for this unit.			;;
;;		NON-SKIP with BEGSAT, LPGSAT and SVSBTL set up.		;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NXCLC:	MOVE	T2,SVSBTL	;PAGES IN THIS SAT.
	ADD	T2,BEGSAT	;LAST PAGE IN THIS SAT+1. NEXT
	CAML	T2,UNIPPU(U)	;SAT WOULD BE PAST E O UNIT?
	  JRST	CPOPJ1		;YES, NO MORE SATS THIS UNIT.
	MOVEM	T2,BEGSAT	;NO, ANOTHER SAT FOR THIS UNIT.
	ADD	T2,SVSBTL	;COMPUTE END OF NEXT
	SUBI	T2,1		;SAT.
	MOVEM	T2,LPGSAT	;REMEMBER LAST PAGE NEW SAT.
	ADDI	T2,1		;SKIP IF NEW SAT WOULD GO
	CAMG	T2,UNIPPU(U)	;PAST END OF UNIT.
	  POPJ	P,		;NO, KEEP GOING.
	SUB	T2,UNIPPU(U)	;YES. FIND OUT HOW
	MOVNS	T2		;MUCH OVER.
	ADDM	T2,SVSBTL	;CORRECT SIZE OF SAT
	ADDM	T2,LPGSAT	;AND LAST PAGE.
	POPJ	P,		;MORE SATS THIS UNIT.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	SATCLC	Set BEGSTA, SVSBTL, LPGSAT and SATIND for the first	;;
;;		SAT on a unit.  Destroys T1.				;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SATCLC:	SETZM	 BEGSAT		;BEGSAT/ 1ST SAT ON A UNIT.
	MOVEI	T1,400*^D36	;SVSBTL/ NO. OF REAL
	MOVEM	T1,SVSBTL	;ENTRIES IN THIS SAT.
	SUBI	T1,1		;LPGSAT/ LAST PAGE IN
	MOVEM	T1,LPGSAT	;THE FIRST SAT.
	SETOM	SATIND		;SAT INDEX,
	POPJ	P,		;SET TO -1 (BECAUSE WE AOS.).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	GETHMP	Allocate 1 page in current SAT for HOME.SYS while	;;
;;		creating SATs.  (Only works for first SAT on a unit).	;;
;;		Destroys T1 and T2.					;;
;;		calls: TAKPAG and HOMRBS.				;;
;;									;;
;;	expects	T1/ LOGICAL PAGE NO. TO ALLOCATE			;;
;;		T3/ STT ENTRY ADDRESS					;;
;;		U/  UNIT DB						;;
;;									;;
;;	returns	NON-SKIP IF CAN'T HAVE PAGE.				;;
;;		SKIP IF GET PAGE, RETRIEVAL POINTER STORED IN RIB	;;
;;		OF HOME.SYS IN MEMORY.					;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GETHMP:	PUSHJ	P,TAKPAG	;
	  POPJ	P,		;NOT AVAILABLE.
	PUSHJ	P,HOMRBS	;
	JRST	CPOPJ1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	TAKPAG	Marks a page taken and adjust SSTFPC in the first SAT	;;
;;		in a unit.  Destroys T1 and T2.				;;
;;									;;
;;	expects	T1/ LOGICAL PAGE NO. TO ALLOCATE			;;
;;		T3/ STT ENTRY ADDRESS					;;
;;		U/  UNIT DB						;;
;;									;;
;;	returns	NON-SKIP RETURN IF CAN'T HAVE PAGE.			;;
;;		SKIP RETURN IF GET PAGE, WITH THE RETRIEVAL POINTER	;;
;;		TO THE PAGE IN T2.					;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TAKPAG:	JSP	T4,SAVE1	;SAVE P1
	PUSH	P,T1		;SAVE PAGE NEEDED (FOR PNTR.).
	IDIVI	T1,^D36
	ADDI	T1,%STA		;
	MOVNS	T2		;
	MOVSI	P1,400000
	LSH	P1,(T2)		;SHIFT BIT INTO POSITION
	POP	P,T2		;
	TDNN	P1,(T1)		;SKIP IF AVAILABLE.
	 MSGLIV	NOTAVL		;NOT AVAILABLE.
	XORM	P1,(T1)		;MARK THE PAGE UNAVAILABLE.
	TLO	T2,RBREAL	;MAKE T2
	LDB	T1,UNYLUN	;A
	DPB	T1,RBYUNI	;RETRIEVAL POINTER.
	SOS	STTFPC(T3)	;
	JRST	CPOPJ1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;									;;
;;	MAKPAG	Makes a retrieval pointer out of the page number in	;;
;;		T1 and returns it in T2.				;;
;;									;;
;;	expects	T1/ logical page number on unit				;;
;;		U/  unit data block					;;
;;									;;
;;	returns	T2/ retrieval pointer					;;
;;									;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MAKPAG:	PUSH	P,T1		; Save page.
	MOVE	T2,T1		; Copy for pointer.
	TLO	T2,RBREAL	; Make T2
	LDB	T1,UNYLUN	; a
	DPB	T1,RBYUNI	; Retrieval pointer.
	POP	P,T1		; Restore page
	POPJ	P,		;  and return
COMMENT #
@@SUBROUTINE UFDSET
@@PURPOSE
SUBR TO SET UP INFORMATION IN A UFD RIB IN %TMP AND THEN WRITE IT OUT.
@@ENTRY
EXPECTS T1/ FILENAME OF UFD, U/ UNIT DB, P1/ AOBJN PNTR TO
FILENAMES, AND P2/ ARG. FOR RIBUSD.
@@CALLS
HASH, RIBSET, OGETPG, AND TMPOUT.
@@EXIT
NON-SKIP RETURNS IF ERROR, ELSE SKIP RETURNS WITH
T2/ DISK PNTR TO RIB ITSELF.
@@ #

UFDSET:	PUSH	P,P2		;
	MOVSI	T2,(SIXBIT .UFD.)
	MOVE	T3,MFDPPN
	MOVEI	T4,%TMP		;
	MOVEI	P4,RIPDIR	;SET DIRECTORY BIT IN STATUS
	PUSHJ	P,RIBSET	;SET UP INFO IN RIB IN CORE.
	POP	P,T2		;STORE NO. OF PAGES IN ALL THE
	MOVEM	T2,%TMP+RIBUSD	;FILES THIS UFD POINTS TO.
	MOVEM	T2,%TMP+RIBMXA	;
    ;SET UP UFDHSI NON-EXISTENT PNTRS.
	MOVEI	T1,UFDHSI	;SET UP UFDHSI
	MOVEI	T2,(SIXBIT/CAT/) ;NON-EXISTENT PNTRS
	MOVEM	T2,%TMP+RIBPFS-1(T1) ;IN THE PRIME
	SOJG	T1,.-1		;RIB.
    ;SET UP THE REAL PNTRS.
	MOVEI	P3,1		;COUNT FOR RIBALP.
	JUMPE	P1,UFDST3	;
PRINTF (<[Should allocate all 14. data pages in UFDSET for UFD project]>)
UFDST1:	MOVE	T1,(P1)		;GET T1/ FIRST FILENME.
	PUSHJ	P,HASH		;HASH IT TO T1.
	MOVE	T2,%TMP+RIBPFS-1(T1) ;PNTR FOR THIS FILE'S PAGE.
	TLNE	T2,RBREAL	;HAS IT ALREADY BEEN MADE REAL?
	  JRST	UFDST2		;YES.
	MOVE	P2,T1		;SAVE PLACE.
	PUSHJ	P,OGETPG	;NO, GET A PAGE FOR IT.
	  POPJ	P,		;LOST.
	ADDI	P3,1		;COUNT FOR RIBALP.
	MOVEM	T2,%TMP+RIBPFS-1(P2) ;STORE THE REAL PNTR.
UFDST2:	AOBJN	P1,UFDST1	;CONTINUE FOR ALL FILES.
UFDST3:	MOVEM	P3,%TMP+RIBALP	;STORE RIBALP.
	MOVEI	P3,UFDHSI*1000	;CALC AND
	MOVEM	P3,%TMP+RIBSIZ	;STORE RIBSIZ.
	PUSHJ	P,OGETPG	;GET A PAGE FOR THE
	  POPJ	P,
	MOVEM	T2,%TMP+RIBSLF	;RIB.
	PUSHJ	P,TMPOUT	;WRITE OUT THE RIB.
	  POPJ	P,
	MOVE	T2,%TMP+RIBSLF	;
	JRST	CPOPJ1
COMMENT #
@@SUBROUTINE SETUFD
@@PURPOSE
SUBR TO SET UP INFO IN THE PAGES OF A UFD AND THEN WRITE THEM OUT.
@@ENTRY
EXPECTS P3/ INDEX IN FSTPG OF FIRST FILE
AND P1/ -LOOP COUNTER,,ADDRESS OF FIRST FILENAME.
EXPECTS PRIME RIB TO BE SET UP IN %TMP.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE NON-SKIP RETURNS.
@@ #

SETUFD:	PUSH	P,P2		;SAVE P2.
	MOVEI	P2,1		;P2/ CURRENT HASH NUMBER.

SETUF1:	MOVE	T2,%TMP+RIBPFS-1(P2) ;T2/ ASSOCIATED RIB PNTR.
	TLNE	T2,RBREAL	;ANY FILE WITH THIS HASH?
	  JRST	SETUF2		;YES, GO MAKE ENTRIES.

    ;HERE TO TRY NEXT HASH NUMBER, OR TO FINISH UP.
SETUFN:	CAIGE	P2,UFDHSI	;ALL DONE?
	  AOJA	P2,SETUF1	;NO, CONTINUE.
	POP	P,P2		;YES, RESTORE P2.
	JRST	CPOPJ1		;

    ;HERE TO MAKE ENTRIES IN ONE PAGE OF THE UFD.
SETUF2:	MOVEI	T1,%T2P		;CLEAR AN AREA FOR
	PUSHJ	P,CORZER	;THE UFD IN CORE, IN %T2P.
	MOVE	T1,[XWD -776,%T2P] ;776 DIVIDES EVENLY BY 5.
	MOVEM	T1,UFDSTP	;SET UP AOBJN PNTR FOR ENTUFD.
	PUSH	P,P3		;SAVE P3 AND
	PUSH	P,P1		;P1.
SETUF4:	MOVE	T1,(P1)		;GET T1/ CURRENT FILENAME.
	PUSHJ	P,HASH		;GET HASH TO T1.
	CAIN	T1,(P2)		;MATCH FOR THIS BLOCK?
	  PUSHJ	P,ENTUFD	;YES, MAKE THE UFD
	ADDI	P3,1		;ENTRY.
	AOBJN	P1,SETUF4	;
SETUF5:	POP	P,P1		;RESTORE P1 AND
	POP	P,P3		;P3.
	MOVEI	PG,%T2P.P	;WRITE
	MOVE	T2,%TMP+RIBPFS-1(P2)	;OUT
	LDB	T4,RBYPNO	;THE
	LDB	U,RBYUNI	;PAGE
	MOVE	U,UNTTBL(U)	;OF THE
	PUSHJ	P,OPAGOT	;UFD.
	  POPJ	P,
	JRST	SETUFN		;
COMMENT #
@@SUBROUTINE HASH
@@PURPOSE
LITTLE SUBR TO HASH A FILENAME FOR A UFD.
@@ENTRY
EXPECTS FILENAME IN T1.
@@ACCUM
DESTROYS T1 AND T2.
@@EXIT
RETURNS HASH IN T1.
@@ #

HASH:	TLZ	T1,(1B0)
	IDIVI	T1,UFDHSI
	MOVEI	T1,1(T2)	;
	POPJ	P,



COMMENT #
@@SUBROUTINE ENTUFD
@@PURPOSE
SUBR TO MAKE AN ENTRY IN A UFD.
@@ENTRY
EXPECTS P3/ TABLE INDEX OF FILE TO ENTER
AND UFDSTP/ AOBJN POINTER TO UFD IN CORE.
@@ACCUM
DESTROYS T1 THRU T4 AND U.
@@ #

ENTUFD:	SKIPN	T1,FSTPG(P3)	;CFP.
	  POPJ	P,
    ;CALC THE COMPRESSED FILE POINTER.
	SKIPL	T4,UFDSTP	;SKIP IF STILL ROOM IN THIS PAGE.
	 MSGSFE	UFDERR
	MOVEM	T1,4(T4)	;STORE CFP.
	MOVE	T1,FSTFL(P3)	;FILE NAME
	HRLI	T2,(SIXBIT .SYS.) ;MOST EXTENSIONS ARE SYS
	CAMN	T1,CRSFNM	;CRASH.SAV HAS A STRANGE EXTENSTION
	  HRLI	T2,(SIXBIT .SAV.)
	CAIL	T1,0		;SKIP IF ASCII NAME, NOT OCTAL NUMBER
	  HRLI	T2,(SIXBIT .UFD.) ;OCTAL NUMBERS ARE UFDS
	MOVEM	T1,(T4)		;STORE FILE NAME
	HLLM	T2,1(T4)	;AND EXTENSION.
	LDB	T2,[POINT 9,FSTPRT(P3),^D26]
	HRRM	T2,1(T4)
	MOVE	T2,FSTALP(P3)
	HRLZM	T2,3(T4)
	SETZM	2(T4)
	ADD	T4,[XWD 5,5]	;BUMP POINTER
	MOVEM	T4,UFDSTP	;RESTORE POINTER
	POPJ	P,
COMMENT #
@@SUBROUTINE RBNFIL
@@PURPOSE
SUBR TO SET UP A RIB IN CORE IN %TMP.P, GET A SPECIFIED
NO. OF PAGES ON A UNIT, STORE THEIR RETRIEVAL PNTRS
IN THE RIB(S), AND WRITE OUT THE RIB(S).
@@ENTRY
EXPECTS:
	T1/ FILE NAME
	T2/ EXT
	T3/ PPN
	T4/ NUMBER OF PAGES TO ALLOCATE (NOT INCLUDING RIBS).
	P4/ BITS TO SET IN STATUS WORD
	U/ UNIT DB
@@ACCUM
DESTROYS
@@CALLS
RIBSET, OGETPG, OPAGOT, SATSRH, GETSAT, GETPRM, AND PTREXT.
@@EXIT
IF ERROR, NON-SKIP RETURNS, ELSE SKIP
RETURNS WITH PRIME RIB IN %TMP (ALREADY WRITTEN OUT)
AND PGSRIB INCREMENTED FOR EACH RIB (OTHER THAN THE PRIME RIB)
GENERATED.
@@ #

    ;SET UP THE PRIME RIB IN CORE.
RBNFIL:	MOVEM	T4,PAGNED	;SAVE NO. OF PAGES REQUESTED.
	SETZM	PGSRIB		;PGSRIB HOLDS NO. OF SPARE RIBS GENERATED.
	MOVEI	T4,%TMP		;SET UP THE
	PUSHJ	P,RIBSET	;RIB AREA.
	MOVEI	T4,1		;SET NO. OF PAGES
	ADD	T4,PAGNED	;PLUS ONE
	MOVEM	T4,%TMP+RIBALP	;RIB.
	PUSHJ	P,OGETPG	;GET A DISK PAGE FOR THE RIB.
	  POPJ	P,
	MOVEM	T2,%TMP+RIBSLF	;STORE SELF RIB PNTR.
	HRLI	T1,-RBLVPR-1	;SET UP
	HRRI	T1,%TMP+RIBPFS-1
	MOVEM	T1,TMPRBP	;PNTR TO RIB AREA.

    ;LOOK FOR DISK SPACE. SEARCH FOR THE SAT ON THIS UNIT WITH THE MOST SPACE.

RBNFL1:	SETZB	P1,P2		;CLR MAX FOUND AND INDEX.
	HRRZ	T1,UNISTT(U)	;T1/ INDEX INTO STT.
RBNFL2:	SKIPN	T2,STTPTR(T1)	;AT E O TABLE?
	  JRST	RBNFL4		;YES.
	SKIPN	T3,STTFPC(T1)	;NO. ANY FREE PAGES IN THIS SAT?
	  JRST	RBNFL3		;NO.
	CAML	T3,PAGNED	;YES. ENOUGH TO SATISFY REQUEST?
	  JRST	RBNFL6		;YES.
	CAMG	T3,P2		;NO. FOUND MORE THAN MAX SEEN ALREADY?
	  JRST	RBNFL3		;NO.
	MOVE	P2,T3		;YES, SAVE IT AS
	MOVE	P1,T1		;MAX.
RBNFL3:	ADDI	T1,STTLEN	;NO.  LOOK AT NEXT
	JRST	RBNFL2		;SAT ENTRY IN STT.

      ;HERE AT END OF TABLE.
RBNFL4:	JUMPN	P2,.+2		;BETTER HAVE FOUND SOMETHING.
	 MSGLIV	OGTPG
	PUSH	P,P1		;SAVE SAT'S INDEX IN STT.
	SKIPA	T2,STTPTR(P1)	;T2/ SAT'S DISK POINTER.

    ;HERE TO READ IN THE SAT.
RBNFL6:	PUSH	P,T1		;SAVE SAT'S INDEX IN STT.
	PUSHJ	P,GETSAT	;
	  JRST	[POP  P,T1
		 POPJ P,]
	MOVE	P2,PAGNED	;SET UP ARGS
	POP	P,P1		;FOR SATSRH. (CLRS BITS & RETURNS

    ;HERE TO GET SOME SPACE IN THE SAT.
RBNFL7:	PUSHJ	P,SATSRH	;T2/ DISK PNTR AND T1/ COUNT.).
	  POPJ	P,
	MOVE	P3,T1		;P3/ # PAGES GOTTEN.
	MOVE	P2,PAGNED	;CALC NO.
	SUB	P2,P3		;LEFT TO
	MOVEM	P2,PAGNED	;GET.
RBNFL8:	PUSHJ	P,PTREXT 	;STORE THE
	  POPJ	P,
	SOJLE	P3,.+2		;DISK POINTERS
	AOJA	T2,RBNFL8	;TO GOTTEN SPACE.

	JUMPLE	P2,RBNFL9	;MORE PAGES TO GET?
	SKIPLE	STTFPC(P1)	;YES.  MORE ROOM IN THIS SAT?
	JRST	RBNFL7		;YES.
	 JRST	RBNFL1		;NO.

    ;HERE WHEN DONE STORING PNTRS (EXCEPT FOR EOF PNTR).
RBNFL9:	SETZ	T2,		;STORE
	PUSHJ	P,PTREXT	;EOF PNTR.
	  POPJ	P,
	SKIPN	PGSRIB		;MORE THAN JUST A PRIME RIB?
	  JRST	RBNF10		;NO.
	PUSHJ	P,GETPRM	;YES, GET IT AND
	  POPJ	P,
	MOVE	P1,PGSRIB	;ADJUST
	ADDM	P1,%TMP+RIBALP	;RIBALP.
RBNF10:	MOVE	T2,%TMP+RIBSLF	;
	LDB	T4,RBYPNO	;WRITE
	MOVEI	PG,%TMP.P	;IT
	PUSHJ	P,OPAGOT	;OUT.
	  POPJ	P,
	JRST	CPOPJ1

PAGNED: Z		;TEMP STORAGE FOR RBNFIL.
COMMENT #
@@SUBROUTINE SATSRH
@@PURPOSE
SUBR TO GET SOME CONTIGUOUS FREE PAGES ON A SAT IN %STA, AND SET THEM IN USE.
SAT IS GUARANTEED TO HAVE SOME PAGES FREE ON ENTRY.
@@ENTRY
EXPECTS P1/ STT ENTRY ADDR OF SAT, P2/ MAX NO. OF PAGES
TO GET, U/ UNIT NO., AND F/ DDB.
@@ACCUM
DESTROYS T1 THRU T4 AND P2.
@@EXIT
IF ERROR, NON-SKIP RETURNS
 ELSE SKIP RETURNS WITH
	T2/ DISK POINTER TO FIRST PAGE GOTTEN
	T1/ NO. OF PAGES ACTUALLY GOTTEN
	THE SAT HAS THE PAGES TAKEN MARKED IN USE.
	STTFPC AND STTAOB ARE ALSO ADJUSTED.
@@ #

SATSRH:	SKIPN	T1,STTAOB(P1)	;T1/ CURRENT AOBJN POINTER.
	  JRST	SATSR2		;START AT START OF SAT IF NONE.
	SKIPE	T2,(T1)		;ANY FREE BITS IN THIS WORD?
	  JRST	SATSR3		;YES.
	AOBJN	T1,.-2		;NO, TRY NEXT WORD.

SATSR2:	MOVE	T1,[XWD -400,%STA] ;T1/ AOBJN PNTR TO START OF SAT.
	SKIPE	T2,(T1)		;ANY FREE BITS IN THIS WORD?
	  JRST	SATSR3		;YES.
	AOBJN	T1,.-2		;NO, TRY NEXT WORD.
	MSGLIV	OGTPG

    ;HERE ON FOUND FIRST FREE PAGE.  BUILD THE DISK POINTER TO IT.

SATSR3:	JFFO	T2,.+2		;GET T3/ NO. OF BITS INTO WORD.
	 STOPCD
	HRRZI	T4,-%STA(T1)	;PAGE NO. IS
	IMULI	T4,^D36		;(NO. OF WORDS INTO SAT *
	ADDI	T4,(T3)		;^D36) +
	HRRZ	T2,UNISTT(U)	;(NO. OF BITS INTO WORD) +
	SUB	T2,P1		;
	MOVNS	T2		;
	PUSH	P,T3		;
	IDIVI	T2,STTLEN	;(NO. OF SAT *
	IMULI	T2,400*^D36	;NO. OF PAGES
	POP	P,T3		;
	ADDI	T4,(T2)		;PER SAT.).
	SETZ	T2,		;BUILD THE
	DPB	T4,RBYPNO	;DISK
	LDB	T4,UNYLUN	;PNTR
	DPB	T4,RBYUNI	;AND
	TLO	T2,RBREAL	;
	PUSH	P,T2		;SAVE IT.

    ;NOW FIND ALL THE CONTIGUOUS PAGES WE CAN/WANT, AND MARK THEM TAKEN.

	MOVE	T2,(T1)		;T2/ SAT WORD AGAIN.
	HRLZI	T4,400000	;BUILD THE
	MOVNS	T3		;MASK IN
	LSH	T4,(T3)		;T4.
	MOVEM	T1,STTAOB(P1)	;SAVE THE AOBJN POINTER.
	SETZ	T1,		;T1/ # OF FREE PAGES.
	ADDI	T3,^D36		;T3/ MAX NO.
	CAMLE	T3,P2		;OF BITS TO LOOK
	  MOVE	T3,P2		;AT IN THIS WORD.
SATSR5:	TDZN	T2,T4		;NEXT PAGE IS FREE?
	  JRST	SATSR8		;NO, DONE.
	ADDI	T1,1		;YES, COUNT IT.
	LSH	T4,-1		;ADJUST THE MASK.
	SOJG	T3,SATSR5	;CONTINUE IN THIS WORD.
	CAML	T1,P2		;NEED MORE?
	  JRST	SATSR8		;NO.
	MOVE	T3,STTAOB(P1)	;YES, TRY TO GET
	AOBJN	T3,.+2		;NEXT WORD.  IS THERE ONE?
	  JRST	SATSR8		;NO.  DONE.
	MOVEM	T2,-1(T3)	;YES.
	SKIPN	T2,(T3)		; ANY FREE PAGES IN IT?
	  JRST	SATSR9		;NO.  DONE.
	MOVEM	T3,STTAOB(P1)	;YES.  SAVE AOBJN PNTR.
	HRLZI	T4,400000	;SET UP MASK FOR NEW WORD.
	MOVE	T3,P2		;SET UP T3 TO
	SUB	T3,T1		;MAX. NO. OF
	CAILE	T3,^D36		;BITS TO LOOK AT
	  MOVEI	T3,^D36		;IN THIS WORD.
	JRST	SATSR5		;GO LOOK AT THIS WORD.
    ;HERE ON DONE.
SATSR8:	MOVE	T3,STTAOB(P1)	;
	MOVEM	T2,(T3)		;
SATSR9:	MOVE	T3,STTFPC(P1)	;ADJUST THE
	SUB	T3,T1		;FREE PAGE
	MOVEM	T3,STTFPC(P1)	;COUNT.
	POP	P,T2		;RESTORE T2/ DISK POINTER.
	JRST	CPOPJ1
COMMENT #
@@SUBROUTINE OGETPG
@@PURPOSE
SUBR TO GET ONE PAGE ON THE DISK.
@@ENTRY
EXPECTS F/ DDB AND U/ UNIT DB.
@@ACCUM
DESTROYS T1 THRU T4 AND PG.
@@CALLS
SATSRH AND GETSAT.
@@EXIT
NON-SKIP RETURNS IF NO PAGE AVAILABLE,
ELSE SKIP RETURNS WITH T2/ DISK PNTR TO THE PAGE.
@@ #

OGETPG:	PUSH	P,P1		;SAVE P1 AND
	PUSH	P,P2		;P2.
	MOVEI	P2,1		;TELL SATSRH WE WANT ONE PAGE.
	HRRZ	P1,UNISTT(U)	;P1/ STT ENTRY ADDR.
OGETP2:	SKIPE	T2,STTPTR(P1)	;AT END OF STT?
	  JRST	OGETP3
	POP	P,P2
	POP	P,P1
	MSGLIV	OGTPG
OGETP3:	SKIPE	STTFPC(P1)	;NO.  ANY FREE PAGES IN THIS SAT?
	  JRST	OGETP4		;YES.
	ADDI	P1,STTLEN	;NO, CONTINUE.
	JRST	OGETP2		;

OGETP4:	PUSHJ	P,GETSAT	;
	  JRST	OGETP5
	PUSHJ	P,SATSRH	;GET T2/ DISK PNTR TO 1ST FREE PAGE.
	  JRST	OGETP5
	POP	P,P2		;RESTORE P2 AND
	POP	P,P1		;P1.
	JRST	CPOPJ1

OGETP5:	POP	P,P2
	POP	P,P1
	POPJ	P,
COMMENT #
@@SUBROUTINE CNDSWT
@@PURPOSE
SUBR TO CONDITIONALLY WRITE OUT A SAT IN CORE.
@@ACCUM
DESTROYS U, PG,
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE, NON-SKIP RETURNS.
@@ #

CNDSWT:	SKIPN	T2,SATDSK	;IS THERE A SAT IN %STA?
	  JRST	CPOPJ1		;NO, NO NEED TO DO ANYTHING.
	LDB	T4,RBYPNO	;YES,
	LDB	U,RBYUNI	;WRITE
	MOVE	U,UNTTBL(U)	;IT
	MOVEI	PG,%STA.P	;OUT.
	PUSHJ	P,OPAGOT	;
	 MSGLIV	IOFAL
	SETZM	SATDSK		;MARK NO SAT IN CORE.
	JRST	CPOPJ1		;SUCCESS RETURN.
COMMENT #
@@SUBROUTINE GETSAT
@@PURPOSE
SUBR TO GET A SAT INTO CORE, POSSIBLY WRITING OUT A SAT FIRST.
@@ENTRY
EXPECTS T2/ DISK ADDRESS OF DESIRED SAT, U/ UNIT DB, AND F/ DDB.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE, NON-SKIP RETURNS.
@@ #

GETSAT:	CAMN	T2,SATDSK	;ALREADY HAVE THIS SAT IN CORE?
	  JRST	CPOPJ1		;YES.  JUST TAKE SUCCESS RETURN.
	MOVEI	PG,%STA.P	;NO, IS THERE
	EXCH	T2,SATDSK	;A SAT
	JUMPE	T2,GTSAT6	;IN CORE?
	LDB	T4,RBYPNO	;YES.  WRITE IT
	PUSH	P,U		;
	LDB	U,RBYUNI	;
	MOVE	U,UNTTBL(U)	;
	PUSHJ	P,OPAGOT	;OUT.
	  PUSHJ	P,[POP P,T2	;
		EXCH T2,(P)	;
		MSGLIV 	IOFAL]
	POP	P,U		;
GTSAT6:	MOVE	T2,SATDSK	;HERE TO READ OUR SAT
	LDB	T4,RBYPNO	;INTO CORE.
	PUSHJ	P,OPAGIN	;
	 MSGLIV	IOFAL
	JRST	CPOPJ1		;
COMMENT #
@@SUBROUTINE SATRBS/HOMRBS
@@PURPOSE
VARIOUS SUBRS TO STORE A RETRIEVAL POINTER AND INC RIBALP.
@@ENTRY
EXPECTS T2/ RETRIEVAL POINTER TO STORE AND XXXRBP TO BE AN AOBJN POINTER.
@@ACCUM
DESTROYS T1.
@@EXIT
STOPCDS IF AOBJN POINTER RUNS OUT.
ELSE RETURNS WITH NEW AOBJN POINTER STORED AND RIBALC ADJUSTED.
@@ #

TMPRBS:	MOVE	T1,TMPRBP
	AOBJN	T1,TMPRS1
	 MSGSFE	RBNOUT
TMPRS1:	MOVEM	T1,TMPRBP
	PUSHJ	P,SAVT		;SAVE T2,T3,T4
	MOVEI	T3,%TMP
	JRST	HOMRS2

SATRBS:	MOVE	T1,SATRBP
	AOBJN	T1,SATRS1
	 MSGSFE	RBNOUT
SATRS1:	MOVEM	T1,SATRBP
	PUSHJ	P,SAVT		;SAVE T2,T3,T4
	MOVEI	T3,%STR
	JRST	HOMRS2

HOMRBS:	MOVE	T1,HOMRBP
	AOBJN	T1,HOMRS1
	 MSGSFE	RBNOUT
HOMRS1:	MOVEM	T1,HOMRBP
	PUSHJ	P,SAVT
	MOVEI	T3,%HMR
HOMRS2:	MOVEM	T2,(T1)
	AOS	RIBALP(T3)	;COUNT NO. OF PAGES IN THIS FILE.
	POPJ	P,



SATRBP:	Z	;PNTR TO SPACE IN SAT.SYS RIB FOR RETRIEVAL PNTRS.
HOMRBP:	Z	;  "              HOM.SYS        "
TMPRBP:	Z	;  "              XXXXXXX        "
COMMENT #
@@SUBROUTINE CLUAOB/CLSAOB
@@PURPOSE
SUBRS TO CLEAR OUT THE STTAOB ENTRIES FOR A UNIT (CLUAOB)
OR FOR ALL UNITS IN A STR (CLSAOB).
@@ENTRY
CLUAOB EXPECTS UNIT DB ADDR IN REFUNI.  CLSAOB EXPECTS
DB ADDB OF FIRST UNIT ON THE STR IN FTSUNI.
@@ACCUM
DESTROYS U AND T1.
@@ #

CLUAOB:	MOVE	U,REFUNI
CLUAB1:	HRRZ	T1,UNISTT(U)	;
CLUAB2:	SKIPN	STTPTR(T1)	;
	  POPJ	P,
	SETZM	STTAOB(T1)	;
	ADDI	T1,STTLEN
	JRST	CLUAB2		;

CLSAOB:	MOVE	U,FSTUNI	;
	PUSHJ	P,CLUAB1	;
	HLRZ	U,UNISTR(U)	;
	JUMPN	U,.-2		;
	POPJ	P,
COMMENT #
@@SUBROUTINE TMPIN/TMPOUT
@@PURPOSE
LITTLE SUBRS TO SET UP ARGS AND CALL OPAGIN/OT FOR IO TO/FROM %TMP.
@@ENTRY
EXPECT T2/ DISK POINTER OF PAGE TO BE TRANSFERRED.
@@CALLS
OPAGIN AND OPAGOT.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURN IFF OPAGOT/IN DO.  ELSE NON-SKIP RETURN.
@@ #

TMPIN:	MOVEI	T3,OPAGIN	;
	JRST	.+2
TMPOUT:	MOVEI	T3,OPAGOT	;
	LDB	T4,RBYPNO	;GET PAGE NO. FROM T2.
	LDB	U,RBYUNI	;GET UNIT DB
	MOVE	U,UNTTBL(U)	;ADDR FROM T2 AND UNTTBL.
	MOVEI	PG,%TMP.P	;IO TO/FROM %TMP.
	PUSHJ	P,(T3)		;READ OR WRITE THE PAGE.
	 MSGLIV	IOFAL
	JRST	CPOPJ1		;WON.
COMMENT #
@@SUBROUTINE PTREXT
@@PURPOSE
SUBR TO STORE A RETRIEVAL POINTER IN %TMP ACCORDING TO TMPRBP,
TAKING INTO ACCOUNT AN EXTENDED RIB STRUCTURE.
(THIS REALLY DOESN'T NEED THREE LEVELS; ALSO PERHAPS THE
OGETPG CALLS SHOULD LOOK AT MORE THAN ONE UNIT.)
@@ENTRY
EXPECTS TMPRBP AND THE RIB IN %TMP TO BE SET UP,
T2/ THE RETRIEVAL POINTER TO BE STORED, AND F/ DDB.
@@CALLS
RIBEX1, RIBEX2, RIBEX3, RIBEX4, OGETPG, TMPOUT, TMPIN, CORZER AND MOROOM.
@@ACCUM
DESTROYS T1, T3, T4, AND PG.
PRESERVES U.
@@EXIT
IF ERROR, NON-SKIP RETURNS, ELSE SKIP RETURNS.
ON EXIT, THE RIB IN %TMP MAY NOT BE THE RIB THAT WAS THERE
ON ENTRY.  ON SUCCESSFUL EXIT, TMPRBP WILL BE SET UP PROPERLY
AND PGSRIB IS INCREMENTED FOR EACH ADDITIONAL RIB GENERATED.
@@ #

PTREXT:	MOVE	T1,TMPRBP	;GET THE AOBJN PNTR TO THE
	AOBJN	T1,PTROT2	;RETRIEVAL PNTR STORAGE AREA.
	PUSH	P,U		;PRESERVE U.
	JRST	PTREX1		;OUT OF ROOM.

PTROU0:	POP	P,P2		;
	POP	P,P1
PTROUT:	POP	P,T2		;RESTORE THE RETRIEVAL POINTER.
	POP	P,U		;RESTORE U.
PTROT2:	MOVEM	T1,TMPRBP	;STORE THE AOBJN
	MOVEM	T2,(T1)		;PNTR & RETRIEVAL PNTR.
	JRST	CPOPJ1

    ;HERE WHEN WE MUST GET ANOTHER RIB.
PTREX1:	PUSH	P,T2		;SAVE RET PNTR WE WANT TO STORE.
	SKIPE	T2,%TMP+RIBSLF	;GET A DISK PAGE TO WRITE US
	  JRST	PTREX2		;OUT TO, UNLESS
	PUSHJ	P,OGETPG	;WE HAVE
	  JRST	PTRFAL		;ONE
	MOVEM	T2,%TMP+RIBSLF	;ALREADY.
PTREX2:	MOVE	T1,%TMP+RIBSZS	;IF NOT AT LOWEST LEVEL
	SOJG	T1,PTREX3	;AND EO RIB WITH REAL PNTR,
	SKIPN	%TMP+RIBRIB	;OR IF ONLY ONE RIB, WE
	  JRST	PTREX3		;HAVE TO EXPAND.

    ;HERE WHEN WE ARE AT LOWEST LEVEL AND THERE IS A HIGHER RIB.
    ;WE MAY OR MAY NOT HAVE TO EXPAND.

	PUSH	P,%TMP+RIBRPS	;SAVE OUR POSITION FOR MOROOM.
	PUSHJ	P,TMPOUT	;(WE HAVE ALREADY SET UP T2), SO
	  JRST	PTRFL1		;WRITE US OUT.
	MOVE	T2,%TMP+RIBRIB	;READ IN THE
	PUSHJ	P,TMPIN		;HIGHER RIB.
	  JRST	PTRFL1
	POP	P,T1		;RESTORE OUR POINTER.
	PUSHJ	P,MOROOM	;ROOM FOR ANY MORE PNTRS IN IT?
	  JRST	PTROUT		;YES.
	SKIPN	T2,%TMP+RIBRIB	;NO. IF THIS IS THE HIGHEST,
	  JRST	PTREX3		;GO EXPAND.
	PUSH	P,%TMP+RIBRPS	;SAVE OUR POSITION FOR MOROOM.
	PUSHJ	P,TMPIN		;READ IN THE HIGHER
	  JRST	PTRFL1		;RIB.
	POP	P,T1		;RESTORE OUR POSITION.
	PUSHJ	P,MOROOM	;ROOM FOR ANY MORE PNTRS?
	  JRST	PTROUT		;YES.
	MSGSFE	RBEOUT

    ;HERE TO EXPAND THE RIB STRUCTURE.

PTREX3:	MOVEI	T1,%T2P		;CLEAR OUT A SPARE RIB
	PUSHJ	P,CORZER	;IN %T2P.
	AOS	PGSRIB		;COUNT IT.
	PUSHJ	P,OGETPG	;GET A PAGE
	  JRST	PTRFAL		;FOR
	MOVEM	T2,%T2P+RIBSLF	;IT.
	MOVEI	T1,CODRIB	;SET ITS
	MOVEM	T1,%T2P+RIBCOD	;RIBCOD.
	PUSH	P,P1		;SET UP THE
	PUSH	P,P2		;ARGS
	MOVEI	P1,%TMP		;FOR
	MOVEI	P2,%T2P		;THE RIBEX? SUBRS.
	MOVE	T1,%TMP+RIBLST	;JUMP UNLESS LAST PNTR IN OUR
	JUMPGE	T1,PTREX4	;SOURCE RIB IS A SPARE RIB PNTR.

    ;HERE TO EXPAND FROM TWO LEVELS TO THREE.

	PUSHJ	P,RIBEX1	;SET UP INFO IN BOTH RIBS.
	MOVEI	T4,RIBSFS+RBLVPR-1 ;
	JRST	PTRE45		;


    ;HERE ON ALL RIB EXPANSION EXCEPT FROM TWO LEVELS TO THREE.

PTREX4:	PUSHJ	P,RIBEX2	;SET UP INFO IN BOTH RIBS.
	  JRST	PTRE45		;NEED NO INTERMED RIB.
	PUSH	P,T4		;NEED INTERMED RIB.  SAVE RPS.
	PUSHJ	P,OGETPG	;
	  JRST	PTRFL2
	AOS	PGSRIB		;COUNT THE INTERMEDIATE RIB.
	PUSHJ	P,RIBEX3	;LINK IT IN.
	MOVE	T2,%TMP+RIBSLF	;
	PUSHJ	P,TMPOUT	;WRITE OUT THE
	  JRST	PTRFL2		;HIGHEST RIB.
	MOVEI	T1,%TMP		;CLEAR SPACE FOR THE
	PUSHJ	P,CORZER	;INTERMEDIATE RIB.
	  JSP	T4,RIBEX4	;SET UP MORE STUFF.
	POP	P,T4		;RESTORE RPS.


PTRE45:	HRLZI	P1,-RIBLST(T4)	;SET UP THE AOBJN PNTR
	HRRI	P1,%TMP+1(T4)	;FOR PTROU0.
	MOVE	T2,%TMP+RIBSLF	;WRITE OUT
	PUSHJ	P,TMPOUT	;A RIB.
	  JRST	PTRFL0
	MOVE	T1,[XWD %T2P,%TMP] ;COPY THE NEW RIB TO
	BLT	T1,%TMP+777	;THE CURRENT RIB AREA.
	MOVE	T1,P1		;GET AOBJN PNTR FOR PTROUT.
	JRST	PTROU0		;


PTRFL2:	POP	P,T1		;VARIOUS
PTRFL0:	POP	P,P2
	POP	P,P1		;ERROR
	JRST	PTRFAL

PTRFL1:	POP	P,T1		;EXITS.
PTRFAL:	POP	P,T2
	POP	P,U
	POPJ	P,
COMMENT #
@@SUBROUTINE MOROOM
@@PURPOSE
LITTLE SUBR TO SEE IF THERE IS ANY MORE ROOM IN A RIB IN
%TMP TO STORE POINTERS.
@@ENTRY
EXPECTS T1/RIBRPS FROM LOWER RIB.
@@ACCUM
DESTROYS T1 AND T2.
@@EXIT
SKIP RETURNS IF NO MORE ROOM.  NON-SKIP RETURNS IF THERE IS
MORE ROOM, WITH T1/ AOBJN POINTER TO ROOM.
@@ #

MOROOM:	ADDI	T1,%TMP+1	;GET ADDR OF NEXT POINTER.
	CAILE	T1,%TMP+RIBLST	;PAST E O RIB?
	 JRST	CPOPJ1		;YES, RETURN.
	MOVEI	T2,(T1)		;NO.  MAKE THE USED AOBJN
	SUBI	T2,%TMP+RIBLST	;PNTR IN T1,
	HRLI	T1,-1(T2)	;AND TAKE THE
	POPJ	P,		;SUCCESSFUL RETURN.
COMMENT #
@@SUBROUTINE GETPRM
@@PURPOSE
SUBR TO WRITE OUT THE RIB IN CORE IN %TMP AND THEN GET
ITS PRIME RIB INTO %TMP.
@@CALLS
TMPIN AND TMPOUT.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS UNLESS ERROR, IN WHICH CASE NON-SKIP RETURNS.
@@ #

GETPRM:	SKIPN	%TMP+RIBRIB	;
	 JRST	CPOPJ1		;
	MOVEI	P1,2		;CHECK FOR 3 LEVELS.
GETPR4:	PUSH	P,%TMP+RIBRIB	;SAVE ADDR OF HIGHER RIB.
	SKIPE	T2,%TMP+RIBSLF	;IF NECESSARY, GET
	  JRST	.+3		;
	PUSHJ	P,OGETPG	;A PAGE FOR THE
	  JRST	[POP  P,T1
		 POPJ P,]
	MOVEM	T2,%TMP+RIBSLF	;CURRENT RIB.
	PUSHJ	P,TMPOUT	;
	  JRST	[POP  P,T1
		 POPJ P,]
	POP	P,T2		;READ IN THE
	PUSHJ	P,TMPIN		;HIGHER RIB.
	  POPJ	P,
	SKIPN	%TMP+RIBRIB	;DONE?
	  JRST	CPOPJ1		;YES
	SOJG	P1,GETPR4	;NO, DON'T DO MORE THAN 3 LEVELS.
	MSGSFE	RIBFAL
COMMENT #
@@SUBROUTINE RIBSET
@@PURPOSE
SUBR TO SET UP PRIME RIB INFORMATION IN A SPECIFIED AREA IN CORE.
@@ENTRY
EXPECTS:
	T1=NAME OF FILE
	T2=EXT
	T3=PPN
	T4=ADDR OF CORE AREA TO BE SET UP.
	P4=BITS TO SET IN STATUS WORD
CURPRT/ BITS FOR RIYPRV.
STNVER/ STANDARD VERSION NO.
@@ACCUM
DESTROYS T1 AND T2.
@@CALLS
CORZER.
@@ #

RIBSET:	PUSH	P,T1		;SAVE T1 AND
	PUSH	P,T2		;T2 FROM CORZER.
	MOVE	T1,T4		;ARG FOR CORZER.
	PUSHJ	P,CORZER	;CLEAR OUT THE RIB AREA.
	POP	P,T2		;RESTORE T2 AND
	POP	P,T1		;T1.
	MOVEM	T1,RIBNAM(T4)
	HRRI	T2,0		;SET ACCESS DATE.
	MOVEM	T2,RIBEXT(T4)
	MOVEM	T3,RIBPPN(T4)
	MOVE	T3,CURPRT	;
	HRLZM	T3,RIBPRV(T4)	;
;*;	MOVE	T3,STNVER	;STANDARD VERSION NUMBER
;*;	MOVEM	T3,RIBVER(T4)
	MOVEI	T3,1		;
	MOVEM	T3,RIBSZS(T4)	;
	MOVEI	T3,CODRIB	;UNLIKELY CODE
	MOVEM	T3,RIBCOD(T4)	;FOR RIB.
	MOVEM	P4,RIBSTS(T4)	;
	TRNN	P4,RIPDIR	;UFD  OR MFD?
	  POPJ	P,		;NO, RETURN.

    ;HERE ONLY FOR MFD OR UFDS.
	MOVE	T3,QUOTAF	;YES, SET FCFS
	MOVEM	T3,RIBQTF(T4)	;AND
	MOVE	T3,QUOTAO	;LOGGED OUT
	MOVEM	T3,RIBQTO(T4)	;QUOTAS.
	MOVE	T2,[SIXBIT /UFD/] ;SET UP
	CAMN	T1,MFDUFD	;RIBUNM
	  JRST	RIBST8		;WITH
	MOVE	T2,[SIXBIT /SYS/] ;THE
	CAMN	T1,SYSUFD	;APPROPRIATE
	  JRST	RIBST8		;
	MOVE	T2,[SIXBIT /NG/] ;MFD OR UFD
	MOVEM	T2,RIBUN1(T4)	;
	MOVE	T2,[SIXBIT /SPOOLI/] ;
RIBST8:	MOVEM	T2,RIBUNM(T4)	;NAME.
	POPJ	P,

CURPRT:	Z	;STORAGE FOR RIBSET.
COMMENT #
@@SUBROUTINE CNVSIZ/CNVSZM
@@PURPOSE
LITTLE SUBRS TO SET RIBSIZ.
@@ENTRY
EXPECTS T1/ ADDR OF RIB IN CORE.
@@ACCUM
DESTROYS T2.
@@ #

CNVSZM:	SOSA	T2,RIBALP(T1)	;ADJUST ALP FOR STORING EOF LATER.
CNVSIZ:	MOVE	T2,RIBALP(T1)	;
	LSH	T2,P2WLSH	;CALCULATE WORDS
	MOVEM	T2,RIBSIZ(T1)	;
	POPJ	P,
SUBTTL	Tables and storage

;*** This table MUST be identical to the home page, no variations
DEFINE ITEMS<
    X	SAT,FNM,SAT,STR;	;;017  SAT.SYS    SAT file
    X	HOM,FNM,HOME,HMR;	;;020  HOME.SYS   HOME, BAT and BOOTS
  ifn FTSPAG,<
    X	SPG,FNM,SPAGES,TMP;	;;021  SPAGES.SYS Spare PAGES file, cyl 1 & 2
  > ; End ifn FTSPAG
  ifndef PAKFIL,<PAKFIL==.-FSTFL>;; per/unit files
  ife FTSPAG,<
    X   SPG,FNM,SPAGES;		;; SPAGES.SYS Spare PAGES file, not made!
  > ; End ife FTSPAG
    X	CRS,FNM,CRASH;		;;022  CRASH.SAV  (later .EXE) crash file
  ifndef LSTFL,<LSTFL==.-FSTFL>	;; all files
    X	SYS,UFD;		;;023  [SYS].UFD
    X	PRT,UFD;		;;024  [PRT].UFD
    X	MFD,UFD;		;;025  [MFD].UFD
  ifndef LSTUF,<LSTUF==.-LSTFL-FSTFL>;; UFDs to create
> ; End Define ITEMS

Define X(NAM,NM1,TXT,RIB)<NAM'NM1: <SIXBIT \'TXT'\>>
FSTFL:	ITEMS			;NAMES OF FILES WE CREATE

Define X(NAM,NM1,TXT,RIB)<NAM'RBD: BLOCK 1>
FSTPG:	ITEMS			;Logical page #s of prime ribs (ret. ptrs)
LSTPGL==.-FSTPG

Define X(NAM,NM1,TXT,RIB)<IFNB <RIB>,<NAM'CTL: XWD %'RIB,%'RIB'.P>>
FSTCTL:	ITEMS

Define X(NAM,NM1,TXT,RIB)<NAM'PRT: BLOCK 1>
FSTPRT:	ITEMS			;BITS SET IN RIYPRV FOR EACH FILE.

Define X(NAM,NM1,TXT,RIB)<NAM'ALP: BLOCK 1>
FSTALP:	ITEMS			;NO. OF PAGES (incl RIBS) IN EACH FILE.
LSTALP==.-FSTALP

IFCPU(KS),<
FEFFNM:	SIXBIT	\FEFILE\	;FE FILE FOR KS-10
FEFRBD:	Block	1		;Logical page # of prime rib for FEFILE.SYS
FEFPRT:	Block	1		;Bits for RIYPRV for FEFILE.SYS
FEFALP:	Block	1		;No. of pages (incl RIBs) in FEFILE.SYS
> ; End IFCPU(KS)
SUBTTL	MISC. DATA LOCATIONS.

RANNO:	BLOCK	1	;Holder for RANDOM # for REFRESH
UFDSTP:	BLOCK	1	;PNTR TO SPACE IN UFD RIB FOR PNTRS.

BEGSAT:	BLOCK	1
SVSBTL:	BLOCK	1
LPGSAT:	BLOCK	1	;LAST CLUSTER IN CURRENT SAT.

FSTUNI:	BLOCK	1	;ADDR OF FIRST UNIT IN STR.

SATIND:	BLOCK 1		;USED AS A TEMPORARY.

SATDSK:	Z		;FLAG TO PREVENT UNNECESSARY IO ON SAT
			;PAGES.

PGSSPG:	Z		;USED BY SPAGES AND FEFILE
PGSRIB:	Z		;USED BY RBNFIL, ETC. TO KEEP TRACK OF COUNT OF
			;RIBS AND MAYBE OF PAGES.

REFLIT:	LIT
	VAR


REFLNR=.-%REF+1
REFLNP=<REFLNR!777>+1

ONSZCK(REFSTR,REF)	;CHECK TO SEE IF ENOUGH PAGES ALLOCATED

DEPHASE

REFEND:	END
7uMJ\