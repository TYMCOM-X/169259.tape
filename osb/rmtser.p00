TITLE  RMTSER  - REMOTE PERIPHERAL SERVICE VERSION 3
SUBTTL  SYMBOL DEFINITIONS

	STOPCD(,ENTRY,RMTSER)

COMMENT !
EDWARD E. POLLACK APRIL 1973
ASSEMBLED WITH S.MAC
NOTE: THIS PROGRAM RELIES UPON THE FACT THAT UUO'S AND
THE CLOCK NEVER INTERRUPT EACH OTHER. THERE ARE NO INTERLOCKS
BETWEEN THE TWO ENTRIES AND ANY CHANGE OF THE NON-INTERRUPT
FEATURE MAY BE DISASTEROUS.
DOUBLE MONITOR BUFFERING IS NOT USED FOR THIS DEVICE BECAUSE
THE 620 ACTS AS A SECOND MONITOR BUFFER.

CAN HANDLE UP TO 4 620'S, EACH WITH 8 LINES, FOR A TOTAL OF 32
LINES.
SOME MODIFICATION TO CODE WILL BE NECESSARY WHEN MORE THAN 1
620 IS IMPLEMENTED TO PUT THE 2 BITS OF 620#
IN FRONT OF THE 3 BITS OF LINE NUMBER WHEN INDEXING INTO RMTDDP.
EACH 620 WILL HAVE ITS OWN RING AND KEY CELL, THUS QTO620
WILL HAVE TO BE CHANGED SLIGHTLY, AS WILL CKRMT AND SIK620.
THE LATTER MUST ONLY CRASH PORTS ON THE OFFENDING 620, RATHER
THAN ALL PORTS.
HOWEVER, NO CHANGES IN UUO'S OR MESSAGE FORMATS SHOULD BE NECESSARY
AND THE ONLY CHANGES IN UUO CODE SHOULD BE CALLS TO QTO620.

!

VERRMT==10
VERDAT==^D102473	;CURRENT VERSION AND DATE OF LAST CHANGE
;FILE ORIGINALLY CREATED 5/16/73

;BIT DEFINITIONS

;IN DEVIOS
RMTZAP==1B0		;PORT IS ZAPPED
IOSVAL==1B1		;PORT IS VALIDATED
IOSARM==1B2		;ARMED FOR OUTPUT BUFFER FREE INTERUPT
URZAPD==1B24		;PORT ZAPPED (FOR USER INFO ONLY)
PHONON==1B25		;TELEPHONE CONNECTION ESTABLISHED
IGCHKS==1B26		;IGNORE CHECKSUM ERRORS (SET BY USER)


;FOR DDT ON PDP10-620 MESSAGES			*******741360,,000017$2M*************
EXTERN RMTDDP	;INDEXED BY PORT, RH POINTS TO DDB FOR THIS PORT, LH AS DEFINED BELOW

IFNCPU(KI),<PRINTX %Warning: RMTSER supported on KI only>
;BIT DEFINITIONS IN RMTDDP
WR620==1B1		;WRITE IS IN PROGRESS TO 620
RD620==1B2		;READ IS IN PROGRESS FROM 620
FLINB==1B3		;620 HAS FULL BUFFER TO BE READ
FROUTB==1B4		;620 HAS FREE OUTPUT BUFFER
WRRMT==1B5		;WRITE IN PROGRESS FROM 620 TO REMOTE
FLMNIB==1B6		;MONITOR BUFFER IS FULL IN INPUT MODE
FLMNOB==1B7		;MONITOR BUFFER IS FULL IN OUTPUT MODE
CLSNPG==1B9		;CLOSE UUO IS IN PROGRESS FOR THIS PORT
RDRMT==1B10		;READ IN PROGRESS FROM REMOTE TO 620
LASTWR==1B11		;CURRENTLY IN WRITE MODE
LASTRD==1B12		;CURRENTLY IN READ MODE
GOIDLE==1B14		;620 GOING IDLE BUT NOT THERE YET
WTIDLE==1B15		;INPUT REQUEST CAME IN WHILE WE WERE GOING IDLE
EOTGOT==1B16		;RECEIVED ETX OR EOT AND HAVE NOT YET SET IOEND

RMTDDB:
PHASE 0
DEVNAM:!	0
DEVCHR:!	BUFSIZ+1
DEVIOS:!	0
DEVSER:!		RMTDSP
DEVMOD:!	XWD DVRMT!DVIN!DVOUT,ASSCON!1B<^D35-I>
DEVLOG:!	0
DEVBUF:!	0
DEVIAD:!0
DEVOAD:!0
DEVCLS:!	XWD 200000,0	;CLASS
DEVSTS:!	0
DDBBLK::!	0		;BACKWARD LINK TO PRECEDING DDB
RMTBUF:!	0		;ADDRESS OF MONITOR BUFFER FOR THIS PORT
INTWRD==DEVINT
RMTPAS:!	0		;USER ADDRESS OF PASSWORD
DEVINT:	0		;INTERRUPT WORD
RMTCTR:!	0		;WORD COUNTER - ALSO USED BY DDT620 TO STORE 620 WORD CONTENTS
DEPHASE
SIZDDB==.-RMTDDB		;SIZE OF DDB


;Q'S AND BUFFERS
EXTERN QFRMST,QFRMND,QTOST,QTOND  ;START & END POINTS OF THE 2 BUFFERS TO & FROM 620
QTO:	QTOST		;POINTER TO DEPOSIT SOMETHING IN THE TO BUFER
QFRM:	QFRMST		;POINTER TO REMOVE SOMETHING FROM THE FROM BUFFER
EXTERN QPRTST	;Q OF JOBS WAITING FOR PORTS TO BE OPENED
EXTERN QPRTND
QPP:	-1		;POINTER TO PUT PORT ON Q
QPJ:	-1		;POINTER TO PUT JOB ON Q

;MISCELLANEOUS
EXTERN NUMPRT,MNUMPT		;+-NUMBER OF PORTS
EXTERN	CPOPJ1,PUNIT,PJOBN,PDVCNT,CPOPJ,JBTAWQ,JBTABT,LIVWRD
CHRLIM==^D400		;NUMBER OF 8-BIT CHARACTERS IN A MONITOR BUFFER
BUFSIZ==<CHRLIM+3>/4	;NUMBER OF WORDS IN A MONITOR BUFFER
PRTCNT:	0		;NUMBER OF OPEN PORTS
PRQCNT:	0		;NUMBER OF WAITING PORT REQUESTS
WAT620==^D10	;WAIT 10 SECONDS MAX FOR 620 TO SAY HELLO
RMTALV:	0		;-1==>620 ALIVE, 0==>620 JUST WENT DEAD,POSITIVE==>620 KNOWN DEAD
DWNFLG:	0		;NON-ZERO IF 620 RESYNC BUT OLD PORT REQUESTS NOT CLEARED UP
CRSNUM:	0		;NUMBER OF CRASHES
RCV620:	0		;<0 IF EXPECTING RCVDDT ELSE ANSWER
D620JB:	0		;JOB WHICH HAS DDT620 RESOURCE
CHKTIM:	0		;TIME BY WHICH 620 MUST HAVE SENT HIPDP
SAVT1:	0		;SAVE RETURN ADDRESS FOR CH2 CODE
CH2TEL:	0		;WHAT TO TELL IVWRD AT CH2 LEVEL
CH2TIM:	0		;WHAT TO RESET CHKTIM TO AT CH2 LEVEL
CH2UP:	0		;NON-0 IF CH2 HAS SEEN HIPDP
CRSRMT:	0		;LOC OF CALL TO SIK620
CRST1:	0		;SAVE PROBABLE MSG ON CALL TO SIK620
CRSF:	0		;SAVE PROBABLE RMTDDP ON CALL TO SIK620
CRSTIM:	0		;<TIME OF CALL TO SIK620>+15 SECONDS
			;USED TO MAKE SURE WE STAY DOWN LONG ENOUGH FOR 620 TO REINITIALIZE
STSDEV:	POINT 4,DEVSTS(F),35		;RIGHT MOST 4 BITS IN DEVSTS, USED BY CKRC12
SV620C:	0		;SAVE OF MSG #6 FROM 620 FOR SYSTEM PROGRAMMER
			;TO USE TO FIGURE  WHY 620 CRASHED
OLDTIM:	0		;USED FOR ACCOUNTING

SYN PUSHJ,PPUSHJ	;PUSHJ TO A SUBROUTINE THAT WILL DO A POP FOLLOWED BY A POPJ.
			;THE IDEA BEING THAT WE WANT TO DO A
			;PJRST BUT WE ALSO WANT TO SAVE THE ADDRESS OF THE CALL

ETB==27		;END OF BLOCK
US==37		;UNIT SEPARATOR
ETX==3		;END OF TEXT
EM==31		;END OF MEDIA
SPACE==40
LF==12		;LINE FEED
CR==15
HIPDP==12345B15		;HELLO MSG FROM 620
HLODER==54321B15		;HELLO MSG TO 620 FROM PDP10


;INTERRUPT CONDITIONS AND ASSIGNED CHANNELS
;THESE WILL GO AWAY WHEN GENERAL DEVICE INTERUPTS HAPPEN
;MESSAGE TYPES & FORMATS
COMMENT!
FORMAT FOR MESSAGES
BITS	NAME		DESCRIPTION
0-3	MSGTYP		TYPE OF MESSAGE
4			USED ONLY BY CRERMT TO FORCE PORT SELECTION
5-7	PRTFLD		PORT NUMBER
8	NOCHK		IF ON, IGNORE CHECKSUMS
9	WRTBIT		IF ON, GO TO WRITE MODE, ELSE GO TO READ MODE
			(ONLY USED FOR SENDING MSGS #1,2 & 5
10-31	ADRFLD		ADDRESS IF RELEVENT
!

MSGTYP:	POINT 4,T1,3
PRTFLD:	POINT 3,T1,7
NOCHK==1B8		;IN MSG TO 620, IGNORE CHECKSUMS
WRTBIT==1B9	;BIT TO TELL 62O TO GO TO WRITE MODE
ADRFLD:	POINT 22,T1,31

;FOR MESSAGES FROM PDP10 TO 620
GTPTCD=1B3		;GET PORT
SNADCD=2B3		;HERE'S ADDRESS FOR OUTPUT BUFFER
RCADCD=3B3		;HERE'S ADDRESS OF INPUT BUFFER
IDLECD=4B3		;FORCE THIS PORT TO IDLE
STMDCD=5B3		;SET MODE FOR THIS PORT
SUICD=6B3		;CLOSE ALL PORTS AND CRASH
STATCD=7B3		;SEND STATE OF THIS PORT
ZAPCD=10B3		;ZAP THIS PORT
RDLCCD==11B3		;READ THIS LOCATION



;FOR MESSAGES FROM 620 TO PDP10
;ALSO DEFINED IN DISPATCH TABLE FOR CKRMT TO GUARANTEE CONSISTENCY
TYPPRT==1			;HERE'S PORT
TYPBOU==2			;NEED BUFFER ADDR FOR OUTPUT
TYPFOU==3			;FINISHED COPYING TO 620
TYPBIN==4			;NEED BUFFER ADDR FOR INPUT
TYPFIN==5			;FINISHED COPYING TO PDP10
			;BIT 9 ON SAYS ETX IS LAST CHAR
TYPCRS==6			;620 IS CRASHING. 620 ADDR OF CRASH IN BITS 16-31
TYPSTS==7			;HERE'S STATUS
TYPHNG==10			;PHONE HANGUP
TYPETX==11			;FINISHED COPYING TO REMOTE AND SAW ETX
TYPIDL==12			;DEPENDS ON CONTENTS OF BITS 12-15
;		1==>PARITY ERROR DETECTED BY 620 ON READING PDP10
;		2==>FATAL CHECKSUM ERROR
;		3==>PORT HAS GONE TO IDLE
;		4==>NO TERMINATING CHAR IN OUTPUT BUFFER
TYPRST==13			;620 IS RESTARTING AND IS INITIALIZED
			;SHOULD ONLY GET THIS WHEN WE KNOW IT HAS ALREADY CRASHED
TYPDDT==14			;HERE ARE CONTENTS OF REQUESTED LOCATION
VOWS:	ASCII /AEIOU/



;ERROR CODES FOR UUOS   -RETURNED IN CALLI AC
NOPORT==1		;PORT NOT AVAILABLE OR DOESN'T BELONG TO THIS JOB
NOROOM==2		;NO ROOM FOR BUFFER AND/OR DDB
NO620==3		;REMOTE 620 IS DOWN
BDMTCH==4		;VALRMT - PASSWORD DOESN'T MATCH
NXCOND==5		;INTRMT - NON-EXISTANT CONDITION
NXCHAN==6		;INTRMT - NON-EXISTANT CHANNEL
NOINT==7		;INTRMT - INTADR UUO NOT CALLED
NOLIC==10		;DDT620 - NO RC LICENSE
NOADR==11		;DDT620 - BAD ADDRESS
COMMENT !

THE FOLLOWING IS A DESCRIPTION OF THE WAY IN WHICH RMTSER WORKS.

FIRST A COMMENT ON THE BITS IN THE LEFT HALF OF RMTDDP. THESE BITS
DETERMINE THE STATE OF COMUNICATION WITH THE 620. THE EXPLANATION
GIVEN WITH THEIR DEFINITIONS IS APPROXIMATELY ACURATE BUT THEIR
REAL FUNCTION CAN ONLY BE DEFERMINED FROM THE STATE TABLE BELOW.
FOR EXAMPLE, THE BIT WRRMT DOES NOT REALLY MEAN A WRITE IN PROGRESS
TO THE REMOTE BUT RATHER THAT A REQUEST FOR OUTPUT BUFFER
ADDRESS IS EXPECTED.

THE STATE TABLE BELOW IS DEVELOPED BY STARTING WITH THE TWO STATES
MARKED WITH *'S. THESE ARE THE STATES A PORT IS PLACED IN WHEN
IT IS ESTABLISHED EITHER FOR OUTPUT OR INPUT.
ALL POSSIBLE EVENTS ARE THEN CONSIDERED FOR EACH STATE AND THE
ACTION TO TAKE FOR THIS EVENT IN THIS STATE IS DETERMINED.
THIS GIVES RISE TO NEW STATES UNTIL ALL ACTIONS AND STATES
ARE DEFINED.

THE EVENTS ARE DEFINED BELOW

EVENT A
	RECIEVE MESSAGE TYPE 2, OUTPUT BUFFER ADDRESS REQUEST

EVENT B
	RECIEVE MESSAGE TYPE 3, FINISHED COPYING BUFFER TO 620

EVENT C
	RECIEVE MESSAGE TYPE 4, INPUT BUFFER ADDRESS REQUEST

EVENT D
	RECIEVE MESSAGE TYPE 5, FINISHED COPY TO 10. NO ETX BIT

EVENT E
	RECIEVE MESSAGE TYPE 5, FINISHED COPY TO 10. ETX BIT ON

EVENT F
	RECIEVE MESSAGE TYPE 11, FINISHED COPY TO REMOTE, ETX SEEN

EVENT G
	RECIEVE MESSAGE TYPE 12, 620 HAS GONE IDLE.

EVENT H
	OUTPUT UUO

EVENT I
	INPUT UUO

EVENT J
	IDLRMT UUO

MESSAGE TYPE 7 (STATUS) IS ASYNCHRONOUS. MESSAGE TYPE 10 (PHONE
HANGUP) IS TREATED SEPERATELY LATER. MESSAGE TYPE 14 (DDT) IS
A SPECIAL CASE AND DOES NOT CHANGE THE STATE. THE 620 CRASHING,
THE ZAPRMT UUO BEING DONE, AND RELEA6 CALLING RELZAP ARE ALL
TREATED AS SPECIAL CASES SINCE THEY ARE ALMOST STATE INDEPENDENT.
THE CREATION OF A PORT IS ALSO TREATED AS A SPECIAL CASE.
THE STATES FOR THE 620 PDPMMUNICATION ARE DEFINED BY THE
BITS WHICH ARE ON IN RMTDDP. THE STATES WITH *'S ARE INITIAL
STATES FROM THE CRERMT UUO.

STATE 1		FLMNOB  WRRMT  LASTWR  **************

STATE 2		FLMNOB  LASTWR  WR620

STATE 3		NO BITS ON (620 IS IDLE)

STATE 4		WRRMT LASTWR

STATE 5		LASTWR  FROUTB

STATE 6		FLMNOB GOIDLE

STATE 7		GOIDLE

STATE 8		RDRMT LASTRD  **************

STATE 9		RD620  LASTRD

STATE 10	RDRMT  LASTRD  FLMNIB

STATE 11	LASTRD  FLMNIB  FLINB

STATE 12	GOIDLE  EOTGOT  FLMNIB

STATE 13	GOIDLE  WTIDLE

STATE 14	EOTGOT  FLMNIB

STATE 15	GOIDLE  WR620

STATE 16	GOIDLE  RD620

STATE 17	GOIDLE  WR620  WTIDLE

STATE 18	GOIDLE  RD620  WTIDLE

STATE 19	GOIDLE  WRRMT

STATE 20	GOIDLE  RDRMT

STATE 21	GOIDLE  WRRMT  FLMNOB

STATE 22	GOIDLE  WRRMT  WTIDLE

STATE 23	GOIDLE  RDRMT  FLMNOB

STATE 24	GOIDLE  RDRMT  WTIDLE
THE FOLLOWING IS THE STATE TRANSITION DIAGRAM. AN S INDICATES
THAT THIS MESSAGE IS NOT LEGAL AT THIS POINT AND THE 620 SHOULD
BE CONSIDERED TO HAVE CRASHED (CALL SIK620). A NUMBER
INDICATES THE ACTION TO TAKE FROM A TABLE OF ACTIONS FOLLOWING
THE STATE TABLE


			EVENT
STATE	A   B   C   D   E   F   G   H   I   J

1	1   S   S   S   S   2   3   4   5   6
2	S   7   S   S   S   S   S   4   5   8
3	S   S   S   S   S   S   9   10  11  9
4	12  S   S   S   S   13  3   14  5   6
5	S   S   S   S   S   S   3   15  5   16
6	S   S   S   S   S   S   17  4   5   32
7	S   S   S   S   S   S   18  38  19  9
8	S   S   20  S   S   S   21  22  4   23
9	S   S   S   24  25  S   S   22  4   26
10	S   S   27  S   S   S   28  22  29  23
11	S   S   S   S   S   S   28  22  30  16
12	S   S   S   S   S   S   28  22  31  32
13	S   S   S   S   S   S   33  22  4   32
14	S   S   S   S   S   S   S   22  34  18
15	S   35  S   S   S   S   36  4   37  9
16	S   S   S   35  35  S   36  4   39  9
17	S   40  S   S   S   S   33  22  4   41
18	S   S   S   40  40  S   33  22  4   42
19	32  S   S   S   S   32  18  43  44  9
20	S   S   32  S   S   S   18  45  46  9
21	2   S   S   S   S   2   17  4   5   47
22	40  S   S   S   S   40  33  22  4   47
23	S   S   2   S   S   S   17  4   5   48
24	S   S   40  S   S   S   33  22  4   48
THE FOLLOWING ARE THE ACTIONS TO BE TAKEN IN THE ABOVE CASES

1	SEND SNADCD, SET PHONON, GO TO STATE 2

2	GO TO STATE 6

3	SET IODERR AND IODEND,
	TAKE OUTPUT INTERUPT IF ENABLED, WAKE JOB,
	GO TO STATE 3

4	TAKE I/O WAIT INTERUPT OR GO INTO I/O WAIT

5	SET IOEND AND IOIMPM

6	SEND IDLECD, GO TO STATE 19

7	IF NOT IN CLOSE (TAKE OUTPUT INTERUPT IF ENABLED, WAKE JOB)
	GO TO STATE 4

8	SEND IDLECD, GO TO STATE 15

9	DO NOTHING

10	FILL BUFFER WITH USERS DATA, SEND STMDCD WRITE,
	GO TO STATE 1

11	SEND STMDCD READ, TAKE I/O WAIT INTERUPT OR
	GO INTO I/O WAIT, GO TO STATE 8

12	IF IN CLOSE WAKE JOB, GO TO STATE 5

13	IF IN CLOSE WAKE JOB, GO TO STATE 7

14	FILL BUFFER WITH USERS DATA, GO TO STATE 1

15	FILL BUFFER WITH USERS DATA, SEND SNADCD, GO TO STATE 2

16	SEND IDLECD, GO TO STATE 7

17	SEND STMDCD WRITE, GO TO STATE 1

18	GO TO STATE 3

19	TAKE I/O WAIT INTERUPT OR GO INTO I/O WAIT, GO TO STATE 13

20	SEND RCADCD, SET PHONON, GO TO STATE 9

21	SET IOEND, TAKE INPUT INTERUPT, WAKE JOB, GO TO STATE 3

22	SET IOIMPM
23	SEND IDLECD, GO TO STATE 20

24	WAKE JOB, TAKE INPUT INTERUPT, GO TO STATE 10

25	WAKE JOB, TAKE INPUT INTERUPT, GO TO STATE 12

26	SEND IDLECD, GO TO STATE 16

27	GO TO STATE 11

28	GO TO STATE 14

29	TRANSFER BUFFER TO USER, GO TO STATE 8

30	TRANSFER BUFFER TO USER, SEND RCADCD, GO TO STATE 9

31	TRANSFER BUFFER TO USER, SET IOEND, GO TO STATE 7

32	GO TO STATE 7

33	SEND STMDCD READ, GO TO STATE 8

34	TRANSFER BUFFER TO USER, SET IOEND, GO TO STATE 3

35	TAKE OUTPUT INTERUPT, WAKE JOB, GO TO STATE 7

36	TAKE OUTPUT INTERUPT, WAKE JOB, GO TO STATE 3

37	TAKE I/O WAIT INTERUPT OR GO INTO I/O WAIT, GO TO STATE 17

38	FILL BUFFER WITH USERS DATA, GO TO STATE 6

39	TAKE I/O WAIT INTERUPT OR GO INTO I/O WAIT, GO TO STATE 18

40	GO TO STATE 13

41	GO TO STATE 15

42	GO TO STATE 16

43	FILL BUFFER WITH USERS DATA, GO TO STATE 21

44	TAKE I/O WAIT INTERUPT OR GO INTO I/O WAIT, GO TO STATE 22

45	FILL BUFFER WITH USERS DATA, GO TO STATE 23

46	TAKE I/O WAIT INTERUPT OR GO INTO I/O WAIT, GO TO STATE 24

47	GO TO STATE 19

48	GO TO STATE 20
THE FOLLOWING IS A SUMMARY OF THE ABOVE, REORIENTED TO BE ON A
WHAT HAPPENS WHEN EVENT X HAPPENS BASIS. IN ADDITION, ALL STATE
CHANGES ARE INDICATED AS CHAGES TO BITS RATHER THAN A CHANGE TO
A PARTICUALR STATE.

NOTES ON CODING CONVENTIONS:
	X<==N MEANS X REPLACED BY N BUT HAS VALUE OF OLD VALUE OF X
	[X;Y;Z] FOLLOWING A THEN OR ELSE MEANS DO X THEN Y THEN Z
	 IF THE APPROPRIATE CONDITION IS TRUE
	SIK620 IS A ROUTINE CALLED WHEN AN ILLEGAL MESSAGE IS
	 RECIEVED FROM THE 620. DETAINS ARE GIVEN LATER.


EVENT A   RECIEVE MESSAGE 2

IF NOT WRRMT<==0 THEN [SKIK620; DONE]
IF GOIDLE THEN DONE
IF FLMNOB THEN [SNADCD; PHONON_WR620_1; DONE]
FROUTB_1
IF CLOSE THEN SETIOD


EVENT B   RECIEVE MESSAGE 3

IF NOT WR620<==0 THEN [SIK620; DONE]
IF WTIDLE THEN DONE
IF FLMNOB<==0 THEN [WRRMT_1; IF CLOSE THEN DONE]
OUTPUT INTERUPT IF ENABLED
SETIOD



EVENT C  RECIEVE MESSAGE 4

IF NOT RDRMT<==0 THEN [SIK620; DONE]
IF GOIDLE THEN DONE
IF FLMNIB THEN [FLINB_1; DONE]
RD620_PHONON_1
RCADCD
EVENT D AND EVENT E   RECIEVE MESSAGE 5

IF NOT RD620<==0 THEN [SIK620; DONE]
IF WTIDLE THEN DONE
IF GOIDLE THEN [OUTPUT INTERUPT; SETIOD; DONE]
INPUT AVAILABLE INTERUPT
SETIOD
FLMNIB_1
IF ETX BIT THEN [GOIDLE_EOTGOT_1; LASTRD_0] ELSE RDRMT_1



EVENT F  RECIEVE MESSAGE 11

IF NOT WRRMT<==0 THEN [SIK620; DONE]
IF GOIDLE<==1 THEN DONE
LASTWR_0
IF NOT FLMNOB AND CLOSE THEN SETIOD



EVENT G  RECIEVE MESSAGE 12 (IDLE SUBCODE)

IF GOIDLE<==0 THEN [
	IF WTIDLE<==0 THEN [
		STMDCD READ; WR620_RD620_WRRMT_0; RDRMT_LASTRD_1
		DONE]
	IF FLMNOB THEN [STMDCD WRITE; RDRMT_0; WRRMT_LASTWR_1; DONE]
	IF WR620<==0 OR RD620<==0 THEN [
		OUTPUT FREE INTERUPT; SETIOD; DONE]
	WRRMT_RDRMT_0; DONE]
IF WR620 OR RD620 OR EOTGOT THEN [SIK620; DONE]
IF LASTWR<==0 THEN [IODERR_IODEND_1; OUTPUT FREE
	INTERUPT; WAKE JOB; FROUTB_FLMNOB_WRRMT_0; DONE]
IF LASTRD<==0 THEN [IF FLMNIB THEN [RDRMT_FLINB_0; EOTGOT_1;
		DONE]
	INPUT AVAILABLE INTERUPT; SETIOD; IOEND_1; RDRMT_0; DONE]



EVENT H  OUTPUT UUO

IF RMTZAP THEN [IODTER_1; EXIT WITH ADVBFE]
IF NOT IOSVAL THEN [ZAPCD; IOIMPM_1; EXIT WITH ADVBFE]
IF LASTRD OR WTIDLE OR FLMNIB THEN [IOIMPM_1; EXIT WITH ADVBFE]
IF FLMNOB OR RD620 OR WR620 THEN [I/O WAIT INTERUPT OR
	GO INTO I/O WAIT; IF IODEND THEN EXIT WITH ADVBFE;
	RESTART UUO]
FILL BUFFER WITH USERS DATA
FLMNOB_1
IF GOIDLE THEN EXIT WITH ADVBFE
IF FROUTB<==0 THEN [SNADCD; WR620_1; EXIT WITH ADVBFE]
IF NOT LASTWR<==1 THEN [STMDCD WRITE; WRRMT_1; EXIT WITH ADVBFE]
EXIT WITH ADVBFE
EVENT I   INPUT UUO

IF RMTZAP THEN [IOEND_IODTER_1; EXIT]
IF FLMNOB OR LASTWR THEN [IOIMPM_IOEND_1; EXIT]
IF FLMNIB<==0 THEN [IF NOT IOSVAL THEN [COMPARE PASSWORD WITH
		CONTENTS OF BUFFER; IF PASSWORDS= THEN IOSVAL_1
		ELSE [ZAPCD; IOIMPM_IOEND_1; EXIT]]
	COPY BUFFER TO USER; ADVBFF;
	IF EOTGOT<==0 THEN [IOEND_1; EXIT]
	IF FLINB<==0 THEN [RCADCD; RD620_1]
	EXIT]
IF LASTRD THEN GO TO A
IF NOT GOIDLE THEN [STMDCD READ; RDRMT_LASTRD_1; GO TO A]
WTIDLE_1
A:
I/O WAIT INTERUPT OR GO INTO I/O WAIT
IF IOEND THEN EXIT
RESTART UUO



EVENT J    IDLRMT UUO

IF RMTZAP THEN DONE
IF GOIDLE<==1 THEN [WTIDLE_FLMNOB_EOTGOT_FLMNIB_0; EXIT]
IF LASTWR<==0 OR LASTRD<==0 THEN [IDLECD;
	FLMNOB_FROUTB_FLMNIB_FLINB_0; EXIT]
EOTGOT_FLMNIB_GOIDLE_0
REQUESTS FOR PORT CREATION ARE HANDLED THROUGH A QUE MECHANISM.
WHEN A PORT IS TO BE CREATED BY CRERMT, THE DDB AND BUFFER ARE
CREATED AND IF OPENING FOR OUTPUT, THE VALIDATION INFORMATION
IS PLACED IN THE BUFFER. THE PORT REQUEST IS THEN SENT TO THE
620 AND AN ENTRY PLACED ON THE PORT REQUEST QUE. THIS ENTRY IS
EXACTLY WHAT IS TO BE PLACED IN RMTDDP FOR THAT PORT. THAT IS,
THE RIGHT HALF IS THE DDB ADDRESS AND THE LEFT HALF HAS
RDRMT AND LASTRD ON FOR INPUT OPEN AND WRRMT, FLMNOB, AND LASTWR
ON FOR OUTPUT OPEN. THE JOB IS THEN PUT INTO MONITOR WAIT.
WHEN THE 620 SEND A PORT ESTABLISHED MESSAGE, THE QUE ENTRY IS
REPLACED BY THE PORT NUMBER IN THE LEFT HALF AND THE JOB
NUMBER IN THE RIGHT HALF, THE OLD QUE ENTRY IS PLACED IN
RMTDDP AND THE JOB IS TAKEN OFF THE MO QUE. SINCE THE DDB HAS
BEEN CREATED AND LINKED, IF A SWAP READ ERROR OCCURS, A CALL
WILL EVENTUALLY BE GENERATED TO RELZAP (BY RELEA6). SINCE
DEVNAM AT THIS POINT WILL BE 0, RELZAP CAN USE THIS AS A FLAG
SO THAT IT CAN ZERO THE REQUEST ON THE PORT QUE AS WOULD HAVE
HAPPENED AT THE END OF CRERMT IF THE SWAP ERROR HAD NOT OCCURED.
IF THE 620 CRASHES, A SPECIAL CODE IS PUT IN FOR ALL PORT
REQUESTS AND THE 620 DOES NOT RESTART UNTIL THE PORT REQUEST
QUE HAS BEEN CLEARED.

CRERMT UUO

IF RMTALV>=0 THEN RETURN ERROR NO620
IF PORT SPECIFIED AND PORT BUSY THEN RETURN ERROR NOPORT
IF ALL PORTS IN USE, RETURN ERROR NOPORT
GET DDB AND BUFFER, LINK IN DDB WITH THIS JOB, ASSCON ON, AND
	0 IN DEVNAM. IF NO ROOM FOR DDB AND BUFFER, RETURN
	ERROR NOROOM
INC PRTCNT
INC PRQCNT
IF OPEN FOR OUTPUT [PUT PASSWORD INTO BUFFER; SET PORT REQ
	TO DDB ADDRESS AND WRRMT, FLMNOB, LASTWR]
	ELSE SET PORT REQ TO DDB ADDRESS AND RDRMT LASTRD
GTPTCD
GO INTO MO WAIT
USE JOB NUMBER TO FIND RESPONSE
IF NO ENTRY ON REQUEST QUE THEN RETURN ERROR NOPORT
ZERO ENTRY ON PORT REQUEST QUE
IF RESPONSE>=400000 THEN [RETURN DDB AND BUFFER AND UNLINK DDB;
	DEC PRTCNT; IF RESPONSE=777776 THEN RETURN ERROR NO620
	ELSE RETURN ERROR NOPORT]
SET DEVNAM IN DDB TO REFLECT PORT NUMBER
SET DVNZP IF REQUEST BY USER
IF INPUT OPEN SAVE PASSWORD ADDRESS IN RMTPAS
RETURN PORT NUMBER TO USER
THE FOLLOWING IS THE PROCESS FOLLOWED WHEN THE 620 SENDS A
HANGUP MESSAGE

LEFT HALF OF DEVNAM_0
IF DEVNAM=0 THEN FIND AND REMOVE ENTRY ON PORT REQUEST QUE
IF RMTBUF#0 THEN [RETURN BUFFER; RMTBUF_0]
IODERR_URZAPD_RMTZAP_1
PHONON_0
RMTDDP_0
DEC PRTCNT
WAKE JOB IF IN I/O WAIT
TAKE PORT ZAPPED TRAP IF ENABLED
CALL RELEAS6 WITH ASSCON



THE FOLLOWING CODE IS EXECUTED IF RELEA6 CALLS RELZAP (I.E.
ASSCON AND ASSPRG ARE NOW BOTH 0)

LEFT HALF DEVNAM_0
PJOBN_0
IF NOT RMTZAP THEN IF DEVNAM=0 THEN [ FIND AND REMOVE ENTRY
			ON PORT QUE; IF NO ENTRY OR RESPONSE <=
			400000 THEN GO TO ZAPRMT UUO ELSE [
			RETURN DDB; DONE]]
		ELSE GO TO ZAPRMT UUO
IF RH(RMTDDP(PUNIT))=RH(F) THEN DONE
IF RMTBUF#0 THEN RETURN BUFFER
UNLINK AND RETURN DDB

THE FOLLOWING CODE IS EXECUTED BY THE ZAPRMT UUO

IF RMTZAP THEN DONE
RMTZAP_1
SEND ZAPCD TO 620  (PHONE ZAP FROM 620 WILL COMPLETE WORK)

THE FOLLOWING HAPPENS ON AN OUTPUT CLOSE

IF RMTZAP THEN DONE
CALL OUTPUT UUO CODE
IF RMTZAP THEN DONE
IF IODEND OR IOIMPM THEN GO TO ILDRMT UUO
IF FLMNOB OR WRRMT THE [CLSNPG_1; GO INTO I/O WAIT]
IF RMTZAP THEN DONE
GO TO IDLRMT UUO

ON THE RECIEPT OF MESSAGE TYPE 1, HERE IS A PORT

IF DEC PRQCNT<0 THEN [SIK620; DONE]
IF PORT=17 THEN PORT_-1 ELSE IF RMTDDP(PORT)#0 THEN
	[SIK620; DONE]
GIVE PORT TO FIRST UNSATISFIED PORT REQUEST AND WAKE JOB
IF PORT>=0 THEN RMTDDP(PORT)_PORT REQUEST
THE FOLLOWING IS THE 620 UP-DOWN CODE AND IS EXECUTED EVERY
CLOCK TICK

IF RMTALV<0 THEN [IF CH2TEL=0 THEN SIK620 ELSE PROCESS INPUT QUE;
		DONE]
IF RMTALV=0 THEN [IF TIME<=CRSTIM THEN DONE;
	CLEAR ALL QUE'S EXCEPT PORT REQUEST; CH2UP_0
	CHKTIM_377777,,777777; CH2TEL_HLODER
	RMTALV_1; DWNFLG_0; DONE]
IF DWNFLG=0 THEN [IF CH2TEL=0 THEN [C: RMTALV_0; CRSTIM_TIME+30 SEC;
		FILL OUTPUT QUE WITH SUICD; DONE]
	IF CH2UP=0 THEN DONE
	IF NO MSG FROM 620 THEN DONE
	IF FIRST MSG IN QUE FROM 620#13 (RESTART) THEN GO TO C
	FOR EACH PORT IF RMTDDP#0 THEN [TREAT AS BUFFER ADDRESS
		AND RETURN BUFFER; RMTDDP_0]
	DWNFLG_-1]
IF PRTCNT#0 THEN DONE
RMTALV_-1


THE FOLLOWING CODE TAKES PLACE AT ACTUAL CLOCK INTERUPT (CHANEL 2)
LEVEL

IF CH2TEL=0 THEN DONE
OLD LIVWRD_LIVWRD<==CH2TEL
IF OLD LIVWRD=HIPDP THEN [CH2UP_-1; CHKTIM_WAT620 SEC; DONE]
IF OLD LIVWRD=HLODER THEN IF DEC CHKTIM>0 THEN DONE
CH2TEL_0
THIS IS A DESCRIPTION OF SIK620

FOR EACH PORT IF RMTDDP#0 THEN IF RD620 OR WR620 THEN [
		SAVE RMTBUF; RMTBUF_0; CALL 620 PHONE HANGUP CODE;
		RESTORE RMTBUF TO RMTDDP]
	ELSE CALL 620 HANGUP CODE
FOR EACH REQ IN PORT REQ QUE [SET RESPONSE TO 777776;
	WAKE JOB FROM MO QUE]
RMTALV_0
CH2TEL_0
CRSTIM_TIME+30 SEC
SET ALL CELLS OF OUTPUT QUE TO SUICD


HERE IS THE CODE EXECUTED FOR THE DDT620 UUO

JBTABT(J)_DDTERR
IF D620JB#0 THEN [T1_D620JB
	WHILE RH(QUEPCB(T1))#0 THEN T1_RH(QUEPCB(T1))
	LH (QUEPCB(J))_T1; RH(QUEPCB(T1))_J; MO WAIT]
D620JB_J
IF RCV620<0 THEN MO WAIT
RCV620_-1
SEND RDLCCD
IF NO QTO620 ERROR THEN MO WAIT ELSE RCV620_NO620+1B1
JBTABT(J)_0
IF QUEPCB(J)#0 THEN [T1_RH(QUEPCB(J)); QUEPCB(J)_0
	LH (QUEPCB(T1))_0; D620JB_T1; WAKE JOB T1] ELSE D620JB_0
RETURN RCV620

CODE FOR DDTERR

IF J#D620JB THEN [T1_RH(QUEPCB(J)); T2_LH(QUEPCB(J))
	RH (QUEPCB(T2))_T1; IF T1#0 THEN LH(QUEPCB(T1))_T2]
ELSE [T1_RH(QUEPCB(J)); QUEPCB(J)_0; LH (QUEPCB(T1))_0
	D620JB_T1; WAKE JOB T1]


WHEN THE ANSWER TO RDLCCD IS RECIEVED

IF RCV620>=0 THEN [SIK620; DONE]
RCV620_620 RESPONSE
IF D620JB#0 THEN WAKE JOB WHOSE NUMBER IS IN D620JB

IN SIK620

IF RCV620<0 THEN [RCV620_NO620+1B1; IF D620JB#0 THEN WAKE JOB]
!
INTERN RMTINI
;DISPATCH TABLE

RMTDSP:	PHASE 0
DDXZ:	DSPSIZ
DDINT:	JRST INTRMT
DBYT:	1000,,1000
DVSIZ:	MOVEI T1,SIZDDB
DINI:	JRST RMTINI
DHNG:	POPJ P,
DRL:	POPJ P,
DCL:	JRST RMTCLS
DOU:	JRST RMTOUT
DIN:	JRST RMTIN
DZAP:	JRST RELZAP
	DSPSIZ==.-1
	DEPHASE
SUBTTL RMTINI & RELZAP & RMTRSI
;CALLED AT SYSTEM INITIALIZATION TIME

RMTINI:	SETZM	RMTALV		;RMTALV=0
	MOVEI T1,ALRRMT
	MOVEM T1,ALR620		;SO ALARM IS SET IF NEVER COMES UP
	SETZM	CRSTIM
	SETZM	CRSRMT
	SETZM	PRTCNT		;PRTCNT=0
	MOVSI	T1,MNUMPT
	SETZM	RMTDDP(T1)
	AOBJN	T1,.-1
	MOVEI T1,WAT620
	IMUL T1,JFYSEC
	MOVEM T1,CH2TIM		;SET UP FOR RESET CHKTIM IN CH2
	SETOM QPP
	SETOM QPJ
;FALL INTO RMTIN1

;ROUTINE TO INITIALIZE STATE OF THE WORLD. CALLED BY RMTINI AT
;SYSTEM INITIALIZATION TIME AND BY CKRDWN
RMTIN1:	SETZM	QFRMST
	SETZM	QTOST
	MOVE	T1,[XWD	QFRMST,QFRMST+1]	;ZERO ALL Q'S AND INITIALIZE Q POINTERS
	HLRZM	T1,QFRM
	BLT	T1,QFRMND
	MOVE	T1,[XWD QTOST,QTOST+1]
	HLRZM	T1,QTO
	BLT	T1,QTOND
	SETZM PRQCNT
	POPJ	P,


;ROUTINE CALLED REOM RELEA6 WHEN ASSCON=ASSPRG=0

RELZAP:	MOVEI T1,0
	DPB T1,PJOBN
	LDB U,PUNIT
	HRRZS T1,DEVNAM(F)
	SETZM DEVLOG(F)	;NO MORE LOGICAL NAME
	SKIPGE DEVIOS(F)	;HAS DEVICE BEEN ZAPPED?
	JRST RELZ1		;YES
	JUMPN T1,ZAPRM1		;IF NAME NOT 0, SEND ZAPPER
	PUSHJ P,FPRTQJ		;NAME IS 0, REMOVE ENTRY ON PORT Q
	 JRST ZAPRM1		;NONE THERE, SEND ZAPPER
	JUMPL T2,RETDDB	;RESPONSE, MUST SEND ZAPPER
	HLRZ U,T2
	JRST ZAPRM1		;SET U TO PORT AND GO ZAP
RELZ1:	HRRZ T1,RMTDDP(U)
	CAIN T1,(F)		;IS RMTDDP STILL POINTED HERE
	POPJ P,	;YES, LEAVE DDB
	JRST RETDDB	;NO, RETURN DDB

RMTRSI:	SETZM INTWRD(F)
	POPJ P,

INTERNAL RMTRSI
SUBTTL	OUTPUT ROUTINES
;OUTPUT
	EXTERN WSYNC,ABTUUO,TSTKTP,ADVBFE,JBTRMC,JBTRMT,TAKTRJ
RMTOUT:	MOVE	J,JOB
	PUSH P,F	;SAVE F SO IT CAN HAVE RMTDDP IN IT
OUT0:	JUMPL S,OUTER2	;PORT IS ZAPPED, GIVE IODTER
	PUSHJ P,SETUNI	;SET UP U AND F
	TLNN S,(IOSVAL)	;IS PORT VALIDATED?
	JRST OUTER4	;NO, IOIMPM AND ZAP PORT
	TLNE F,(LASTRD!WTIDLE!FLMNIB)
	JRST OUTER1	;OUTPUT NO LEGAL IF DOING INPUT
	HRRZ T2,DEVOAD(F)
	XCTFU <SKIPN T2,1(T2)>	;GET COUNT
	JRST OUTFIN	;COUNT IS 0, IGNORE BUFFER
	CAILE T2,BUFSIZ
	JRST OUTER1	;BUFFER TOO LARGE
	MOVEM T2,RMTCTR(F)	;SAVE SIZE
	TLNN F,(FLMNOB!RD620!WR620)	;CAN WE FILL BUFFER?
	JRST OUT1	;YES, DO IT
	PUSHJ P,WATOUT	;CAN NOT FILL BUFFER, GO TO IOW
	TRNN S,IODEND	;WAS IT ERROR CONDITION?
	JRST OUT0	;NO, JUST TRY AGAIN
	JRST OUTFIN	;ALL DONE

;HERE TO TRANSFER THE USERS BUFFER TO THE MONITOR BUFFER

OUT1:	HRRZ	T1,RMTBUF(F)	;YES, TRANSFER BUFFER TO MONITOR AREA
	HRL	T1,DEVOAD(F)
	ADD	T1,[XWD 2,0]
	MOVE T2,RMTCTR(F)	;RESTORE COUNT
	IMULI	T2,4		
	ADDM	T2,JBTRMC(J)	;CHARGE FOR CHARACTERS (4 PER WORD)
	ADDM T2,JBTRMC
	MOVE	T2,RMTCTR(F)	;GET WORD COUNT AGAIN
	ADDI	T2,-1(T1)
	XCTFU	<BLT T1,(T2)>	;GET BUFFER DOWN TO MONITOR AREA
	MOVE	T1,RMTCTR(F)
	CAIL	T1,BUFSIZ
	JRST	OUT2
	MOVE	T1,[BYTE (8)ETB,ETB,ETB,ETB]
	MOVEM	T1,1(T2)	;MARK END OF BUFFER WITH ETB'S FOR 620
OUT2:	TLO F,(FLMNOB)	;MARK BUFFER FULL FOR OUTPUT
	TLNE F,(GOIDLE)	;WAITING FOR IDLE?
	JRST OUTFN2	;YES, ACTUAL TRANSFER WILL START LATER
	TLZE F,(FROUTB)	;HAS 620 REQUESTED BUFFER>
	JRST OUT3	;YES, SEND IT
	TLON F,(LASTWR)	;ARE WE ALREADY WRITING?
	JRST OUT4	;NO, NOT YET
OUTFN2:	MOVEM F,RMTDDP(U)	;SAVE STATE
OUTFIN:	PUSHJ P,ADVBFE	;ADVANCE BUFFER
	 JFCL		;DON'T CARE IF THERE IS ANOTHER
FPOPJ:	POP P,F
	POPJ P,

;HERE IF 620 HAS ALREADY REQUESTED BUFFER

OUT3:	TLO F,(WR620)
	MOVSI T1,(SNADCD)	;GET SET TO SEND IT ADDRESS
OUT3A:	DPB U,PRTFLD
	MOVE T2,RMTBUF(F)
	DPB T2,ADRFLD
	PUSHJ P,QTO620	;SEND MSG TO 620
	 JRST OUTFIN	;620 NOW DOWN, DO NOT RESET RMTDDP
	JRST OUTFN2

;HERE IF 620 IS IN IDLE STATE, MUST RESTART

OUT4:	TLO F,(WRRMT)
	MOVSI T1,(STMDCD!WRTBIT)
	JRST OUT3A	;SEND IT TO 620

OUTER4:	PUSHJ P,ZAPRM1	;SEND A ZAPPER
OUTER1:	TROA S,IOIMPM
OUTER2:	TRO S,IODTER
	IORB S,DEVIOS(F)	;JUST IN CASE ZAP SET BY QTO620
	JRST OUTFIN

;HERE ARE THE I/O WAIT ROUTINES FOR INPUT AND OUTPUT

WATIN:	TDZA T3,T3
WATOUT:	MOVSI T3,(IOSARM)	;OUTPUT WAIT MAY ARE FOR BUFFER FREE INTERUPT
	LDB T1,NWATRP
	PUSHJ P,TSTKTP
	 JRST	[IORM T3,DEVIOS(F)	;ARM IF TRAP TAKEN
		JRST ABTUUO]
	TRO S,IOACT
	MOVEM S,DEVIOS(F)
	PUSHJ P,WSYNC
	SKIPGE JBTAWQ(J)
	JRST ABTUUO	;WAIT ABORTED BY TRAP, EXIT
	POPJ P,
SUBTTL	INPUT UUO

EXTERN ADVBFF
RMTIN:	MOVE	J,JOB
	PUSH P,F
IN0:	JUMPL S,INERR2
	PUSHJ P,SETUNI
	TLNE F,(FLMNOB!LASTWR)
	JRST INERR1	;INPUT NOT LEGAL IN OUTPUT MODE
	TLZE F,(FLMNIB)	;BUFFER ALREADY FULL?
	JRST IN1	;YES
	TLNE F,(LASTRD)	;POSSIBLY IDLE
	JRST IN2	;CAN NOT BE, WAIT FOR BUFFER
	TLNN F,(GOIDLE)	;WAITING FOR IDLE?
	JRST IN3	;NO, HAVE TO RESTART IT
	TLO F,(WTIDLE)	;MARK TO GO TO INPUT WHEN IDLE
IN2:	MOVEM F,RMTDDP(U)
	PUSHJ P,WATIN
	TLNN S,IOEND
	JRST IN0		;RESTART IF NOT ERROR
	POP P,F
	POPJ P,		;DONE

;HERE IF 620 IS IDLE AND MUST BE RESTARTED

IN3:	TLO F,(RDRMT!LASTRD)
	MOVSI T1,(STMDCD)	;SET TO READ MODE
	DPB U,PRTFLD
	MOVE T2,RMTBUF(F)
	DPB T2,ADRFLD
	PUSHJ P,QTO620
	 JRST INERR2	;620 NOW DOWN, GETT OUT
	JRST IN2

;HERE WHEN THERE IS A FULL BUFFER

IN1:	TLNE S,(IOSVAL)	;VALIDATED YET?
	JRST INVAL	;YES, GIVE BUFFER TO USER
	MOVEI	T1,INZAP	;NO, COMPARE PASSWORD
	MOVEM	T1,JBTABT(J)	;ZAP PORT IF NXM HAPPENS
	SKIPN	T1,RMTPAS(F)
	JRST	INZAP		;ZAP IF PORT NOT VALID AND WAS OPENED FOR OUTPUT
	HRLI	T1,(POINT 7,0)	;T1 POINTS TO USER-SUPPLIED PASSWORD
	HRR	T2,RMTBUF(F)
	HRLI	T2,(POINT 8,0)	;T2 POINTS TO MONITOR BUFFER
	MOVNI	T4,^D80
	MOVEM	T4,RMTCTR(F)		;MAX OF 80 CHARS IN PASSWORD
INV1:	ILDB	T3,T2		;GET A CHAR FROM 620
	CAIE	T3,ETX
	CAIN	T3,EM
	JRST	INV2		;EM OR ETX TERMINATES
	CAIE	T3,ETB
	CAIN	T3,US
	JRST	INV2		;AS DOES ETB AND US
	XCTFU	<ILDB	T4,T1>		;GET CHAR FROM USER PASSWORD
	JUMPE	T4,BLANK	;IF IT'S A NULL, THEN REST OF 620 CHARS MUST BE SPACES
	CAIN	T4,CR
	JRST	BLANK
	CAME	T4,T3
	JRST	INZAP		;LOSE IF IT DOESN'T MATCH
	AOSL	RMTCTR(F)	;MATCHES
	JRST	INV3		;IF 80 CHARS HAVE BEEN CHECKED, DONE
	JRST	INV1		;ELSE GET NEXT CHAR

BLANK:	CAIE	T3,SPACE		;CURRENT CHAR MUST BE SPACE
	JRST	INZAP		;OR LOSE
BLANK1:	ILDB	T3,T2		;GET NEXT CHAR
	AOSLE	RMTCTR(F)
	JRST	INV3		;IF ALREADY CHECKED 80 CHARS, DONE
	CAIN	T3,SPACE
	JRST	BLANK1		;IF A SPACE, KEEP CHECKING
	CAIE	T3,ETX
	CAIN	T3,EM
	JRST	INV3		;ETX OR EM TERMINATES
	CAIE	T3,ETB
	CAIN	T3,US
	JRST	INV3
				;ELSE FALL INTO INZAP
INZAP:	SETZM	JBTABT(J)
	PUSHJ P,ZAPRM1	;ZAP HIS PORT
	JRST	INERR1		;ERROR RETURN

;REMOTE BUFFER TERMINATED
INV2:	XCTFU <ILDB	T4,T1>		;USER BUFFER MUST TERMINATE WITH CR OR NULL
	JUMPE	T4,INV3
	CAIN	T4,CR
	JRST	INV3
	JRST	INZAP



INV3:	TLO S,(IOSVAL)		;NOW VALIDATED
	MOVEM S,DEVIOS(F)
	SETZM	JBTABT(J)		;DON'T CARE ABOUT NXMS ANYMORE
INVAL:	HRLZ	T1,RMTBUF(F)	;TRANSFER BUFFER TO USER
	HRR	T1,DEVIAD(F)
	ADDI	T1,2
	HRRZ	T2,T1
	XCTTU	<BLT T1,BUFSIZ-1(T2)>
	MOVE	T2,DEVIAD(F)
	MOVEI	T1,BUFSIZ
	UMOVEM	T1,1(T2)	;SET WORD COUNT IN BUFFER
	PUSHJ	P,ADVBFF	;AND ADVANCE BUFFER
	JFCL
	MOVEI	T1,CHRLIM
	ADDM	T1,JBTRMC(J)	;KEEP COUNT OF CHARACTERS TRANSFERRED
	ADDM T1,JBTRMC
	TLZE F,(EOTGOT)
	JRST INEOT	;TIME TO GIVE USER EOT
	TLZE F,(FLINB)	;620 WANT A BUFFER
	JRST INRST	;YES
INFIN:	MOVEM F,RMTDDP(U)
	POP P,F
	POPJ P,

INEOT:	TLO S,IOEND
	MOVEM S,DEVIOS(F)
	JRST INFIN

INRST:	TLO F,(RD620)
	MOVSI T1,(RCADCD)
	DPB U,PRTFLD
	MOVE T2,RMTBUF(F)
	DPB T2,ADRFLD
	PUSHJ P,QTO620
	 JRST INERR3	;620 IS NOW DOWN
	JRST INFIN

INERR2:	TDOA S,[IOEND,,IODERR]
INERR1:	TDO	S,[IOEND,,IOIMPM]
	IORB	S,DEVIOS(F)
INERR3:	POP P,F
	POPJ	P,

;HERE TO SET UP U AND F GIVEN F A POINTER TO A DDB

SETUNI:	LDB U,PUNIT
	MOVE F,RMTDDP(U)	;F STILL POINTS TO DDB
	POPJ P,
SUBTTL	CLOSE UUO

EXTERN OUT
RMTCLS:	JUMPL S,CPOPJ	;ZAPPED
	PUSHJ P,OUT
	SKIPGE DEVIOS(F)
	POPJ P,		;ZAPPED NOW
	PUSH P,F
	PUSHJ P,SETUNI
	MOVE S,DEVIOS(F)
	TRNN S,IODEND!IOIMPM
	TLNN F,(FLMNOB!WRRMT)
	JRST IDLRM1	;JUST FORCE TO IDLE
	TLO F,(CLSNPG)
	MOVEM F,RMTDDP(U)
	PUSHJ P,WATOUT
	SKIPGE DEVIOS(F)
	PJRST FPOPJ	;ZAPED NOW
	PUSHJ P,SETUNI
	JRST IDLRM1	;AND GO FORCE TO IDLE
SUBTTL CRERMT UUO
;CRERMT UUO

	COMMENT !

CRERMT AC,0
	CREATE A PORT FOR A REMOTE PERIPHERAL
	AC BITS:
	   0       ON MEANS SELECT PORT FROM BITS 1-5, OFF MEANS GET ANY FREE PORT
	   1-2	   620 #
	   3-5     LINE NUMBER FOR THAT 620
			NOTE THAT THE 5 BITS TOGETHER GIVE THE TOTAL LINE NUMBER
			I.E. LINE 34 IS LINE 4 ON 620 #3
	   12-14   MODE. CURRENTLY ONLY MODE 0 IS ALLOWED AND THIS FIELD IS NOT USED.
			EVENTUALLY, MODE MIGHT BE USED TO GIVE COMPATIBILTIES OTHER THAN 2780
	   15-16   00==> OPEN FOR OUTPUT TO PRINTER
		   01==> OPEN FOR INPUT
		   10==> OPEN FOR OUTPUT TO PUNCH
		   11==> UNDEFINED
	   17      ON MEANS DON'T ZAP REMOTE PORT ON RESET,GET, OR
	      RUN UUO.
	   18-35   IF BIT 16=1, THE ADDRESS OF AN ASCIIZ STRING
		  WHICH IS THE PASSWORD TO BE CHECKED AGAINST
		  THE FIRST RECORD OF THE FIRST INPUT.

	SKIP RETURN IF SUCCESSFUL
		AC RIGHT HAS NUMBER OF PORT. THIS SHOULD BE
		APPENDED TO "RMT" FOR PURPOSES OF THE INIT. THE
		NUMBER SHOULD BE TREATED AS OCTAL.
		AC LEFT HAS 620 NUMBER WHICH, IN CONJUNCTION
		WITH PORT #, WILL BE USED TO OBTAIN THE TELEPHONE NUMBER
		OF THE ASSIGNED PORT

	NON-SKIP RETURN ON ERROR
		AC CONTAINS ERROR CODE
		  NOPORT==>NO PORT AVAILABLE
		  NOROOM==>NO ROOM IN MONITOR FOR BUFFERS
		  NO620==>VARIAN 620 IS INOPERATIVE
!





	INTERN CRERMT
	EXTERN	PJBSTS,MLOWQ,WSCHED
CRERMT:	SKIPL	RMTALV
	JRST	NO620X		;620 NOT AROUND
	MOVE	T2,PRTCNT
	CAIL	T2,NUMPRT
	JRST	NOPRTX		;NO PORTS AVAILABLE
	UMOVE	U,(W)
	JUMPGE	U,CRERMA	;DOES USER WANT A PARTICULAR PORT?
	LDB T1,[POINT 5,U,5]	;GET DESIRED PORT NUMBER
	CAIGE	T1,NUMPRT
	SKIPE	RMTDDP(T1)
	JRST	NOPRTX		;MAKE SURE PORT IS FREE BEFORE GOING FURTHER
CRERMA:	PUSHJ	P,GTDDB		;GET DDB AND BUFFER
	JRST	NOROMX		;NO ROOM
	DPB J,PJOBN
	SETZM	@RMTBUF(F)	;ZERO OUT BUFFER
	MOVE	T1,RMTBUF(F)
	HRL	T1,T1
	HRRZ	T2,T1
	ADDI	T1,1
	ADDI	T2,BUFSIZ-1
	BLT	T1,(T2)
	AOS	T1,PRTCNT		;INCREMENT PORT COUNT
	CAIE	T1,1
	JRST	CRERM0
	MOVE	T1,UPTIME	;IF THIS IS FIRST PORT, INITIALIZE OLDTIME FOR ACCOUNTING
	MOVEM	T1,OLDTIM
CRERM0:	TLNE	U,(1B16)
	JRST	CREPIN		;OPEN FIRST FOR INPUT
EXTERN TIME,THSDAT,JBTPPN
	SETZM	RMTPAS(F)	;NO, FOR OUTPUT
	HRRZ	T3,RMTBUF(F)	;BYTE POINTER IN T3
	HRLI	T3,(POINT 8,0)
	MOVEI	T1,33
	IDPB	T1,T3		;SELECT PROPER OUTPUT DEVICE
	MOVEI	T1,"A"
	TLNE	T4,(1B15)
	MOVEI	T1,"4"		;IF PRINTER, DO A FORMFEED AFTER PASSWORD
	IDPB	T1,T3
	MOVE	T2,TIME		;FORM 6 CHAR PASSWORD
	ADD	T2,UPTIME
	IMULI	T2,10405
	ADD	T2,THSDAT
	ADD	T2,JBTPPN(J)
	IMULI	T2,10405
	ADD	T2,THSDAT
	MOVNI	T4,2
CRERM3:	SETZ	T1,
	LSHC	T1,6
	PUSHJ	P,GETCNS
	IDPB	T1,T3
	SETZ	T1,
	LSHC	T1,6
	PUSHJ	P,GETVOW
	IDPB	T1,T3
	SETZ	T1,
	LSHC	T1,6
	PUSHJ	P,GETCNS
	IDPB	T1,T3
	AOJL	T4,CRERM3

;FINISHED PUTTING PASSWORD IN MONITOR BUFFER
	MOVEI	T2,EM		;ADD EM
	IDPB	T2,T3
	MOVEI	T2,US
	IDPB	T2,T3
	HRRZ	T1,RMTBUF(F)	;TOTAL OF 11 CHARS. REPEAT THEM SO PASSWORD GETS OUTPUT TWICE
	HRLI	T1,(POINT 8,0)
	MOVNI	T4,11
	ILDB	T2,T1
	IDPB	T2,T3
	AOJL	T4,.-2
	MOVEI	T2,ETX
	IDPB	T2,T3		;MARK END OF BUFFER FOR 620
	MOVEI	T2,ETB
	REPEAT	3,<IDPB	T2,T3>
	HRLI F,(FLMNOB!WRRMT!LASTWR)
	JRST CREREQ	;NOW PUT IN A REQUEST
CREPIN:	HRRZM U,RMTPAS(F)	;SAVE PASSWORD ADDRESS ON INPUT
	HRLI F,(RDRMT!LASTRD)
CREREQ:	MOVSI T1,(GTPTCD)	;SEND A GET PORT TO THE 620
	TLNN U,(1B16)
	TLO T1,(WRTBIT)		;OPEN FOR OUTPUT
	LDB T2,[POINT 6,U,5]
	DPB T2,PRTFLD
	SKIPGE U
	TLO T1,(1B4)		;IN CASE SPECIFYING A PORT
	PUSHJ P,QTO620
	 JRST NO620R		;620 NOW DOWN, GIVE BACK DDB
	AOS PRQCNT
	AOS T1,QPP
	MOVEM F,QPRTST(T1)	;PUT A PORT REQUEST ON THE QUE
	MOVEI T1,MLOWQ
	DPB T1,PJBSTS
	PUSHJ P,WSCHED		;WAIT FOR AN ANSWER
	PUSHJ P,FPRTRQ		;FIND THE ANSWER TO THE PROT REQUEST
	 JRST NOPRTX	;NONE, ZAPPED, DDB RETURNED
	HLRES T2	;GET THE PORT NUMBER
	JUMPL T2,[AOJE T2,NOPRTR	;777777, NO PORT
		JRST NO620R]	;ELSE NO 620 (620 CRASH)
	UMOVEM T2,(W)	;RETURN PORT NUMBER TO USER
	MOVSI T1,DVNZP
	TLNE U,(1B17)
	IORM T1,DEVMOD(F)	;SET NO ZAP BIT IF REQUESTED
	DPB T2,PUNIT	;SAVE PORT NUMBER
	ADDI T2,20
	LSH T2,^D12	;SET GO GIVE PROPER NAME
	HRLI T2,'RMT'
	MOVEM T2,DEVNAM(F)
	JRST CPOPJ1

NO620R:	PUSHJ P,RETBFC	;RETURN BUFFER AND DEC COUNT
NO620X:	MOVEI T2,NO620
	JRST RETERR

NOPRTR:	PUSHJ P,RETBFC
NOPRTX:	MOVEI T2,NOPORT
	JRST RETERR

NOROMX:	MOVEI T2,NOROOM
	JRST RETERR
RETBFC:	SOS PRTCNT
RETDDB:	MOVEI T1,BUFSIZ
	SKIPE T2,RMTBUF(F)
	PUSHJ P,GIVWDS	;RETURN BUFFER IF ONE PRESENT
	HLRZ T1,DDBBLK(F)
	HLRZ T2,DEVSER(F)
	JUMPE T2,RTDB1
	MOVE T3,DEVMOD(T2)	;GET TYPE OF NEXT DDB
	TLNE T3,DVTTY!DVRMT
	HRLM T1,DDBBLK(T2)	;SET BACK LINK
RTDB1:	HRLM T2,DEVSER(T1)	;RELINK PREVIOUS
	MOVEI T1,SIZDDB
	HRRZ T2,F
	PJRST GIVWDS	;RETURN DDB
;GET A CONSONANT
;ENTER WITH A NUMBER FROM 0-77 IN T1, EXIT WITH ASCII CONSONANT IN T1
;CLOBBERS NOTHING
GETCNS:	CAIL	T1,^D26
	SUBI	T1,^D26
	CAIL	T1,^D26
	SUBI	T1,^D26
	ADDI	T1,"A"
	CAIE	T1,"A"
	CAIN	T1,"E"
	ADDI	T1,1
	CAIE	T1,"I"
	CAIN	T1,"O"
	ADDI	T1,1
	CAIN	T1,"U"
	ADDI	T1,1
	POPJ	P,


;GETVOW - ENTER WITH A NUMBER IN T1, EXIT WITH AN ASCII VOWEL
;IN T1 BITS 29-35. OTHER BITS ARE NON-ZERO
;CLOBBERS NOTHING
GETVOW:	PUSH	P,T2
	IDIVI	T1,5
	ADDI	T2,1
	IMULI	T2,7
	MOVE	T1,VOWS
	ROT	T1,(T2)
	ANDI	T1,177
	POP	P,T2
	POPJ	P,
SUBTTL	ZAPRMT UUO
INTERN ZAPRMT
COMMENT !
ZAPRMT AC,0
	ZAP A REMOTE PORT.

	AC RIGHT CONTAINS PORT NUMBER.

	ALWAYS SKIP RETURNS.

	ACTS AS NO-OP IF PORT IS ALREADY ZAPPED OR
	  IS NON-EXISTANT.

	SHOULD NEVER PRECEDE CLOSE UUO SINCE NO ATTEMPT IS MADE
	  TO FLUSH BUFFERS.

	NOTES:
		TYPING "DEASSIGN RMT#" WILL ZAP A CLOSED PORT
		IMMEDIATELY AND CAUSE AN OPEN PORT TO BE
		ZAPPED AS SOON AS IT IS CLOSED.

		A PHONE DISCONNECT WILL ZAP A PORT.
!



EXTERN JOB,GIVWDS,RELEA6,TAKTRP,RETERR

ZAPRMT:	AOS (P)	;ALWAYS SKIP RETURN
	HRRZ U,T1
	PUSHJ P,CHKPRT	;SEE IF PORT NUMBER GIVEN IS LEGAL
	 POPJ P,	;NO, JUST RETURN TO USER
ZAPRM1:	SKIPGE DEVIOS(F)	;AT THIS POINT, F AND U, SET
	POPJ P,		;PORT HAS BEEN ZAPPED, JUST REUTRN
	MOVSI S,(RMTZAP)
	IORM S,DEVIOS(F)	;SET ZAPPED BIT
	MOVSI T1,(ZAPCD)
	DPB U,PRTFLD
	PUSHJ P,QTO620
	 JFCL
	POPJ P,		;JUST TELL 620 TO ZAP HIM

CHKPRT:	MOVEI T2,NO620	;RETURN REASON IN T2 IF FAILS. U SET
	SKIPL RMTALV
	POPJ P,		;620 DOWN
	MOVEI T2,NOPORT
	CAIGE U,NUMPRT	;TOO LARGE?
	SKIPN F,RMTDDP(U)	;OR NOT THERE
	POPJ P,
	LDB T3,PJOBN	;GET JOB NUMBER
	CAMN T3,J	;BELONG TO THIS USER?
	AOS (P)		;YES, SKIP RETURN
	POPJ P,		;NO, NON-SKIP RETURN

; SET UP INTERRUPT CONDITIONS

IOWINT==NWATRP
FOBINT==NOUTRP
INAINT==NINTRP
ZAPINT==NSPTRP
EXTERNAL NWATRP,NOUTRP,NINTRP,NSPTRP
INTRMT:	SKIPGE DEVIOS(F)		;ZAPPED?
	JRST [MOVEI T2,NOPORT		;YES. ERROR RETURN
	      POPJ P,]
	LDB U,PUNIT
	HLL F,RMTDDP(U)		;STATUS BITS FOR IMMEDIATE TRAP
	XCT INTTAB(T2)		;TRAP CONDITION SATISFIED?
	AOS (P)		;NO. NO TRAP RETURN
	JRST CPOPJ1	;YES. TRAP RETURN

INTTAB:	TLNE F,(FLMNIB)	;INPUT AVAILABLE
	TLNN F,(FLMNOB!RD620!WR620)	;OUTPUT AVAILABLE
	SKIPA		;I/O WAIT NEVER TRAP
	SKIPA		;EOF NEVER TRAP FOR NOW
	SKIPA		;ERROR NEVER TRAP FOR NOW
	SKIPA		;ZAPPED. DID NOT GET THIS FAR IF ZAPPED
SUBTTL	VALRMT UUO
INTERN VALRMT

COMMENT	!

VALRMT AC,0
	VALIDATE A PORT THAT WAS CREATED FOR OUTPUT FIRST.

	AC LEFT HAS PORT NUMBER.
	AC RIGHT CONTAINS ADDRESS OF ASCIIZ STRING IDENTICAL TO THE
	  PASSWORD AS CREATED AND OUTPUT TO THE REMOTE
	  BY THE OPERATING SYSTEM. THIS STRING WILL BE CHECKED AGAINST
	  THE PASSWORD.

	SKIP RETURN IF SUCCESSFUL.

	NON-SKIP RETURN  IF NON-SUCCESSFUL, ERROR CODE IN AC.
		NOPORT==>PORT DOESN'T BELONG TO THIS JOB
		BDMTCH==>PASSWORD DOESN'T MATCH
		NO620==>REMOTE 620 IS DOWN
!


VALRMT:	HLRZ U,T1	;GET PORT NUMBER
	PUSHJ P,CHKPRT
	 JRST RETERR	;NOT VALID PORT NUMBER, GIVE ERR
	SKIPGE DEVIOS(F)
	JRST RETERR	;T2 STILL HAS NOPORT, ERR IF ZAPPED
	MOVEI T2,BDMTCH	;IN CASE OF ERROR
	HRLI T1,(POINT 7,0)
	MOVE T3,RMTBUF(F)
	HRLI T3,(POINT 8,0)
	MOVNI	T4,6		;CHECK 6 CHARS. USER PASSES 7-BIT, WE CHECK AGAINST 8-BIT
	MOVEM	T4,RMTCTR(F)
	IBP	T3
	IBP	T3
VALR1:	XCTFU	<ILDB T4,T1>	;GET A CHAR FROM USER
	ILDB	U,T3		;AND AN ORIGINAL CHAR
	CAME	U,T4		;COMPARE
	JRST	RETERR		;AND FAIL IF THEY DON'T MATCH
	AOSGE	RMTCTR(F)
	JRST	VALR1		;KEEP CHECKING UNTIL 6 CHARS
	MOVSI S,(IOSVAL)
	IORM S,DEVIOS(F)
	JRST	CPOPJ1		;AND EXIT
SUBTTL IDLRMT UUO
INTERN IDLRMT
COMMENT !

IDLRMT AC,0
	FORCE REMOTE TO IDLE STATE.

	AC RIGHT HAS PORT NUMBER.

	ALWAYS SKIP RETURNS


	THIS UUO IS A NO-OP IF THE PORT IS ZAPPED OR DOES NOT BELONG
	  TO THE CALLING JOB.
!

IDLRMT:	AOS (P)	;ALWAYS SKIP RETURN
	HRRZ U,T1
	PUSHJ P,CHKPRT
	 POPJ P,	;BAD PORT
	PUSH P,F
IDLRM1:	MOVE S,DEVIOS(F)
	SKIPL S
	TLNN S,(IOSVAL)
	JRST FPOPJ	;ZAPPED OR NOT VALID
	TLOE F,(GOIDLE)
	JRST IDLRM2	;ALREADY WAITING TO GO IDLE
	TLZE F,(LASTWR!LASTRD)
	JRST IDLRM3	;READING OR WRITING
	TLZ F,(EOTGOT!FLMNIB!GOIDLE)
	JRST INFIN	;DONE

IDLRM2:	TLZ F,(WTIDLE!FLMNOB!EOTGOT!FLMNIB)
	JRST INFIN

IDLRM3:	TLZ F,(FLMNOB!FROUTB!FLMNIB!FLINB)
	MOVSI T1,(IDLECD)
	DPB U,PRTFLD	;SET IDLE CODE TO 620
	PUSHJ P,QTO620
	 JRST FPOPJ	;620 NOW DOWN
	JRST INFIN
SUBTTL	DDT620 UUO
INTERN DDT620
EXTERNAL JBTLIC,QUEPCB

COMMENT !

DDT620	AC,0
	RETURN CONTENTS OF A LOCATION IN THE REMOTE 620
	REQUIRES READ CORE LICENSE

	AC LEFT HAS 620 ADDRESS

	NON-SKIP RETURN IF 620 IS DEAD
	READ CORE LICENCE NOT INVOKED,  OR ADDRESS IS HIGHER THAN 177777.

	SKIP RETURN IF SUCCESSFUL WITH CONTENTS IN AC.
	IF 620 ADDRESS IS HIGHER THAN AMOUNT OF MEMORY IN
	620, SKIP RETURN WILL BE TAKEN BUT CONTENTS OF AC WILL BE
	MEANINGLESS.

	ON AN ERROR RETURN, AC WILL HAVE THE REASON
	 3  NO 620
	10  NO LICENSE
	11  BAD ADDRESS

!

DDT620:	MOVEI T2,NOLIC
	MOVSI T3,LICWCR
	TDNN T3,JBTLIC(J)
	JRST RETERR	;DOES NOT HAVE LICENSE
	MOVEI T2,NO620
	SKIPL RMTALV
	JRST RETERR
	HLRZ U,T1	;GET ADDRESS
	MOVEI T2,NOADR
	CAIL U,200000
	JRST RETERR	;BAD ADDRESS
	MOVEI T1,DDTERR
	MOVEM T1,JBTABT(J)	;GET SET IN CASE OF SWAP ERROR
	SKIPN T1,D620JB		;DOES SOME JOB HAVE THE RESOURCE?
	JRST DDTNQ	;NO, NO NEED TO QUE
DDTSQ:	HRRZ T2,QUEPCB(T1)	;YES, LINK UP
	JUMPE T2,DDTQ	;FOUND END OF CURRENT QUE
	MOVE T1,T2
	JRST DDTSQ	;KEEP LOOKING

DDTQ:	HRLZM T1,QUEPCB(J)	;LINK IN
	HRRM J,QUEPCB(T1)
	PUSHJ P,MOWAIT	;AND GO INTO MO WAIT
DDTNQ:	MOVEM J,D620JB	;WE HAVE IT NOW
	SKIPGE RCV620	;STILL WAITING FOR AN ANSWER TO THE LAST ONE?
	PUSHJ P,MOWAIT	;YES, WILL GET REACTIVATED WHEN IT COMES
	MOVSI T1,(RDLCCD)
	DPB U,ADRFLD
	PUSHJ P,QTO620	;SEND MESSAGE TO 620
	 JRST	[MOVE T1,[1B1+NO620]	;ERROR 620 NOW DOWN
		JRST DDTA]
	SETOM RCV620	;EXPECTING ANSWER
	PUSHJ P,MOWAIT
DDTA:	SETZM JBTABT(J)	;NO LONGER WORRIED ABOUT SWAP ERRORS
	PUSHJ P,WAKNXT	;WAKE UP NEXT JOB IN QUE
	MOVE T2,RCV620	;GET ANSWER
	TLZN T2,(1B1)	;SEE IF ERROR BIT IS ON
	AOS (P)		;NO, TAKE GOOD RETURN
	JRST RETERR	;GIVE ANSWER TO USER

DDTERR:	SETZM JBTABT(J)
	CAMN J,D620JB	;IS IT THE JOB WITH THE QUE?
	JRST WAKNXT	;YES, WAKE NEXT JOB ON LIST
	HRRZ T1,QUEPCB(J)
	HLRZ T2,QUEPCB(J)
	SETZM QUEPCB(J)
	HRRM T1,QUEPCB(T2)
	JUMPE T1,CPOPJ
	HRLM T2,QUEPCB(T1)	;NO RELINKED
	POPJ P,

WAKNXT:	SETZM D620JB	;NO ONE WAITING NOW
	SKIPN T1,QUEPCB(J)	;IS THERE A QUE?
	POPJ P,		;NO, NOTHING MORE TO DO
	SETZM QUEPCB(J)	;THIS ONE IS DONE
	HRRZS QUEPCB(T1)	;NO BACK LINK FOR HIM ANY MORE
	HRRZM T1,D620JB	;AND HE HAS IT
MOWAK:	PUSH P,J
	MOVE J,T1
	MOVEI T1,RNQ
	DPB T1,PJBSTS
	PUSHJ P,SETRUN	;WAK UP THE JOB
	POP P,J
	POPJ P,

MOWAIT:	MOVEI T1,MLOWQ
	DPB T1,PJBSTS
	PJRST WSCHED	;GET ON THE MO QUE
SUBTTL		CLOCK ROUTINES

;CLOCK ROUTINES.  CALLED FROM CLOCK1 WITH P SET UP
;AND ALL OTHER ACS FAIR GAME
EXTERN UPTIME,JFYSEC
INTERNAL CKRMT

CKRMT:	SKIPL	RMTALV
	JRST	CKRDWN		;620 IS DOWN
	SKIPN CH2TEL
	PPUSHJ P,SIK620	;CH2 SAYS 620 IS DOWN NOW
	SKIPG	PRTCNT
	JRST CKRMS0	;CHECK IF WAITING FOR DDT ANSWER
	MOVE T1,OLDTIM
	IDIV T1,JFYSEC		;CONVERT TO SECS
	MOVE T2,UPTIME
	MOVEM T2,OLDTIM
	IDIV T2,JFYSEC
	SUB T2,T1
	JUMPE T2,CKRMS1	;NO POINT IN UPDATE IF 0 SEC.
	MOVSI T1,MNUMPT		;EKKP TRACK OF HOW MUCH PORT TIME EACH JOB USES
	SKIPE	F,RMTDDP(T1)
	PUSHJ	P,ACCTIM
	AOBJN	T1,.-2
	JRST CKRMS1	;GO CHECK FOR MSGS
CKRMS0:	SKIPL RCV620	;WAITING FOR DDT MSG?
	POPJ P,		;NO, NO MSGS EXPECTED
CKRMS1:	SKIPN	T1,@QFRM	;ANY MSGS FROM 620?
	POPJ	P,		;NO, EXIT
	AOS	T2,QFRM		;YES, MESSAGE IS IN T1
	SETZM	-1(T2)		;TAKE MESSAGE OFF Q
	CAILE	T2,QFRMND
	MOVEI	T2,QFRMST
	MOVEM	T2,QFRM		;ADJUST Q POINTER
	LDB	T2,MSGTYP	;GET MSG TYPE IN T2
	CAIL	T2,SIZDSP
	PPUSHJ	P,SIK620	;MAKE SURE MESSAGE IS VALID NUMBER
	LDB	U,PRTFLD	;PORT IN U
	MOVE	F,RMTDDP(U)	;AND RMTDDP IN F
	PUSHJ	P,@DSPTCH(T2)	;AND DISPATCH TO SERVICE ROUTINE
	 JFCL			;IN CASE ROUTINE ENDS WITH CALL TO QTO620
	SKIPL	RMTALV		;EXIT IF THAT ROUTINE CRASHED THE 620
	POPJ	P,
	JRST	CKRMS1		;ELSE THEN LOOK FOR MORE MSGS
;THE CRITICAL (AND HOPEFULLY JUSTIFIED) ASSUMPTION HERE IS THAT
;MSGS CAN BE PROCESSED FAR FASTER THAN THE 620 CAN SEND THEM.
ACCTIM:	LDB	J,PJOBN
	JUMPE J,CPOPJ	;IGNORE IF JOB NUMBER 0
	ADDM	T2,JBTRMT(J)
	ADDM T2,JBTRMT	;AND KEEP TOTAL
	POPJ	P,

;620 IS DOWN
CKRDWN:	SKIPE RMTALV		;FIRST TIME?
	JRST CKRSNC		;NO, WAITING FOR 620 NOT TIMEOUT
	MOVE	T1,UPTIME
	CAMG	T1,CRSTIM	;STAY DOWN AFTER A CRASH FOR A WHILE
	POPJ	P,
	PUSHJ	P,RMTIN1	;THEN CLEAR ALL Q'S AS SOON AS WAIT IS OVER
	HRLOI T1,377777
	MOVEM T1,CHKTIM	;SET TIME TO VERY LARGE NUMBER
	SETZM CH2UP	;SO WE KNOW WHEN ITS UP
	MOVSI T1,(HLODER)
	MOVEM T1,CH2TEL	;START CH2 CODE
	AOS RMTALV		;SAID HI TO 620, FLAG IT
	SETZM DWNFLG		;BUT NOT ANSWERED YET
	POPJ P,			;GIVE HIM TIME TO ANSWER

CKRSNC:	SKIPE DWNFLG
	JRST CKRPRT		;WAITING FOR ALL PORT RQ'S TO GO AWAY
	SKIPN CH2TEL	;IS IT STILL OK FROM CH2
	JRST CKRCRS		;NO, GARBAGE, RECRASH HIM
	SKIPN CH2UP	;SEEN ANSWER YET?
	POPJ P,		;NO
	MOVEI T2,0
	EXCH	T2,QFRMST	;YES, HAS HE SENT INIT MESSAGE?
	JUMPE	T2,CPOPJ	;NO, NO MSG. MAYBE NEXT TIME
	HLRZS	T2
	CAIE	T2,(<TYPRST>B3)
	JRST	CKRCRS		;NO, START OVER IF HE SENT ANYTHING ELSE
	MOVSI U,MNUMPT
CKRBFC:	SKIPN T2,RMTDDP(U)	;IS THERE ANYTHING STILL THERE?
	JRST CKRNBF		;NO
	MOVEI T1,BUFSIZ		;YES, MUST BE BUFFER TO GIVE BACK
	PUSHJ P,GIVWDS
	SETZM RMTDDP(U)
CKRNBF:	AOBJN U,CKRBFC
	SETOM DWNFLG		;RESYNC, JUST WAITING FOR PORT CLEANUP
CKRPRT:	SKIPE PRTCNT		;ALL PORT REQS PROCESSED?
	POPJ P,		;NO, FINISHED
	SETOM QPP	;NOW THAT COUNT IS 0, INIT PORT REQUESTS
	SETOM QPJ
	SETOM	RMTALV		;RMTALV=-1
	MOVEI	T1,ALRRMT
	ANDCAM	T1,ALR620	;TURN OF UNHAPPY BIT
	PUSHJ	P,GETOPR
	JUMPE	U,CPOPJ
	PUSHJ	P,INLMES
	ASCIZ /
REMOTE PERIPHERAL 620 JUST RESTARTED.
/
	POPJ	P,		;EXIT
CKRCRS:	SETZM	RMTALV		;RMTALV=0
	SETZM CH2TEL	;STOP CH2
	MOVEI T1,^D30
	IMUL T1,JFYSEC
	ADD T1,UPTIME		;30 SECS FROM NOW
	MOVEM	T1,CRSTIM
	MOVSI	T1,(SUICD)
	MOVEM	T1,QTOST
	MOVE	T1,[QTOST,,QTOST+1]
	BLT	T1,QTOND	;TELL 620 TO CUT IT OUT
	POPJ	P,

DSPTCH:	
PHASE 0
	SIK620	;ILLEGAL MESSAGE TYPE, CRASH
TYPPRT:	RCVPRT
TYPBOU:	RCVBOU
TYPFOU:	RCVFOU
TYPBIN:	RCVBIN
TYPFIN:	RCVFIN
TYPCRS:	RCVCRS
TYPSTS:	RCVSTS
TYPHNG:	RCVHNG
TYPETX:	RCVETX
TYPIDL:	RCVIDL
TYPRST:	RCVRST
TYPDDT:	RCVDDT
DEPHASE
SIZDSP=.-DSPTCH			;SIZE OF DISPATCH TABLE

INTERNAL CH2RMT	;CALLED FROM CLOCKS INTERUPT WITH JSP T1,CH2RMT

CH2RMT:	MOVEM T1,SAVT1
	SKIPN T1,CH2TEL	;DO WE WANT TO DO ANYTHING?
	JRST CH2RTN	;NO
	EXCH T1,LIVWRD
	MOVSS T1
	CAIN T1,(HIPDP)	;620 SAYS HELO?
	JRST CH2RM1	;YES
	CAIN T1,(HLODER)
	SOSG CHKTIM
	SETZM CH2TEL	;GARBAGE IN CELL OR TIMEOUT
CH2RTN:	MOVE T1,SAVT1
	JRST (T1)

CH2RM1:	SETOM CH2UP
	MOVE T1,CH2TIM
	MOVEM T1,CHKTIM	;SET TIME TO MAX
	JRST CH2RTN
	SUBTTL MESSAGE SERVICE ROUTINES

;ENTER WITH MESSAGE IN T1, PORT IN U, RMTDDP(U) IN F

;RECIEVED MSG 1, HERE'S PORT

RCVPRT:	SOSGE PRQCNT	;WERE THERE ANY REQUESTS?
	PPUSHJ P,SIK620	;NO, 620 ERROR
	LDB U,[POINT 4,T1,7]	;GET PORT NUMBER (1 BIT LARGER)
	CAIN U,17
	JRST	[MOVNI U,1
		JRST RCVPT1]	;NO PORT AVAILABLE
	CAIGE U,NUMPRT	;IS IT TOO LARGE?
	SKIPE RMTDDP(U)	;OR IN USE?
	PPUSHJ P,SIK620	;YES, 620 ERROR
RCVPT1:	AOS T1,QPJ	;SATISFY FIRST UNSAT PORT REQUEST
	PUSHJ P,PRTWAK	;WAKE UP JOB AND GIVE HIM PORT NUMBER
	SKIPL U
	MOVEM F,RMTDDP(U)	;IF ONE THERE, SET RMTDDP FROM REQ
	POPJ P,

PRTWAK:	MOVE F,QPRTST(T1)	;GET THE PORT REQUEST
	LDB J,PJOBN	;GET JOB NUMBER FROM DDB (POINTER IN F)
	PUSH P,T1
	MOVEI T1,RNQ
	DPB T1,PJBSTS
	PUSHJ P,SETRUN
	POP P,T1
	HRLM U,J	;MAKE RESPONSE OF PORT,,JOB
	MOVEM J,QPRTST(T1)	;AND SET IT
	POPJ P,

EXTERNAL SETRUN,RNQ,SETIOD
;RECIEVE MSG 2, NEED ADDRESS OF OUTPUT BUFFER

RCVBOU:	CAIGE U,NUMPRT	;IS PORT TOO HIGH
	TLZN F,(WRRMT)	;OR UNEXPECTED MESSAGE
	PPUSHJ P,SIK620	;620 ERROR
	TLNE F,(GOIDLE)
	PJRST STORMT	;JUST RESTORE RMTDDP
	TLNN F,(FLMNOB)	;IS THERE A BUFFER READY?
	JRST RCVBO1	;NO
	MOVEI S,PHONON
	IORM S,DEVIOS(F)	;TELL USER PHONE IS THERE
	TLO F,(WR620)	;NO COPYING TO 620
	MOVSI T1,(SNADCD)	;TELL 620 WHERE BUFFER IS
	DPB U,PRTFLD
	MOVE T2,RMTBUF(F)
	DPB T2,ADRFLD
QTOSTO:	MOVEM F,RMTDDP(U)	;SEND TO 620 AND STORE RMTDDP
QTO620:	SKIPL RMTALV	;SEND TO 620
	POPJ P,		;NON-SKIP RETURN IF DOWN FOR UUO LEVEL
	SKIPE @QTO	;IS QUE FULL
	PPUSHJ P,SIK620	;YES, 620 MUST BE SICK
	MOVEM T1,@QTO	;PUT MESSAGE IN QUE
	AOS T1,QTO
	CAIG T1,QTOND	;RUN OVER END?
	JRST CPOPJ1	;NO, SKIP RETURN (FOR UUO LEVEL)
	MOVEI T1,QTOST	;YES, RESET POINTER TO START
	MOVEM T1,QTO
	JRST CPOPJ1	;ALL FINISHED

RCVBO1:	TLO F,(FROUTB)	;NO BUFFER READY, SET FLAG THAT 620 HAS REQUESTED ONE
	TLZE F,(CLSNPG)	;IS THIS A CLOSE?
	PJRST WAKONT	;YES, WAKE JOB WITHOUT TRAP
STORMT:	MOVEM F,RMTDDP(U)
	POPJ P,


;RECIEVE MSG 3, FINISHED COPY TO 620

RCVFOU:	CAIGE U,NUMPRT	;CHECK PORT NUMBER
	TLZN F,(WR620)	;AND THAT MSG EXPECTED
	PPUSHJ P,SIK620
	TLNE F,(WTIDLE)
	PJRST STORMT	;WAITING FOR 620 TO GO IDLE TO START INPUT
	TLZN F,(FLMNOB)	;BUFFER THERE?
	PJRST WAKOTR	;NO, SAY OUTPUT FREE AND WAKE
	TLO F,(WRRMT)	;BACK TO WRITING TO RMT
	TLNE F,(CLSNPG)	;CLOSE?
	PJRST STORMT	;YES, DO NOT WAKE HIM YET
WAKOTR:	LDB T1,FOBINT	;GET INTERUPT CODE
	MOVSI S,(IOSARM)
	TDNN S,DEVIOS(F)	;DID WE ARM FOR OUTPUT TRAP?
	JRST WAKONT		;NO, DO NOT TRAP
	ANDCAM S,DEVIOS(F)	;RESET
WAKTRC:	PUSHJ P,TAKTRJ	;TAKE TRAP IN ENABLED ETC
WAKONT:	MOVE S,DEVIOS(F)	;SEE IF IN IOW
	TLZN S,IOW
	PJRST STORMT	;NO, JUST RESET RMTDDP
	TRZ S,IOACT	;YES, RESET IOACT
	MOVEM S,DEVIOS(F)
	MOVEM F,RMTDDP(U)
	PJRST SETIOD	;AND GO
;RECIEVE MSG 4, NEED INPUT BUFFER ADDRESS

RCVBIN:	CAIGE U,NUMPRT
	TLZN F,(RDRMT)
	PPUSHJ P,SIK620
	TLNE F,(GOIDLE)
	PJRST STORMT	;JUST WAITING FOR IT TO GO IDLE
	TLNE F,(FLMNIB)
	JRST	[TLO F,(FLINB)	;NO BUFFER SPACE, JUST FLAG IT
		PJRST STORMT]
	TLO F,(RD620)	;NOW READING FROM 620
	MOVEI S,PHONON
	IORB S,DEVIOS(F)
	MOVSI T1,(RCADCD)
	DPB U,PRTFLD	;TELL USER PHONE LINE THERE AND TELL 620
	MOVE T2,RMTBUF(F)	;WHERE BUFFER IS
	DPB T2,ADRFLD
	TRNE S,IGCHKS	;IGNORE CHKSUMS?
	TLO T1,(NOCHK)	;YES, TELL 620
	PJRST QTOSTO	;STORE F AND QUE MSG


;RECIEVE MSG 5, FINISHED COPY TO PDP-10

RCVFIN:	CAIGE U,NUMPRT
	TLZN F,(RD620)
	PPUSHJ P,SIK620
	TLNE F,(WTIDLE)
	PJRST STORMT	;WAITING FOR IT TO GO IDLE
	TLNE F,(GOIDLE)
	PJRST WAKOTR
	TLO F,(FLMNIB)	;INPUT BUFFER IS NOW FULL
	TLNE T1,(1B9)	;DID 620 SAY ETX THERE?
	TLOA F,(GOIDLE!EOTGOT)	;ETX PRESENT
	TLOA F,(RDRMT)	;ETX NOT PRESENT
	TLZ F,(LASTRD)	;ETX PRESENT
WAKITR:	LDB T1,INAINT
	PJRST WAKTRC	;INPUT AVAILABLE TRAP AND WAKE JOB
;RECIEVE MSG 6  620 CRASH

RCVCRS:	MOVEM T1,SV620C	;SAVE CRASH LOCATION
	PPUSHJ P,SIK620

;RECIEVE MSG 7  STATUS

RCVSTS:	CAIL U,NUMPRT
	PPUSHJ P,SIK620
	JUMPE F,CPOPJ	;NOT REALLY A JOB ON THIS PORT, IGNORE
	DPB T1,[POINT 32,DEVSTS(F),31]
	POPJ P,		;JUST SAVE STATUS

;RECIEVE MSG 13 RESTARTED

RCVRST:	PPUSHJ P,SIK620	;SHOULD NEVER SEE THIS MSG

;RECIEVE MSG 11 FINISHED COPY TO RMT AND SAW ETX

RCVETX:	CAIGE U,NUMPRT
	TLZN F,(WRRMT)
	PPUSHJ P,SIK620
	TLOE F,(GOIDLE)
	PJRST STORMT	;DONE IF ALREADY WAITING FOR IDLE
	TLZ F,(LASTWR)
	TLNN F,(FLMNOB)	;IF BUFFER
	TLZN F,(CLSNPG)	;NO BUFFER AND CLOSE
	PJRST STORMT	;BUFFER OR NOT CLOSE, DONE
	PJRST WAKONT	;WAKE JOB
;RECIEVE MSG 10, PHONE HANGUP

RCVHNG:	CAIGE U,NUMPRT
	SKIPN RMTDDP(U)
	PPUSHJ P,SIK620	;PORT TOO BIG OR NO ONE THERE
HNGCOD:	HRRZS DEVNAM(F)	;ZERO LEFT HALF OF NAME, CAN NOT ACCESS NOW
	SETZM DEVLOG(F)	;REMOVE LOGICAL NAME ALSO
	SKIPN DEVNAM(F)	;DID WE EVER FINISH CRERMT
	PUSHJ P,FPRTQJ	;FIND AND REMOVE PORT REQUEST
	JFCL		;IN CASE OF FPRTQJ SKIP RETURN
	MOVEI T1,BUFSIZ
	SKIPE T2,RMTBUF(F)	;GIVE BACK BUFFER
	PUSHJ P,GIVWDS	;IF NON-ZERO
	SETZM RMTBUF(F)
	SOS PRTCNT	;ONE LESS PORT IN USE
	MOVE S,[IODERR!URZAPD!RMTZAP]
	IORM S,DEVIOS(F)
	MOVEI S,PHONON
	ANDCAM S,DEVIOS(F)
	LDB T1,ZAPINT
	PUSHJ P,WAKTRC	;TAKE ZAP TRAP IF THERE AND WAKE JOB
	SETZM RMTDDP(U)	;NOTHING THERE ANYMORE
	MOVEI T2,ASSCON
	PJRST RELEA6	;AND RESET ASSCON BIT

;REMOVE A REQUEST FROM THE PORT REQUEST QUE

FPRTQJ:	LDB J,PJOBN	;WE ALREADY HAVE F, GET JOB
FPRTRQ:	SKIPGE T1,QPJ	;ANY REQUESTS IN QUE?
	POPJ P,		;NO
FPRTQ1:	MOVE T2,QPRTST(T1)	;GET REQUEST
	CAIE J,(T2)	;CORRECT JOB?
	SOJGE T1,FPRTQ1	;NO
	JUMPL T1,CPOPJ	;DID WE STOP BECAUSE WE RAN OUT?
	SOS QPJ		;DEC POINTER TO SATISFIED REQS
	SOSL T3,QPP	;AND TOTAL
	CAMGE T3,T1
	JRST CPOPJ1	;NO REQUEST LEFT OR DELETING LAST ONE
	HRLI T1,QPRTST+1(T1)
	ADDI T1,QPRTST
	BLT T1,QPRTST(T3)	;REMOVE REQUEST FROM QUE
	JRST CPOPJ1
;RECIEVED MSG 12, DISTRESS (IDLE MOST IMPORTANT PART

RCVIDL:	LDB T2,[POINT 4,T1,15]	;GET MSG
	CAIL T2,SIZD12
	PPUSHJ P,SIK620
	XCT CK12DS(T2)

CK12DS:	PPUSHJ P,SIK620	;ZERO CODE IS ERROR
	JRST PARRMT	;1 PARITY ERROR
	JRST CHKSER	;CHKSUM ERROR
	JRST IDL620	;IDLE
	JRST NOTERC	;NO TERMINAL CHARACTER
SIZD12==.-CK12DS

PARRMT:	CAIE U,17	;IF PORT NUMBER IS 17, THEN IN QUE
	JRST PARRM1	;NO, IN USERS BUFFER
	MOVEI T1,QTOST
	CAILE T1,QTOND	;REACHED END YET
	PPUSHJ P,SIK620	;NONE SEEN BY US, BETTER CRASH HIM
	MOVE T2,(T1)	;READ, SHOULD GET PARITY INTERUPT
	AOJA T1,.-3

;PARITY IN USER BUFFER
PARRM1:	CAIGE U,NUMPRT
	SKIPN RMTDDP(U)
	PPUSHJ P,SIK620
ERR620:	DPB T1,STSDEV	;SAVE STATUS FOR USER
	MOVEI S,IODTER
	IORM S,DEVIOS(F)	;SET ERROR BIT ALSO
	POPJ P,

;CHKSUM ERROR
CHKSER:	CAIGE U,NUMPRT
	SKIPN RMTDDP(U)
	PPUSHJ P,SIK620	;CHECK PORT
	JRST ERR620	;COMMON ERROR CODE

;NO TERMINAL CHARACTER
NOTERC:	CAIGE U,NUMPRT
	SKIPN RMTDDP(U)
	PPUSHJ P,SIK620
	DPB T1,STSDEV
	MOVEI S,IOIMPM
	IORM S,DEVIOS(F)	;LIKE ABOVE BUT IOIMPM
	POPJ P,
;HERE ON AN IDLE MESSAGE

IDL620:	CAIGE U,NUMPRT
	SKIPN RMTDDP(U)
	PPUSHJ P,SIK620
	TLZE F,(GOIDLE)
	JRST IDLIDL	;IDLE AND WAITING FOR IDLE
	TLNE F,(WR620!RD620!EOTGOT)
	PPUSHJ P,SIK620	;SHOULD NOT GET IDLE WHILE IN THIS STATE
	TLZE F,(LASTWR)
	JRST IDLWR	;IDLE WHILE WRITE
	TLZN F,(LASTRD)
	PJRST STORMT	;PROBABLY JUST IDLE WHILE IDLE
	TLNN F,(FLMNIB)
	JRST IDLRD1
	TLZ F,(RDRMT!FLINB)
	TLO F,(EOTGOT)
	PJRST STORMT	;NOW IDLE

IDLRD1:	TLZ F,(RDRMT)
	MOVSI S,IOEND
	IORM S,DEVIOS(F)
	PJRST WAKITR	;WAKE INPUT AND TRAP

IDLWR:	TLZ F,(FLMNOB!WRRMT!FROUTB)
	MOVEI S,IODERR!IODEND
	IORM S,DEVIOS(F)
	PJRST WAKOTR	;WAKE OUTPUT AND TRAP

IDLIDL:	TLZE F,(WTIDLE)
	JRST IDLGOR	;NOW IDLE, GO TO READ
	TLNE F,(FLMNOB)
	JRST IDLGOW	;NOW IDLE GO WRITE
	TLZE F,(WR620!RD620)
	PJRST WAKOTR
	TLZ F,(WRRMT!RDRMT)
	PJRST STORMT

IDLGOR:	TLZ F,(WR620!RD620!WRRMT)
	TLO F,(LASTRD!RDRMT)
	MOVSI T1,(STMDCD)
	DPB U,PRTFLD
	MOVE S,DEVIOS(F)
	TRNE S,IGCHKS
	TLO T1,(NOCHK)
	PJRST QTOSTO	;STORE AND SEND MSG

IDLGOW:	TLZ F,(RDRMT)
	TLO F,(LASTWR!WRRMT)
	MOVSI T1,(STMDCD!WRTBIT)
	DPB U,PRTFLD
	PJRST QTOSTO
;RECIEVED MSG 14, ANSWER TO DDT REQUEST

RCVDDT:	SKIPL RCV620	;EXPECTED?
	PPUSHJ P,SIK620	;NO
	LDB T1,ADRFLD	;GET ANSWER
RCVDT1:	MOVEM T1,RCV620
	SKIPE T1,D620JB
	PJRST MOWAK	;WAKE UP JOB
	POPJ P,
;620 HAS CRASHED OR MUST BE FORECED DOWN BECAUSE OF ERRORS

EXTERNAL ALR620,GETOPR,INLMES

;RETURN OUT OF CALLING ROUTINE, NOT TO CALING ROUTINE

SIK620:	POP P,CRSRMT	;SAVE LOC OF CALLER
	MOVEM T1,CRST1	;SAVE PROBABLE MESSAGE
	MOVEM F,CRSF	;AND PROBABLE RMTDDP
	AOS CRSNUM	;ONE MORE CRASH
	PUSH P,J
	PUSH P,F
	PUSH P,S
	MOVSI U,MNUMPT
SIK1:	SKIPN F,RMTDDP(U)	;ANYTHING THERE?
	JRST SIK2	;NO, SKIP THIS PORT
	TLNE F,(RD620!WR620)	;WAS 620 ACCESSING BUFFER?
	JRST SIKCOP	;YES, MUST NOT RETURN BUFFER
	PUSHJ P,HNGCOD	;NO, PRETNED A HANGUP SENT
SIK2:	AOBJN U,SIK1
	MOVEI U,777776	;GET SET TO SAY NO 620 TO PORT RQS
SIK3:	AOS T1,QPJ	;INCREMENT THE SATISFY POINTER
	CAMLE T1,QPP	;STILL POINTING TO A REQUEST?
	JRST SIK4	;NO
	PUSHJ P,PRTWAK	;WAKE UP THAT JOB
	JRST SIK3	;TRY AGAIN
SIK4:	SOS QPJ		;TO MAKE UP FOR THE EXTRA AOS
	MOVE T1,[1B1+NO620]
	SKIPGE RCV620	;EXPECTING ANSWER TO 620 DDT REQ?
	PUSHJ P,RCVDT1	;YES, GET JOB RESTARTED
	MOVEI	T1,ALRRMT
	IORM	T1,ALR620	;SET SYSTEM UNHAPPY.
	PUSHJ	P,GETOPR
	JUMPE	U,SIK5		;IF THERE'S AN OPR TTY, TELL OPER
	PUSHJ	P,INLMES
	ASCIZ	/
REMOTE PERIPHERAL 620 JUST CRASHED.
/
SIK5:	POP	P,S
	POP	P,F
	POP	P,J		;RESTORE S,F,J
	JRST CKRCRS	;GO FINISH MAKING 620 DOWN

SIKCOP:	PUSH P,RMTBUF(F)	;SAVE THE BUFFER POINTER
	SETZM RMTBUF(F)	;AND ZERO IT
	PUSHJ P,HNGCOD	;SO HNGCOD WILL NOT TRY TO GIVE IT BACK
	POP P,RMTDDP(U)	;NOW PUT IT IN RMTDDP
	JRST SIK2	;AND CONTINUE
;GET DDB AND PUT ADDR IN F
;CLOBBER T1 AND T2
;SKIP RETURN IF SUCCESSFUL
EXTERN TTYTAB,GETWDS

GTDDB:	MOVEI	T2,BUFSIZ	;GET BUFFER FIRST
	PUSHJ	P,GETWDS
	POPJ	P,		;EXIT IF FAILURE
	PUSH	P,T1		;SAVE ADDR OF BUFFFER
	MOVEI	T2,SIZDDB
	PUSHJ	P,GETWDS
	JRST	GTFAL		;THEN GET DDB AND RELEASE BUFFER IF NO ROOM LEFT
	MOVE	F,T1
	ADDI	T1,SIZDDB-1
	HRRZ	T2,F
	HRLI	T2,RMTDDB
	BLT	T2,(T1)		;COPY PROTOTYPE DDB INTO NEW DDB
	POP	P,RMTBUF(F)	;RMTBUF POINTS TO BUFFER
	HRRZ	T1,TTYTAB(J)	;LINK DDB INTO CHAIN
	HRLZM	T1,DDBBLK(F)	;AFTER CONTROLLING TTY
	HLRZ	T2,DEVSER(T1)
	HRLM	T2,DEVSER(F)
	HRLM	F,DEVSER(T1)
	JUMPE	T2,CPOPJ1
	MOVE	T1,DEVMOD(T2)	;IF NEXT DDB IS FOR TTY OR REMOTE
	TLNE	T1,DVRMT!DVTTY	;THEN FIX ITS BACK LINK
	HRLM	F,DDBBLK(T2)
	JRST	CPOPJ1

GTFAL:	MOVEI	T1,BUFSIZ
	POP	P,T2
	PJRST	GIVWDS

RMTLIT:	LIT
RMTEND:	END
      `bkg