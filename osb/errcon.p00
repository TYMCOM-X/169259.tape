TITLE ERRCON - MONITOR DETECTED ERROR HANDLING ROUTINES - V425
SUBTTL T. HASTINGS/TH/CHW/TW/RCC SCNSER 07 OCT 70

	S$NAME='ERRCON'

XP VERRCN,425		;THIS MACRO PUTS VERSION NO. IN STORAGE MAP AND GLOB

	ENTRY ERRCON	;ALWAYS LOAD ERRCON(IF LIB SEARCH)
ERRCON:

;THESE ERROR ROUTINES PRINT "ERROR IN JOB N"
;FOLLOWED BY AN APPROPRIATE ERROR MESSAGE
;THEN THE JOB IS STOPPED AND CONSOLE IS RETURNED TO
;MONITOR COMMAND MODE

;APR DETECTED ERRORS
;PUSHDOWN OVERFLOW,ILLEGAL MEMORY, NONEXISTENT MEMORY
;FOR WHICH THE USER IS NOT ENABLED.
;SEE APRSER TO SEE HOW APR INTERRUPTS ARE HANDLED
;CALL:	SKIPE T1,APRERR	;RESULT OF CONI APR,APRERR
;	PUSHJ P,APRILM	;FROM CLK SERVICE ROUT.(LOWEST PRIOTITY PI)
;	RETURN TO RESCHEDULE NEW USER

EXTERNAL HOLD,ALR620,TTYFND
EXTERNAL TSETBI,GETOPR,TTYFNU,TTYSTR,PIOMOD
EXTERNAL UPTPDL,%UPT,UPTABK,UPTSTS,UPSABK,UPTABL,%UPX,%UPS
EXTERNAL UPTUII,UPTXII
IFCPU (KL),<EXTERNAL AB.USR>
EXTERNAL JBTSTS
EXTERNAL USRXIT,WSCHED,CLKPC1,CLKPC2
EXTERNAL JOB
SUBTTL SYSTEM ERROR EXIT DEFINITIONS
COMMENT #

GENERATE CODE TO STORE ERROR STATUS IN THE FRAME'S UPT, TRAP TO
TRAPHANDLER OR PARENT, PRINT MESSAGE IF NO ONE IS HANDLING ERRORS.

X ARGUMENTS:

CODE	THREE LETTER CODE FOR ERROR. SYMBOLS ERR??? GENERATED TO JRST TO.
TYPE	TYPE NUMBER WITHIN ERROR CLASS.
MESSAGE	BASIC MESSAGE TO PRINT.
TTYFIN	PUSHJ TO THIS ROUTINE TO FINISH MESSAGE.
	ERRSCP - "FOR (EXEC) LOCATION/PAGE <C(M)> AT USER <C(GETPC)>" OR
		 "FOR (EXEC) LOCATION/PAGE <C(M)>; UUO AT EXEC/USER <C(UPTPDL)-1>"
	ERRSCD - "AT USER <C(GETPC)>" OR
		 ";UUO AT <C(UPTPDL)-1>"
	ERRSCM - "AT USER <C(GETPC)-1>" OR
		";UUO AT <C(GETPC)-1>"
	UUOPCP - "AT USER <C(UPTPDL)-1>"
	ERRSCU - "; UUO AT <C(UPTPDL)-1>"
	TCLTTY - CLEAR TYPE AHEAD, PUT TTY IN MONITOR MODE, PRINT CRLF, WATCH
		 DATA, CRLF, AND PERIOD
	TNCTTY - SAME AS TCLTTY, BUT DOESN'T CLEAR TYPE AHEAD
	E1STTY - PRINT WATCH, CRLF, PERIOD, PUT TTY IN MONITOR MODE (FOR EXIT 1,)
	<BLANK> - DOES TCLTTY
STOP	ROUTINE TO USE TO STOP THE JOB, WHETHER OR NOT A MESSAGE
	IS PRINTED.
	KJSTOP - STOP JOB, SET JERR, SET IT TO LOGOUT IF JLOG OFF
	HISTOP - STOP JOB CONTINUABLY, CONTINUES POPJ
		  (FOR HALT INSTRUCTION AND ADDRESS BREAK.)
	HNSTOP - STOP CONTINUABLY, SET JDCON
	BISTOP - SPECIAL RETURN FOR BAD INTERRUPT ADDRESS
	E1STOP - STOP CONTINUABLY, JRST TO USCHED (FOR EXIT 1,)
		 CONTINUES AT ADDRESS C(P) (IS UPTPDL FOR EXIT 1,)
	HLSTOP - STOP CONTINUABLY, CONTINUE WILL POPJ FROM JRST ERR???
	STOP1  - IF JERR NOT ON, WILL RETURN TO CALLER OF ERR???.
		 USED IF CALLER NOT SAME AS THE FRAME THAT IS STOPPING.
		 ALSO USED IF FRAME STOPS BECAUSE OF DELAYED CONTROL-C
		 IN WHICH CASE PUSHJS TO ERR??? AND JRSTS TO WSCHED, USCHED, ETC.
	<BLANK> - KJSTOP
GETPC	<BLANK> - GET PC FROM STACK
	NONE - NO CODE GENERATED TO FETCH PC
	<NON-BLANK> GET PC FROM SPECIFIED ARG
SETTTY	<BLANK> - USE ERRTTY, SETS UP FRAME'S LDB, OR IF NONE, OPR LDB
	<NON BLANK> - PUSHJ TO ARG ROUTINE, JUMP TO STOP JOB ROUTINE IF
			C(U) IS ZERO, ELSE ASSUME F AND U ARE SETUP
	  TTYFNU - RETURNS C(U) 0 IF DETACHED, OR LDB ADDRESS. C(F) GETS TTY DDB ADDRESS
	  ERRFNU - SAME AS TTYFNU, BUT PRESERVES F.
	  EXIFNU - SPECIAL TTY FINDING ROUTINE FOR EXIT, SEE ROUTINE.
	  NOMESS - NO MESSAGE OR TTY NEEDED, JUST STOP THE FRAME.
VALUE	<BLANK> - NO VALUE ASSOCIATED WITH MESSAGE
	<NON-BLANK> - AC NAME TO STORE INTO UPTELC
VALUE1	<BLANK> - NO VALUE
	<NON-BLANK> - AC NAME TO STORE INTO UPTEL1
UPLOC	<BLANK> - CONTEXT PAGES ACCESSIBLE THRU %UPT
	%UPS - THRU %UPS
	%UPX - THRU %UPX
#

DEFINE ERRS<
ERRCLS==0	;CLASS 0, MEMORY VIOLATIONS

X(PCO,0,<PC OUT OF BOUNDS>,ERRSCD)
X(IMR,1,<ILL MEM REF>,ERRSCP)
X(WRV,2,<WRITE VIOLATION>,ERRSCP)
X(ADC,3,<ADDRESS CHECK FOR ,DEV>,ERRSCP)
X(IMU,4,<ILL MEM REF IN UUO>,ERRSCP)
X(IIA,5,<ILLEGAL INTERRUPT ADDRESS>,,BISTOP,NONE)
X(ABK,6,<ADDRESS BREAK>,ERRSCP,HISTOP,P1)
X(POV,7,<PDL OV>,ERRSCD)

ERRCLS==1	;CLASS 1,SYSTEM RELATED ERRORS

X(PIO,0,<PAGE I/O ERROR>,ERRSCP)
X(DFL,1,<DISK FULL DURING C-O-W>,ERRSCP)
X(PHE,2,<PAGING HARDWARE ERROR>,ERRSCP)
X(TPL,3,<TOO MANY PAGES LOCKED, CAN'T HANDLE FAULT>,ERRSCP)
X(CIO,4,<CONTEXT PAGE I/O ERROR>)
X(PAR,5,<PARITY ERROR(S). ALL CORE REMOVED>)
X(MED,6,<Monitor Error Detected>,UUOPCP)

ERRCLS==2	;DEVICE RELATED ERRORS

X(OCI,0,<OUTPUT ,DEV, CANNOT DO INPUT>,UUOPCP)
X(ICO,1,<INPUT ,DEV, CANNOT DO OUTPUT>,UUOPCP)
X(IDM,2,<ILLEGAL DATA MODE FOR ,DEV>,ERRSCU)
X(IUC,3,<IO TO UNASSIGNED CHANNEL>,UUOPCP)
X(HDV,4,<HUNG ,DEV>,ERRSCU)
X(DOP,5,<DEV, OPR ACTION REQUESTED>,,HNSTOP,NONE,ERRFNU)

ERRCLS==3	;ILLEGAL INSTRUCTION TRAPS

X(ILU,0,<ILLEGAL UUO>,UUOPCP)
X(UUE,1,<UUO ERROR>,UUOPCP)
X(ILI,2,<ILL INST>,UUOPCP)
X(HLT,3,<HALT>,ERRSCM,HISTOP,P1)
X(CAL,4,<ILLEGAL CALL NAME>,UUOPCP)

ERRCLS==4	;FRAME EXITS

X(EXI,0,<CRLF,EXIT>,TNCTTY,KJSTOP,NONE,EXIFNU)
X(EX1,1,<>,E1STTY,E1STOP,NONE,EXIFNU)
X(FEX,2,<?fail exit >,FEXPRT,KJSTOP,NONE,EXIFNU,T4)
X(TLE,3,<TIME LIMIT EXCEEDED>,TLETTY,STOP1,NONE,TTYFNU)
X(JSU,4,<FNAME, SETUP>,TNCTTY,KJSTOP,NONE,EXIFNU,P3,P4)
X(JSV,5,<FNAME, SAVED>,TNCTTY,KJSTOP,NONE,EXIFNU,P3,P4)
X(FCL,6,<FRAME CLEARED>,,KJSTOP,NONE,NOMESS)
X(FX1,7,<?fail stop >,FEXPRT,E1STOP,NONE,EXIFNU,T4)

ERRCLS==5	;RUN, RUNSEG, GETSEG UUO ERRORS

X(TRE,0,<CRLFQ,I/O error on file ,FNAME>,,KJSTOP,NONE,EXIFNU)
X(PGN,1,<CRLFQ,DECPRT, PAGES NEEDED>,,KJSTOP,NONE,EXIFNU,M)
X(DNA,2,<CRLFQ,DEV, NOT AVAILABLE>,,KJSTOP,NONE,EXIFNU)
X(FNF,3,<CRLFQ,FNAME, NOT FOUND>,,KJSTOP,NONE,EXIFNU,P3,P4)
X(NSF,4,<CRLFQ,NOT A SAVE FILE>,,KJSTOP,NONE,EXIFNU)
X(EUF,5,<CRLFQ,FNAME, ATTEMPTED ENTER UUO FAILED>,,KJSTOP,NONE,EXIFNU,P3,P4)
X(CAN,6,<CRLFQ,CORE ARGUMENT MUST BE SPECIFIED>,,KJSTOP,NONE,EXIFNU)
X(MHB,7,<CRLFQ,MAG TAPE HISEG FORMAT BAD OR SYSTEM ERRORS>,,KJSTOP,NONE,EXIFNU)
X(RMF,10,<CRLFQ,FATAL ERROR DURING REMAP UUO>,,KJSTOP,NONE,EXIFNU)
X(MGF,11,<CRLFQ,MAGTAPE GET FAILURE>,,KJSTOP,NONE,EXIFNU)
X(NSA,12,<NO START ADDR>,,KJSTOP,NONE,EXIFNU)
>;END ERRS MACRO DEFINITION
SUBTTL ERROR EXIT ROUTINE GENERATION

DEFINE IFADF(ARG1,ARG2,DO,%A)<;BEGIN DEFINITION OF IF ALL DIFFERENT MACRO
%A==0
IRP ARG2,<IFIDN <ARG1> <ARG2> <%A==-1>
>;END IRP ARG2
IFE %A,<'DO>
PURGE %A
>;END IFADF

DEFINE IFOID(ARG1,ARG2,DO,%A)<;BEGIN IF ONE IDENTICAL MACRO
%A==0
IRP ARG2,<IFIDN <ARG1> <ARG2> <%A==-1>
>;END IRP ARG2
IFN %A,<'DO>
PURGE %A
>;END IFOID
;NOW DEFINE X MACRO, SO CAN CALL ERRS AND GENERATE THE ERROR EXITING
; CODE.

DEFINE X(CODE,TYPE,MESS,TTYFIN,STOP,GETPC,SETTTY,VALUE,VALUE1,UPLOC,%STP,%UP)<
IFB <STOP> <%STP==KJSTOP>
IFNB <STOP> <%STP=='STOP>
IFB <UPLOC> <%UP==%UPT>
IFNB <UPLOC> <%UP=='UPLOC>

ERR'CODE::
IFB <GETPC> <
	MOVE P1,(P)>	;IF BLANK, MEANS PC IS (P).
IFADF GETPC,<P1,NONE,>,<
	MOVE P1,'GETPC	;IF NOT BLANK, MEANS GET PC FROM ARG PLACE
>;END IFADF

	MOVE	T1,[ERRCLS,,'TYPE] ;GET CLASS,,TYPE WITHING CLASS
	MOVEM	T1,%UP+UPTETP	;EXIT TYPE
IRP MESS,<IFIDN <MESS> <DEV> <
	MOVE	T1,DEVNAM(F)	;IF ITS A DEVICE MESSAGE, STORE NAME
	MOVEM	T1,%UP+UPTEDV
>>;END IFIDN AND IRP

IFIDN <TTYFIN> <ERRSCP> <
	MOVEM M,%UP+UPTELC 	;IF PRINTING LOC, STORE IT TOO.
>;END IFIDN
IFNB <VALUE> <
	MOVEM 'VALUE,%UP+UPTELC ;OR IF OTHER VALUE SPECIFIED
>;END IFNB <VALUE>
IFNB <VALUE1> <
	MOVEM 'VALUE1,%UP+UPTEL1
>;END IFNB <VALUE1>

IFOID 'UPLOC,<%UPT,>,<
	PUSHJ	P,ERRSET>
IFIDN <UPLOC> <%UPS> <
	PUSHJ	P,ERRSES>
IFIDN <UPLOC> <%UPX> <
	PUSHJ	P,ERRSEX>
	  PJRST	%STP		;GO STOP THE JOB THE RIGHT WAY

IFDIF <SETTTY> <NOMESS> <
IFB <SETTTY> <
	PUSHJ	P,ERRTTY	;FIND A LINE TO TYPE MESSAGE ON
>;END IFB SETTTY

IFNB <SETTTY> <
  IFDIF <SETTTY> <CPOPJ> <
	PUSHJ P,'SETTTY		;SPECIAL ROUTINE TO SET TTY UP
  >;END IFDIF <SETTTY> <CPOPJ>
	JUMPE U,%STP		;JUST STOP JOB
>;END IFNB <SETTTY>
IFNB <MESS> <IRP MESS,<
IFIDN <MESS> <DEV> <
	PUSHJ P,ERNAM>		;PRINT DEVICE X
IFIDN <MESS> <CRLF> <
	PUSHJ P,CRLF>		;PRINT CRLF IF ASKED TO
IFIDN <MESS> <CRLFQ> <
	PUSHJ P,CRLFQ>
IFIDN <MESS> <FNAME> <
	PUSHJ P,ERFNAM>
IFIDN <MESS> <DECPRT> <
	MOVE T1,M		;GET VALUE INTO T1
	PUSHJ P,PRTDIG>
IFADF MESS,<DECPRT,CRLF,CRLFQ,DEV,FNAME>,<
	PUSHJ	P,INLMES
	ASCIZ	\'MESS\
>;END IFADF
>;END IRP MESS
>;END IFNB MESS
IFNB <TTYFIN> <
	PUSHJ P,'TTYFIN>	;IF NEED MORE PC TYPE INFO, DO IT.
IFB <TTYFIN> <
	PUSHJ P,TCLTTY>
>;END IFDIF <SETTTY> <NOMESS>
	PJRST	%STP		;AND STOP THE JOB.
>;END X MACRO DEFINITION
EXTERNAL UPTJOB,UPTETP,UPTEDV,UPTELC,UPTEL1
;NOW GENERATE ALL THE ROUTINES
XALL	;DON'T WASTE PAPER
	ERRS
SALL	;RESTORE REASONABLE LISTING
;HERE ON PAGE FAILURE. MAY BE OLD OR NEW STYLE

EXTERNAL TSTTRP,CLKTR1,COMNT1,COMNT2,PFSWE%,PFDFC%
EXTERNAL JBTPIP,JBYPGT

USRMPT::			;User mode Memory Page Trap
IFCPU (KI),<MOVE T1,%UPT+UPTUPF>
IFNCPU (KI),<MOVE T1,%UPT+UPTPFW>
	PUSHJ	P,PAGFLU##	;CHECK THE FAULT
	  JRST	USRXIT		;IN CASE HE NEEDS TRAP OR ^C OR CLOCK TICKED.
USRSPF:	XCT	UPFTBT(T1)	;DISPATCH FROM TRAP TABLE
				; HERE FOR WRITE VILOATIONS, ILL MEM REFS,
	HRL	F,M		;CONSTRUCT ILL MEM REF FAULT WORD
	MOVEM	F,%UPT+UPTUII	;PUT IN FOR PGISTS UUO
				; AND ADDRESS BREAKS.
	MOVE J,JOB
	MOVE	P1,T1		;SAVE ERROR CODE FOR LATER
	MOVEI T1,FLGMPT
	SKIPGE JBTPIP(J)	;IS THIS OLD STYLE?
	JRST COMNT2		;YES, GO TAKE CARE OF IT
	LDB T1,JBYPGT		;GETSTYLE INTERRUPT
	MOVE T2,T1		;IN CASE WE TAKE THE TRAP
	PUSHJ P,TSTTRP		;CAN WE TRAP RIGHT NOW?
	  JRST	USRSP1		;NO, TREAT AS ERROR.
	POP P,T3		;GET OLD PC
	PUSHJ P,CLKTR1		;SET FOR NEW STYLE TRAP
	JRST COMNT1		;AND GO RETURN TO USER

USRSP1:	XCT	UPFTAB(P1)	;DISPATCH TO PROPER PLACE
PAGUDE:: STOPCD (.,JOB,PAGUDE,,<Page fault - Unexpected Dispatch Error>)


UPFTBT:	 STOPCD (.,XCT,PAGUDE)	;USER CAN'T FAULT FOR EXEC PAGE
	JFCL			;ILL MEM REF
	JFCL			;WRITE VIOLATION
	JRST	ERRPIO		;PAGE I/O ERROR
	JRST	ERRDFL		;DISK FULL ON COW PAGE
	JRST	USRILR		;USER WROTE INTO COW SUPER PAGE
	JFCL			;LET USER HANDLE ADDRESS BREAK
	JRST	ERRTPL		;HARD PAGE FAIL.
SUBTTL	USRMPE - User Memory Protection Error - default handler

USRMPE::			;Called from PICON(PGFAIL) with ACs stacked
IFCPU (KI),<MOVE T1,%UPT+UPTUPF>
IFNCPU (KI),<MOVE T1,%UPT+UPTPFW>
	PUSHJ P,PAGFLU##
	  JRST	USRXIT		;IN CASE USER IS GETTING FAULT TRAP OR TYPED ^C
USRMP2::XCT	UPFTAB(T1)	;DISPATCH ON ERROR TYPE.
	 STOPCD (,XCT,PAGUDE)	;Unexpected Dispatch Error

;ERROR DISPATCH TABLE FOR USER MODE FALTS

UPFTAB:	 STOPCD (,XCT,PAGUDE)	;USER CAN'T FAULT FOR EXEC PAGE.
	JRST	USRILR		;TRADITIONAL ILL MEM REF
	JRST	ERRWRV		;WRITE VIOLATION
	JRST	ERRPIO		;PAGE I/O ERROR
	JRST	ERRDFL		;DISK FULL ON COW
	JRST	USRILR		;WROTE INTO SUPER COW PAGE
	JRST	USRABK		;ADDRESS BREAK.
	JRST	ERRPHE		;HARDWARE PAGE FAIL.
	JRST	ERRTPL		;TOO MANY PAGES LOCKED

;USER PAGE FAIL ERROR ROUTINES

USRILR:	LDB	T2,[POINT 9,(P),26] ;GET PAGE OF PC
	CAIE	T2,(W)		;SAME AS ERROR PAGE?
	JRST	ERRIMR		;NO, ILL MEM REF
	JRST	ERRPCO		;YES, PC OUT OF BOUNDS.


;HERE FOR ADDRESS BREAK

USRABK:	MOVSI	P1,PC.ADR	;SET IT NOW IN CASE TYPES DDT
	IORB	P1,%UPT+UPTPDL
	MOVEM	P1,%UPT+UPTABL	;THIS IS ADDRESS BREAK LOCATION.
	MOVE	M,%UPT+UPTABK	;GET LOCATION OF ADDRESS BREAK
	JRST	ERRABK		;GO PRINT OR TRAP
SUBTTL	Exec Memory Protection Error

EXCMPE::			;Called from PICON(PGFAIL) with ACs stacked
IFCPU (KI),<MOVE T1,%UPT+UPTXPF>	;GET THE PAGE FAIL WORD
IFNCPU(KI),<MOVE T1,%UPT+UPTPFW>
	PUSHJ	P,PAGFLE##	;TAKE USERS PAGE FAULT ROUTINE
	 JRST	KTRRT1##	;IT WAS OK, PAGE SHOULD NOW BE THERE
	XCT	EPFTAB(T1)	;AND DISPATCH.
	TRNN	F,SPFW.U	;IF EXEC PC FAULT TO EXEC PAGE FAILED,
S..IME:: STOPCD (.,STOP,IME,TYPIME,<Illegal Memory-reference from Exec>)
	HRRZ	T1,(P)		;GET FAULT PC
	CAIE	T1,CLKPC1	;IN CLKTRP?
	CAIN	T1,CLKPC2
	 JRST	ERRIIA		;YES, ILLEGAL INTERRUPT ADDRESS ERROR.
	JRST	UUOADR		;NO, BAD UUO ADDRESS ERROR.

;Routine to output data on an Ill Mem-ref Exec
IFCPU (KI),<
TYPIME:	PUSHJ	P,INLMES##
	 ASCIZ /Instruction is /
	MOVE	T1,@%UPT+UPTMUP	;Kernal Trap MUUO saved PC of failing instruction
	PUSHJ	P,HWDPNT	;Print the instruction that cause ILL MEM REF
	MOVE	T1,%UPT+UPTMUP	;Now the PC of that same instruction
	PUSHJ	P,PCP		;" at Exec PC xxxxxx"
	PUSHJ	P,INLMES##
	 ASCIZ /
Virtual page /
	LDB	T1,[POINT 9,%UPT+UPTXPF,17]
	PUSH	P,T1
	PUSHJ	P,OCTPNT
	PUSHJ	P,INLMES##
	 ASCIZ /, physical page /
	POP	P,T1
	MAP	T1,(T1)
	ANDI	T1,17777	;Only the page bits
	PUSHJ	P,OCTPNT
>  ;End IFCPU(KI)
IFNCPU(KI),<
TYPIME:	PUSHJ	P,INLMES##
	 ASCIZ /Instruction is /
	MOVE	T1,@%UPT+UPTOPP	;Get instruction old PC points to
	PUSHJ	P,HWDPNT
	MOVE	T1,%UPT+UPTOPP
	PUSHJ	P,PCP		;Print " at Exec PC xxxxxx"
	PUSHJ	P,INLMES##
	 ASCIZ /
Virtual address /
	HRRZ	T1,%UPT+UPTPFW
	PUSH	P,T1
	PUSHJ	P,OCTPNT	;Output address
	PUSHJ	P,INLMES##
	 ASCIZ /, physical address /
	POP	P,T1
	MAP	T1,(T1)
	PUSHJ	P,HWDPNT	;Output halfwords
>  ;End IFCPU(KI)
	PJRST	CRLF		;End of TYPIME

IFNCPU(KS),<
EXCABK:	TRNN	F,SPFW.U	;IF EXEC GOT ADDRESS BREAK FOR USER SPACE,
	 JRST	ADRBRK		;FOR EXEC PAGE, DON'T BOTHER USER.
	HRL	F,M		;GET FAULT INFO WORD IN F
	MOVEM	F,%UPT+UPTXII	;AND STORE FOR USER TO SEE WHEN UUO RETURNS.
	MOVSI	T1,PC.ADR
	IORM	T1,(P)
	MOVE	T1,%UPT+UPTPDL	;THIS IS ADDRESS BREAK LOCATION
	SOS	T1		;BACK UP TO LOCATION OF UUO.
	MOVEM	T1,%UPT+UPTABL	;
EXCAB1:	MOVSI	T1,UPSABK	;SET ADDRESS BREAK AT UUO LEVEL FLAG
	IORM	T1,%UPT+UPTSTS
	MOVEI	T1,UTRP		;SET SO USRXIT WILL SEE
	IORM	T1,JBTSTS(J)
	JRST	KTRRT1		;RETURN.

ADRBRK::MOVSI T1,PC.ADR		;NO, INHIBIT ADDRESS FAILURE
	IORM T1,(P)		;SO WE CAN DISMIS
	MOVE	T1,ABKSET##	;SEE IF OK TO MESS WITH ADDRESS BREAK
	CAME	T1,[WRADB %UPT+UPTABK] ;HAS IT BEEN CHANGED FOR EDDT?
	 JRST	KTRRT1		;NO, NO MESSAGE, DDT BREAKPOINT AT ADRBRK
	MOVE	T1,(P)		;GET PC OF ADDRESS BREAK
	MOVEM	T1,%UPT+UPTABL	;PUT EXEC PC FOR ABKPRT TO PRINT
				; MUST BE A %UPT SETUP, OR CAN'T GET ADDRESS BREAK
	MOVEI	T1,ABKACS	;SAVE ACS AT BREAK FOR EXEC ADDRESS SPACE
	XCTFU	<BLT T1,ABKACS+17>
	JRST	EXCAB1		;GO SET UTRP AND UPSABK AND RETURN.


;ROUTINE TO PRINT ADDRESS BREAK AT USER X, STOP JOB WITH NO ERROR
; BIT, AND RETURN. CALLED WITH PUSHJ.

ABKACS::BLOCK	20		;ACS STORED HERE ON EVA BREAK.
>  ;End IFCPU(KS)
;EXEC FAULT ERROR DISPATCH

EPFTAB:: STOPCD (,XCT,S..IME)	;Exec fault for context page or exec hiseg
	JFCL			;ILL MEM REF TO USER
	JFCL			;ILL WRITE REF TO USER
	JRST	EXCPIO		;I/O ERROR ON PAGE
	JRST	EXCDFL		;COW DISK FULL
	 STOPCD (,XCT,S..IME)	;CRASH IF EXEC WRITES INTO SUPER COW.
IFNCPU(KS),<JRST EXCABK>	;EXEC ADDRESS BREAK (KI+KL, don't know F3)
IFCPU (KS),<STOPCD (,XCT,S..IME)>;2020 does not have address break hardware
	 STOPCD (,XCT,S..IME)	;HARD PAGE FAILURE.
	JRST	EXCTPL		;CORE FULL ON MWSRPL

;ERROR ROUTINES

;EXEC PAGE I/O ROUTINE. CALLED FROM PAGFLE ERROR RETURN AND
; FROM DEFFERED I/O ERROR PROCESSING IN USRXIT. ASSUMES
; PAGE FAIL ALWAYS TURNS ON THE IGNORE ERROR BITS FOR VPS
; THAT IT REFERENCES.

EXTERNAL JBYPER,TSTKTP,ABTUUO

;ROUTINE TO PRINT PAGE I/O ERROR OR GIVE RETURN, IN WHICH CASE
; CALLER WILL CAUSE TRAP.

EXCPIO::PUSHJ	P,CHKABT	;ALLOW MONITOR TO CLEAN UP.
	HRRZS	W		;CLEAR LH
	CAILE	W,777		;IF EXEC PAGE,
	JRST	ERRPIO		;NO TRAPS, PLEASE
	LDB	T1,JBYPER	;GET PAGE I/O ERROR CHANNEL
	JUMPE	T1,ERRPIO	;USER NOT ENABLED FOR IT
	PUSHJ	P,TSTKTP	;OK, CAN HE TAKE IT NOW?
	  JRST	[MOVEI T1,ABTUUO ;ROUTINE TO BACKUP PC
		 HRRM T1,(P)	;PUT ONTO RETURN PLACE
		 JRST KTRRT1]	;AND LET CALLER TAKE THE TRAP
	JRST	ERRPIO		;EXEC PAGE ERROR.

EXCPDL::MOVEM	P,XXXPDL	;Save bad stack pointer
	MOVEI	P,XXXPDL	;Point to 1-word stack
	 STOPCD (.,STOP,EPDLOV,,<Exec Push Down List Overflow>)
XXXPDL:	BLOCK	2		;Saves old P, and 1 PC

EXCDFL:	PUSHJ	P,CHKABT	;CLEAN UP IF NECESSARY
	PJRST	ERRDFL		;AND TO DO THE ERROR.

EXCTPL:	PUSHJ	P,CHKABT	;CLEAN UP
	JRST	ERRTPL		;AND GO DO THE ERROR.
ADRERR::PUSHJ	P,CHKAB1	;DO JBTABT ROUTINE IF THERE
	JRST	ERRADC		;AND DO ADDRESS CHECK.

EXTERNAL JBTABT,ABTCPL

UUOADR::PUSHJ	P,CHKABT	;CLEAN UP IF NECESSARY.
	JUMPE F,ERRIMU		;ILLEGAL UUO ADDRESS
	MAP T1,DEVNAM(F)
IFCPU (KI),<TRNE T1,MAP.FL>
IFNCPU (KI),<TLNE T1,PFW.H		;FORGET IT IF HARD ERROR
	JRST ERRIMU
	TLC T1,PFW.A+PFW.W	;MAKE EASY TO SEE IF ONE IS OFF
	TLNE	T1,PFW.R	;IF UNPAGED REF, SKIP
	TLNN	T1,PFW.A+PFW.W	;PAGED. IF A OR W WAS OFF, DIE.
	JRST	.+2>		;UNPAGED OR A AND W WERE BOTH ON.
	JRST ERRIMU		;BAD IF DEVNAM(F) NOT LEGAL ADRESS
	MAP T1,@PJOBN
IFCPU (KI),<TRNE T1,MAP.FL>		;ALSO CHECK THAT LDB PJOBN WILL NOT FAULT
IFNCPU (KI),<TLNE T1,PFW.H		;IF HARD FAILURE, FORGET IT
	JRST ERRIMU
	TLC T1,PFW.A+PFW.W
	TLNE T1,PFW.R
	TLNN T1,PFW.A+PFW.W
	JRST	.+2>
				;MUST BE PAGED WITH A OR W OFF.
	JRST ERRIMU		;NOT FAULT
	LDB T1,PJOBN
	CAMN T1,JOB		;POINTS TO CURRENT JOB?
	JRST ERRADC		;YES, PROBABLY REAL DDB ADDRESS
	JRST ERRIMU		;NO, JUST SAY ILL MEM REF IN UUO

;ROUTINE TO SET UP F AND J FOR CALLER, AND CALL JBTABT ROUTINE
; IF ONE IS SETUP. CLEARS JBTABT CELL.
; T1 SETUP WITH OLD CONTENTS OF JBTABT CELL FOR THE FRAME.
; JBTABT ROUTINES MUST PRESERVE W AND M.

CHKABT:	UMOVE	F,F		;GET F AT TIME OF ERROR (OR MAYBE USER'S F?)
CHKAB1:	MOVE	J,JOB
	SETZ	T1,
	EXCH	T1,JBTABT(J)
	PJUMPE	T1,ABTCPL	;IF NO JBTABT ROUTINE, JUST GIVE CONTEXT PAGE LOCKS UP
	PUSHJ	P,(T1)		;CALL JBTABT ROUTINE
	MOVE	J,JOB		;IN CASE JBTABT ROUTINE SMASHED IT
	PJRST	ABTCPL		;THEN GIVE UP LOCKS. (JBTABT ROUTINE MAY
				; NEED THE LOCK TO FIX UP STUFF)


;DISK FULL WHEN USER WROTE IN COPY ON WRITE PAGE.
; T1 HAS ERROR CODE, 1 = DISK FULL. OTHERS, CRASH.

EXTERN CRDFL%


NOCREA::HLRZ	M,T1		;GET PAGE NUMBER IN M
	ANDI	M,777		;JUST 9 BITS WORTH
	LSH	M,^D9		;TURN INTO LOCATION (LIE A LITTLE)
	HRRZS	T1		;JUST ERROR CODE IN RH
	CAIE	T1,CRDFL%	;DISK FULL?
	 STOPCD (.,JOB,PAGNCR,,<Page Fault, cannot create COW page>)
	JRST	ERRDFL		;DISK FULL.
SUBTTL	Illegal UUO
;CALLED AT UUO LEVEL ONLY

UUOMNR::MOVE T2,PDNMUP##(P)	;GET ADDRESS OF UUO
	TLNN T2,PC.USR		;THIS IS STILL A KLUDGE BECAUSE OF NON
				;JUMPS. GOES AWAY WITH SWAPABLE UPT
	 STOPCD (.,JOB,UUOIPF,,<UUO with Illegal PC Flags>)
UUOERR::JRST	ERRILU		;SAY ILLEGAL UUO
;UUO ERROR-MONITOR ERROR AT UUO LEVEL
;CALLED AT UUO LEVEL ONLY
XP UUOER1,ERRUUE

;ILLEGAL INSTRUCTION
;HALT INSTRUCTION IS A SPECIAL CASE WHICH STOPS JOB BUT
;THE USER MAY CONTINUE FROM IT(EFFECTIVE ADR.)
;CALLED AT UUO LEVEL WITH A JRST

EXTERNAL HOLD0,HOLD1

ILLINS::MOVE	P1,PDNMUP(P)
	TLNN	P1,PC.USR	;MAKE SURE IN USER MODE
	 JRST	EMUERR		;Exec mode uuo error  STOPCD;;ILLINS+2
	HLRZ	T1,M		;ILLEGAL OPCODE
	CAIN	T1,(JRST 4,)	;IS IT A HALT?
	 JRST	[HRRM M,%UPT+UPTPDL ;YES, STORE E OF HALT ON STACK FOR CONTINUE
		 JRST ERRHLT]	;AND GO HALT HIM.
	JRST	ERRILI		;SAY ILL INST


;HERE ON AN EXEC MODE UUO ERROR

LUUOPC::0			;JSR here from EPT+41 when LUUO detected
	EXCH	T1,LUUOPC	;Save T1, get PC
	MOVEM	T1,%UPT+UPTMUP	;Save where MUUOs store their PC
IFCPU (KI),<MOVE T1,EPT##+40>	;Get LUUO from EPT
IFNCPU(KI),<MOVE T1,40>		;Get LUUO from virtual address 40
	MOVEM	T1,%UPT+UPTMUU	;Save where MUUOs store their opcode
	MOVE	T1,%UPT+UPTMUP	;Restore contents of T1
	EXCH	T1,LUUOPC	;Continue at EMUERR

;In most cases where memory fails, an interrupt will occur, causing UIL stopcode

EMUERR:	CONSZ	PI,PI.IPA	;Any interrupts in progress?
S..UIL:: STOPCD (.,CPU,UIL,,<Uuo at Interrupt Level>)	;;ILLINS+2
S..EUE:: STOPCD (BUGSTP,DEBUG,EUE,,<Exec Uuo Error>)	;;INSSIM+2=ILLINS+2
;ROUTINE FOR HUNG IO DEVICE
;CALL	MOVE F,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ P,DEVHNG
;ASSUMES THAT DEVICE SERVICE ROUTINE HAS BEEN CALLED AND DEVIOS
; WILL NO LONGER BE CHANGED BY INTERRUPT LEVEL.

INTERNAL DEVHNG
EXTERNAL SETIOD

DEVHNG:	MOVE	S,DEVIOS(F)	;GET S
	TLZE	S,IOW		;IS HE IN IO WAIT?
	PUSHJ	P,SETIOD	;YES, WAKE HIM UP
	TLO	S,IOHNG		;TELL WSYNC TO NEVER RETURN
	TRZ	S,IOACT		;TURN OFF IOACT
	MOVEM	S,DEVIOS(F)	;STORE BACK
	POPJ	P,		;AND JOB WILL START AT ERRHDV.


;ROUTINE TO HALT A JOB WHEN A DEVICE IS NOT READY FOR I/O
;CALLED FROM XXXSER AT M LEVEL
;CALL	MOVE F,ADDR. OF DEV. DDB
;	PUSHJ P,HNGSTP

HNGSTP::PUSH P,J
	PUSH P,S
	PUSH P,F
	PUSH P,P1		;P1 USED FOR PRINTING PC
	LDB J,PJOBN##
	PUSHJ P,GETOPR		;GET OPR LINE
	MOVE	F,-1(P)		;GET ORIGINAL F BACK FOR PRINTING AND STORING NAME
	JUMPE U,HNGSTW		;NO LINE, IGNORE
	PUSHJ P,INLMES
	ASCIZ /
problem on /
	PUSHJ P,ERNAM
	PUSHJ P,INLMES
	ASCIZ / for job /
	PUSHJ P,PJOB##		;NOW THE JOB
	PUSHJ P,CRLF
HNGSTW:	MOVSI T2,FLGHNG		;SET TO FLAG HUNG DEVICE
	LDB T1,JBYHNG		;GET INTERRUPT CHANNEL
	PUSHJ P,TSTKOT		;TEST AND TAKE OLD TRAP
	 JRST ABTUUO		;TOOK TRAP
	JRST	ERRDOP		;DEVICE OPER ACTION REQUESTED ERROR

;HERE TO STOP THE JOB ON OPER ACTION REQUESTED. ACS STILL ON STACK,
; MAYBE LINE, MAYBE NOT.
HNSTOP:	MOVEI T1,JDCON
	IORM T1,JBTSTS(J)
	PUSHJ	P,STOP1		;STOP THE JOB CONTINUABLY
	POP P,P1		;RESTORE SMASHED REG USED FOR PC
	POP P,F
	POP P,S
	POP P,J
	JRST WSCHED		;RESCHEDULE
;MONITOR JOB STARTED UP BY SWAPPER CONTEXT PAGE I/O ERROR CODE.

	EXTERN TPOPJ,JBYHNG,TSTKOT,ABTUUO
	EXTERN ESTOP,MONSTR

ERRSWP::MOVEI	T2,ESTOP	;WHERE TO STOP
	JSP	T1,MONSTR	;SETUP ACS, PDL, CLEAR INTERRUPTS
	MOVEI	T1,ALRACT
	IORM	T1,ALR620
	PUSHJ	P,GETOPR	;NOW PRINT ON OPR CONSOLE
	PUSHJ	P,ERROP1
	PUSHJ	P,INLMES
	ASCIZ	"context page I/O error"
	PJRST	ERRCIO		;GO DO THE RIGHT STUFF FOR THE FRAME.
COMMENT ;@@SUBROUTINE ERRSET/ERRSES/ERRSEX/HLTTRP
@@PURPOSE SETUP J TO RELEVANT FRAME NUMBER, STORE EXIT STATUS IN THE
CONTEXT PAGES OF THE FRAME.
HALT COMMAND CALLS AT HLTTRP TO INTERRUPT PARENT.
@@ENTRY	CONTEXT PAGES AT %UPT,%UPS,%UPX AT ENTRIES ERRSET,ERRSES,ERRSEX
	P1/PC OF ERROR
@@ACCUM T1-T4 (MUST SAVE SAME ACS THAT STOP1 DOES)
@@EXIT NON-SKIP IF NO MESSAGE TO BE PRINTED
	SKIP IF NO TRAPHANDLER OR ENABLED PARENT FOR CONDITION, PRINT MESSAGE
@@RESTRICTIONS ONLY CALLED AT UUO LEVEL.
@@FUNCTION SETUP J FROM JOB IF CALLED AT ERRSET. CHECK J, CRASH IF
OUT OF BOUNDS.
INCREMENT EXIT COUNT IN UPT, STORE PC, LAST UUO PC, AND IF
ENABLED PARENT OR TRAPHANDLER, FIRE UP SOFTWARE INTERRUPT IN
THEM.
@@;


EXTERNAL UPTJOB,PRQM,CPOPJ1,JOBMAX,JBYEXC,IPOPJ1,TAKTRP,JBTSTS
EXTERNAL UPTEPC,UPTEUP,UPTECN,JBTFTR

ERRSES:	MOVEI	T4,%UPS		;CONTEXT PAGES IN %UPS
	JRST	ERRSE0
ERRSEX:	SKIPA	T4,[%UPX]	;CONTEXT PAGES IN %UPX
ERRSET:	MOVEI	T4,%UPT		;CONTEXT PAGES IN %UPT
ERRSE0:	MOVE	J,UPTJOB(T4)	;GET CURRENT JOB NUMBER IN J
	SKIPE	J		;NULL JOB DOESN'T GET ERRORS.
	CAILE	J,JOBMAX	;LEGAL?
	 STOPCD (.,STOP,UUOEIJ,,<Error with Illegal Job number>)
	MOVEM	P1,UPTEPC(T4)	;REMEMBER IT
	MOVE	T1,UPTPDL(T4)	;GET PC OF LAST UUO
	MOVEM	T1,UPTEUP(T4)	;LAST TOP LEVEL UUO OR FAULT PC
	SETZ	U,		;NO LDB YET - MAYBE TTY FINDING ROUTINE WILL SET IT UP, MAYBE NOT.
				; ZERO IT NOW SO KJSTOP WON'T BE FOOLED
	AOS	UPTECN(T4)	;INCREMENT COUNT OF TIMES JOB EXITED.
HLTTRP:	PUSH	P,J		;SAVE CALLER'S J
	LDB	J,PRNTBP(J)	;GET CALLER'S PARENT, IF ANY
	JUMPE	J,IPOPJ1	;IF NONE, JUST DO MESSAGE STUFF
	LDB	T1,JBYEXC	;GET INTERRUPT ASSIGNMENT
	JUMPE	T1,HLTTR1	;JUMP IF INT NOT DESIRED AT PRESENT
	PUSHJ	P,TAKTRP	;ELSE GIVE PARENT THE TRAP
	POP	P,J
	POPJ	P,		;AND GIVE CALLER NON-SKIP - JUST STOPS THE FRAME.
HLTTR1:	MOVEI	T1,EXCFLG
	IORM	T1,JBTSTS(J)	;SET THIS FOR THE PARENT
	JRST	IPOPJ1		;GET J OFF STACK AND RETURN

; Routine to print frame exit error code (octal or SIXBIT), followed by
; "at user xxxxxx"

FEXPRT:	MOVE	T2,%UPT+UPTELC	;Pick up error code
	TLNE	T2,-1		;Skip if octal
	  JRST	[PUSHJ	P,PRNAME
		 JRST	FEXPR1]
	MOVEI	T1,(T2)		;Set up for octal type-out
	PUSHJ	P,OCTPNT
FEXPR1:	PJRST	UUOPCP		;Remainder of message


COMMENT ;@@SUBROUTINE ERRTTY
@@PURPOSE FIND AN LDB TO PRINT MESSAGE ON
@@ENTRY J/FRAME NUMBER
@@ACCUM ??
@@EXIT U SETUP
@@;

EXTERNAL TTYERP

ERRTTY:	PUSH	P,F		;DON'T SMASH F
	PUSHJ	P,TTYERP	;GET F AND U SETUP
	  JRST	ERRTT1		;MAYBE HAVE TO GET OPR LDB
	POP	P,F		;RESTORE F
	PJRST	CRLF		;PRINT CRLF AND RETURN.

ERRTT1:	POP	P,F		;GET F BACK
	LDB	T1,PRNTBP(J)	;IF HAS NO PARENT,
	JUMPE	T1,ERROPR	;THEN GET OPR'S LDB OR CTY.
	SETZ	U,		;MAKE SURE NO MESSAGE COMES OUT
	POPJ	P,		;AND RETURN SILENTLY.

ERROPR:	MOVEI	T1,ALRUSR	;TELL NETWORK LOGGER OPR MESSAGE
	IORM	T1,ALR620
ERROP1:	PUSHJ	P,INLMES
	ASCIZ/?
?error in job /
	PUSHJ	P,PJOB##	;PRINT JOB NUMBER
	PJRST	PRQM		;PRINT QUESTION MARK FOR HISTORICAL REASONS
				; (BATCH AND SCRIPT) AND RETURN.
COMMENT ;@@SUBROUTINE ERRFNU
@@PURPOSE FOR ERRORS THAT DON'T PRINT MESSAGES ON OPR CONSOLE IF JOB
IS DETACHED.
@@ENTRY J/JOB
@@ACCUM PRESERVES F
@@EXIT RETURNS U EITHER 0 IF DETACHED, OR LDB ADDRESS OF WHERE TO TYPE MESSAGE
@@;

ERRFNU:	PUSH	P,F		;THIS IS ALMOST RIDICULOUS
	PUSHJ	P,TTYFNU
	POP	P,F
	POPJ	P,		;IN CASE F HAS DDB ASSOCIATED WITH ERROR.
COMMENT ;@@SUBROUTINE EXIFNU
@@PURPOSE CALLED TO FIND TTY LDB IF ANY IF CALLER NOT DIRECTLY ENABLED
FOR EXIT TRAPPING.
@@ENTRY	J/JOB NUMBER
@@ACCUM T1-T4,F,U
@@EXIT U CONTAINS 0 OR LDB ADDRESS.
@@FUNCTION FIND LDB FOR TTY, IF ANY, AND IF THERE IS ONE, WAIT
FOR ANY CURRENT OUTPUT TO COMPLETE AND THEN RETURN WITH LDB ADDRES IN U.
IF THERE IS NO LDB, AND A PARENT (OR LATER, A TRAPHANDLER FRAME) EXISTS,
JUST RETURN WITH U/0, ERROR ROUTINE WILL JUST STOP THE JOB.
IF THERE IS NO LDB AND NO PARENT OR TRAPHANDLER, IF DISCONNECT STATUS
IS CONTINUE OR DETACH, JUST WAIT FOR ATTACH TO HAPPEN.
IF DISCONNECT STATUS IS OTHER THAN THE ABOVE, CAUSE THE JOB TO BE
KILLED BY CALLING MONHNG, CLEAR U SO ERROR ROUTINES DON'T ATTEMPT
TO PRINT MESSAGES, AND RETURN.
@@;

EXTERNAL IFDET,PVYHNG,TTYFUW,MONHNG

EXIFNU:	PUSHJ	P,IFDET		;GET DDB, MAYBE LDB ADDRESS
	  POPJ	P,		;IS ATTACHED, RETURN WITH U SETUP.
	LDB	T1,PRNTBP(J)	;DOES IT HAVE A PARENT?
	JUMPN	T1,CPOPJ	;IF SO, DON'T DO ANY KILLING OR WAITING STUFF
;	DOES IT HAVE A TRAPHANDLER FOR EXITS?
	LDB	T1,PVYHNG	;HAS NO PARENT. SEE WHAT DISCONNECT MOE IS
	CAIE	T1,.PVHDT	;IF DETACH OR
	CAIN	T1,.PVHCN	;CONTINUE ON DISCONNECT,
	PJRST	TTYFUW		;WAIT UNTIL SOMEONE ATTACHES.
	MOVE	T1,J		;NO, DO WHAT DISCONNECT WOULD HAVE DONE
	PUSHJ	P,MONHNG
	SETZ	U,		;CLEAR THIS SO NO MESSAGES COME OUT
	POPJ	P,		;AND RETURN.
COMMENT ;@@SUBROUTINES ERRSCP/ERRSCD
@@PURPOSE ERRSCP -  PRINT FOR LOCATION(PAGE ON KI) X, THEN ERRSCD
	ERRSCD - PRINT AT USER X OR UUO AT USER/EXEC X
@@ENTRY	P1/PC OF ERR
	M/LOCATION IF CALLED AT ERRSCP
	U/LDB TO TYPE ON
@@ACCUM ?
@@EXIT ALWAYS NON-SKIP
@@;

ERRSCP:
IFCPU (KI),<
	PUSHJ	P,INLMES
	 ASCIZ / for page /
	LDB	T1,[POINT 9,M,26] ;GET PAGE FROM M
	PUSHJ	P,OCTPNT
			;AND FALL INTO ERRSCD
>;END IFCPU (KI)
IFNCPU (KI),<
	PUSHJ	P,INLMES
	 ASCIZ / for location /
	HRRZ	T1,M	;GET FULL LOCATION
	PUSHJ	P,OCTPNT
			;AND FALL INTO ERRSCD
>;END IFCPU (KI)

ERRSCD:	MOVE	T2,P1	;GET PC INTO T2 FOR PCP
	TLNE	T2,PC.USR	;USER MODE
	JRST	ERRSC1		;PRINT PC AND STOP TTY
ERRSCU:	PUSHJ	P,INLMES	;NO, PRINT WHERE UUO IS
	 ASCIZ /; UUO/
	MOVE	T2,%UPT+UPTPDL
	SUBI	T2,1
ERRSC1:	PUSHJ	P,PCP		;PRINT PC
	PJRST	TCLTTY

;PRINT "AT USER <C(P1)-1>" OR ";UUO AT <C(P1)-1>

ERRSCM:	SOJA	P1,ERRSCD
SUBTTL	New externals used by STOPCODE processor

REPEAT 0,<
CCPNAM		;Name of program to copy crash ('CRSCPY' or 'CRSHID')
DATE		;Universal date/time  (18-Nov-1858, 1/3 second resolution)
JBTPRG		;Table with name of file that program came from (not JBTNAM)
SCCTAB,SCCTBL	;Stopcode count table and length
SCLTAB		;Table with LH=ticks until next check, RH=limit
.CPxxx		;CPU data block for this CPU (equated to .C0xxx)
%SYSxx		;System-wide errors, GETTAB table .GTSYS=51
DEBUGF		;Debugging flags, whether or not to dump/reload
DIECDB		;Pointer to CPU Data Block (for FILDDT to set paging)

REBOOT	COMMON		dump and reload the system
RCDSTB	COMMON		read CPU and device status blocks
TYPCSB	COMMON		type CPU status block
BUGDMP	COMMON (MONBTS)	copy all of physical memory to SYS:CRASH.EXE
FLTCHK	VMSER  (PICON)	check if bits in T1 indicate a potential page fault
CSDMP	KLSER  (COMMON)	do a cache sweep on a KL
SKPMRN	DTESER (COMMON)	skip if master PDP-11 is running on KL
SVPPC	DTESER (SCNSER)	save protocol status, start secondary
CTYWAT	SCNSER		output to CTY, wait, with PI off
CCTYO	SCNSER		output character to TTY chunk (LDB in U)
FRCSET	SCNSER		make PRNAME store into input buffer of the FRCLIN
CONMSG	TTDINT (SCNSER)	output message to all TTYs (T1 has addr of ASCIZ)
PRTDDB	COMCON		type DEVICE:FILE.EXT[P,PN] when F points to DDB
> ;End of REPEAT 0
SUBTTL	STOPCD -- DIE and GOBACK routines

;Routine to recover/reload after an internal system error.
;Called by the STOPCD macro with PUSHJ P,DIE

DIE::	AOSE	.CPDWD##	;Interlock stopcode processor
	 STOPCD (.,HALT,DIEREH,,<Recursion in Error Handler>)
	POP	P,.CPCPC##	;Store continue PC
	CONI	PI,.CPCPI##	;Save PI status
	CONO	PI,PI.TFP+177	;Turn off all PI channels
	MOVEM	17,CRSHAC##+17	;Store current ACs
	MOVEI	17,CRSHAC##	; where FILDDT can find them,
	BLT	17,CRSHAC##+16	; in a system-wide table
	MOVEI	17,PREVAC##	;Place to store previous context ACs
	XCTFU	<BLT 17,PREVAC+17>;Store them after CRSHAC
	MOVE	17,CRSHAC##+17	;Restore 17, then go save all ACs in CDB
	JSR	.CPSVA##	;Save all AC blocks, make .CPACA point to them

	MOVE	T1,CRSHWD##	;Get contents of location 30
	MOVEM	T1,SAV30##	;Save before is gets modified
	MOVE	P,.CPEPD##	;Set up error PDL
	PUSHJ	P,RCDSTB##	;Record CPU and device status blocks
	SKIPN	T1,.CPCPC##	;Get PC of stopcode
	 MOVEI	T1,DIEBPC+1	;If zero, point at "Bad PC" stopcode
	SUBI	T1,1		;Back up incremented PC
	MOVEM	T1,.CPSPC##	;Store stop PC
	MOVE	M,0(T1) 	;Get the XCT instruction
	TLC	M,(XCT) 	;Clear these bits
	TLNE	M,777740	;Make sure it was an XCT instruction
	 MOVEI	M,@DIEBPC	;If not, point to "Bad PC" data
IFCPU (KL),<
	PUSHJ	P,CSDMP##	;Dump all of cache to physical memory
	PUSHJ	P,SKPMRN##	;Skip if master PDP-11 is running
	 STOPCD (.,HALT,DIEMNR,,<Master PDP-11 not running>)
>  ;End of IFN FTKL10
				;M points to start of literal block
	PUSHJ	P,DIE1		;Output STOPCODE, resume keep-alive via POPJ
				;.CPCPC may be modified

RESRET:
;*;	PUSHJ	P,DAEEST##	;Tell DAEMON about the stopcode
	MOVEI	T1,177		;All PI bits
	AND	T1,.CPCPI##	;Only the ones that were on
	IORI	T1,PI.TNP	;Turn on PI bit
	MOVEM	T1,.CPCPI##	;Save for CONO
	HRLZ	17,.CPACA##	;Where to restore the AC's from
	BLT	17,17		;Restore them all
	SETOM	.CPDWD##	;Allow further STOPCD's
;*;		.CREF DF.SBD	;(Cref the use of the sign bit)
	SKIPGE	DEBUGF##	;Is system being debugged?
	 XCT	.CPDDT##	;Yes, jump to DDT (use GOBACK$G to continue)
DIECON::
GOBACK::PUSH	P,.CPCPC##	;Set up continue PC
	SETZM	.CPCPC##	;No longer processing crash
	SETZM	SYSSNP##	;Disable the snapshot program
	CONO	PI,@.CPCPI##	;Turn on the PI system
	POPJ	P,		;Return from DIE
SUBTTL	STOPCD -- Process tables


COMMENT @
"Recent findings have show bugs that are adaptive and intellegent.
The study of such bugs has been hampered by the probablity that these
bugs themselves have bugs, producing erratic buglike behavior.  If
this is indeed true, it provides the first demonstration that Murphy's
Law is recursive, that it can invoke itself."

IEEE Spectrum, September 1984
@

DIEBPC:: STOPCD (.,STOP,DIEBPC,,<Bad PC in DIE>)

;Tables for driving stopcode processing

S%FAST==1B0	;Flag for EVENT and INFO (don't switch to secondary protocol
S%NDDB==1B1	;Flag to suppress DDB/JOB typout
S%CSB== 1B2	;Flag to output CPU Status Block
S%EVNT==1B3	;Flag to indicate EVENT (as opposed to INFO or other stopcode)
S%PION==1B4	;Flag to indicate that PI channel 1 should be on

DEFINE STPTAB,<;;Name, routine, CPU counter, GETTAB counter, flags
STP	HALT,RELOAD,0,0,
STP	STOP,RELOAD,0,0,
STP	JOB,ZAPJOB,.CPSNJ##,%SYNJS##,<PION>
STP	DEBUG,BUGCHK,.CPSND##,%SYNDS##,<PION>
STP	CPU,CPUSTP,.CPSNC##,%SYNCS##,<CSB>;;CPU or hardware failure
STP	INFO,INFSTP,.CPSNI##,%SYNIS##,<FAST,NDDB,PION>
STP	EVENT,INFSTP,.CPSNI##,%SYNIS##,<FAST,NDDB,EVNT,PION>
STP	DSKCLN,DSKSTP,0,0,;;	;Set flag to do full DSKCLN and then RELOAD
>

	DEFINE STP(TYP,RTN,CPLOC,SYLOC,FLAGS),<
	IFN <.-STPTYP>-S$'TYP,<PRINTX ? Stopcode type TYP is out of order>
	SIXBIT	\TYP\	>

STPTYP: STPTAB
  STPMAX==.-STPTYP-1	;Maximum legal stopcode type

	DEFINE STP(TYP,RTN,CPLOC,SYLOC,FLAGS),<
	ZZ==0
	IRP FLAGS,<ZZ=ZZ!S%'FLAGS>
	EXP	ZZ ! RTN	;TYP
	PURGE ZZ
	>

PRCTAB: STPTAB

	DEFINE STP(TYP,RTN,CPLOC,SYLOC,FLAGS),<
	XWD	SYLOC,CPLOC	;TYP>

SCTTAB: STPTAB
SUBTTL	STOPCD -- Routine to output the stopcode information

;Here for STOPCODE processing which might need to be run in secondary protocol
;The Keep-Alive function is disabled during typeout, restored via POPJ

;1) Determine type of stopcode
;2) If not INFO or EVENT, disable keep-alive checking (secondary protocol)
;3) Store stopcode type, name, PC, etc in the GETTAB table (for FILDDT & SYSTAT)
;4) If not INFO or EVENT, set output routine to one that does not use interrupts
;5) For EVENT, output "%% Event".  For all others, output 10 bells and "?STOPCD"
;6) Output date and time
;7) For STOP, JOB, and DEBUG, output job status and DDB
;8) If optional typeout routine is provided, call it with original ACs
;9) For STOP, JOB, and DEBUG, output CPU status
;10) Call RELOAD, ZAPJOB, BUGCHK, or CPOPJ depending on stopcode type
;11) If system is to be continued, check for too many stopcodes per minute
;12) Restore primary protocol and keep-alive functions on POPJ

DIE1:	HLRZ	T1,0(M)		;Get opcode (should be PUSHJ P,DIE)
	TRZ	T1,37		;Clear index and indirect fields
	CAIE	T1,(XCT)	;Is it a second XCT in a row?
	 JRST	DIE1A		;No, M points to literal block from macro
	MOVE	T1,0(M)		;Yes, get the XCT instruction
	MOVEM	T1,.CPSTY##	;Save outside of the ACs
	MOVE	T1,.CPACA##	;Restore ACs
	MOVE	M,M(T1)		; in case of XCT TABLE(T1)
	MOVE	T1,T1(T1)
	MOVEI	M,@.CPSTY##	;Get address this XCT points to
	JRST	DIE1		;Check for multiple XCT in a row

;0(M)=PUSHJ P,DIE		;Format of the literal block
;1(M)=SIXBIT /NAME/		;Unique name or /?STOP?/
;2(M)=1B0+<TYPE_^D18>+CONTINUEADDRESS
;3(M)=DATA,,TYPEOUTADDRESS	;Optional, present if 1B0 set in 2(M)

DIE1A:	LDB	T1,[POINT 4,2(M),17] ;Get stopcode type
	CAIL	T1,S$STOP	;Within range
	CAILE	T1,STPMAX
	 MOVEI	T1,S$STOP	;No, don't make things worse
	MOVEM	T1,.CPSTY##	;Save as stopcode type
;*;		.CREF S%FAST
	MOVSI	T2,(S%PION)	;Bit to test
	TDNE	T2,PRCTAB(T1)	;Ok to keep channel 1 on?
	 CONO	PI,PI.TNP+PI.CO1;Turn on channel 1 (to keep KEY620 updated)
	SKIPL	PRCTAB(T1)	;Is this a fast stopcode (INFO or EVENT)?
	 PUSHJ	P,SVPPC##	;No, save primary protocol, disable keep alive

COMMENT ~  Note: for TOPS-10 only ($U implemented in FILDDT version 40 or later)
 The following code is explicitly to make it easier to automatically map in
 a crash.  The usual sequence would be to use a DDT file which would say:
 	DIECDB[ $Q-.CPCDB+.CPEPT[ $Q'1000$U	Set up EPT to match dead CPU
 	SPTTAB$6U				Set up SPT mapping (KL paging)
 	.CPACA[ $Q$5U				Set up ACs active at the time
~  ;End of COMMENT

	MOVE	T1,.CPSLF##	;Get physical pointer to the CDB
	MOVEM	T1,DIECDB##	;Save where FILDDT can find it
	MOVE	T1,1(M) 	;Get name of stopcode
	MOVEM	T1,.CPSNM##	;	CDB
	MOVEM	T1,%SYSNM##	;	GETTAB
	MOVE	T1,.CPSPC##	;Get PC of STOPCD macro (points to XCT)
	MOVEM	T1,%SYSPC##	;	GETTAB
	MOVE	T1,.CPSTY##	;Get stopcode type
	MOVEM	T1,%SYSTY##	;	GETTAB
	MOVE	T1,DATE##	;Get universal date/time
	MOVEM	T1,.CPSDT##	;	CDB
	MOVEM	T1,%SYSDT##	;	GETTAB
	MOVE	T1,.CPCPN##	;CPU number
	MOVEM	T1,%SYSCP##	;	GETTAB
	HRRZ	T1,2(M) 	;Get continuation address
	CAIN	T1,1		;Is it <.+1> ?
	 AOS	T1,.CPCPC##	;Yes, make for a skip return
	SKIPE	T1		;If nonzero,
	 MOVEM	T1,.CPCPC##	; set the saved PC to the continue address

	PUSH	P,.CPTOA##	;Save CTY typeout address
	MOVE	T1,.CPSTY##	;Get stopcode type
	SKIPN	DINITF##	;Always use CTYWAT if still in once-only
;*;		.CREF S%FAST
	 SKIPL	PRCTAB(T1)	;Is it an INFO or EVENT stopcode?
	  SKIPA	T2,[CTYWAT##]	;No, use non-interrupt output routine
	   MOVEI T2,DIETYO	;Yes, use CTY LDB for fast stopcodes
	MOVEM	T2,.CPTOA##	;Tell SCNSER to use this for INLMES
	MOVE	T1,PRCTAB(T1)	;Get the control bits for this type of STOPCD
	TLNN	T1,(S%EVNT)	;Is this an EVENT?
	 JRST	DIE3		;No, a real STOPCODE
	PUSHJ	P,INLMES##	;Yes, do not ding bell for an event
	 ASCIZ /
%% Event /
	MOVE	T2,.CPSNM##	;Get stopcode name
	PUSHJ	P,PRNAME	;Output SIXBIT
	PUSHJ	P,INLMES##
	 ASCIZ / at /
	PUSHJ	P,GMTTIM##	;Output date, time of day GMT, CRLF
	JRST	DIE4		;Common code

;?JOB stopcode UUOXWL(176070) at 24-JUL-85 12:34:56 GMT
;System C33, hardware VV, KL #1081, C33-P034/N15  7-31-85

DIE3:	MOVEI	T2,^D10		;Send 10 bells
	PUSHJ	P,BELLEN
	PUSHJ	P,INLMES##	;CRLF and "?"
	 ASCIZ /


?/
	MOVE	T1,.CPSTY##	;Get type
	MOVE	T2,STPTYP(T1)	;'STOP', 'JOB', 'DEBUG', 'INFO'
	PUSHJ	P,PRNAME
	PUSHJ	P,INLMES##
	 ASCIZ / stopcode /
	MOVE	T2,.CPSNM##	;Get stopcode name
	PUSHJ	P,PRNAME	;(up to 6 characters)
	PUSHJ	P,INLMES##
	 ASCIZ /(/
	HRRZ	T1,.CPSPC##	;Get stop PC
	PUSHJ	P,OCTPNT
	PUSHJ	P,INLMES##
	 ASCIZ /) at /
	PUSHJ	P,GMTTIM##	;Output date, time of day GMT, CRLF
	PUSHJ	P,INLMES##
	 ASCIZ /System /
	MOVE	T2,.CPSNO##	;SYSNO this monitor was built for
	PUSHJ	P,PR6BIT
	PUSHJ	P,INLMES##
	 ASCIZ /, hardware /
	MOVE	T2,.CPLOG##	;'AA', 'BB', etc
	PUSHJ	P,PR6BIT
	PUSHJ	P,INLMES##
	 ASCIZ /, /
	HLLZ	T2,.CPCPU##	;'KL', 'KI', 'KS', 'F3'
	PUSHJ	P,PR6BIT
	MOVEI	T3,"#"
	PUSHJ	P,COMTYO##
	HRRZ	T1,.CPCPU##	;CPU serial number monitor was built for
	PUSHJ	P,RADX10
	PUSHJ	P,INLMES##
	 ASCIZ /, /
	MOVEI	T1,CONFIG##	;Full system number
	PUSHJ	P,CONMES##
	PUSHJ	P,INLMES##
	 ASCIZ /, /
	MOVEI	T1,SYSDAT##	;System build date
	PUSHJ	P,CONMES##
	PUSHJ	P,INLMES##
	 ASCIZ /, /
	MOVE	T2,CNFSID##	;Configuration system ID number
	PUSHJ	P,PRNAME
	PUSHJ	P,CRLF##

DIE4:	MOVE	T1,.CPSTY##	;Stopcode type again
	MOVE	T1,PRCTAB(T1)	;Get control bits
	TLNE	T1,(S%NDDB)	;Suppress DDB and job typeout?
	 JRST	NODDB
;If a job was running, output job then DDB, blame STOPCD on the job
;If at interrupt level, output DDB then job, blame STOPCD on the device
	MOVEI	S,PI.IPA	;Get the "PI's ON" mask
	AND	S,.CPCPI##	;Set S nonzero if any interrupts in progress
	MOVE	J,.CPJOB##	;Last job scheduled for this CPU
	SKIPN	S		;At interrupt level?
	 PUSHJ	P,WHATJB	;No, UUO level, output JOB info first
	TLZ	F,-1		;Clear LH in case F points to a DDB
	PUSHJ	P,CHKDDB	;Make sure it's not garbage
	  JRST	NODDB0		;Not a DDB pointer
	LDB	T1,PJOBN##	;Get owning job number from DDB
	SKIPE	T1		;Must not be null job
	CAILE	T1,JOBMAX##	;Must not be too big
	 JRST	NODDB0		;DDB not valid
	PUSHJ	P,INLMES##
	 ASCIZ /File /
	PUSHJ	P,PRTDDB##	;Print DEVICE:FILE.EXT[P,Pn,SFD,SFD,SFD]
	PUSHJ	P,CRLF##
	JUMPE	S,NODDB		;Don't change J if STOPCD at UUO level
	LDB	J,PJOBN##	;Interrupt level - get owning job number
NODDB0:	SKIPE	S		;Output job info last if at interrupt level
	 PUSHJ	P,WHATJB	;Output job number, PPN, etc

NODDB:	MOVE	T1,2(M)		;Get bits field
	TLNE	T1,400000	;Is there more information?
	 SKIPN	T1,3(M) 	;Yes, must be nonzero
	  JRST	NOTYPE		;Nothing there
	HLLM	T1,.CPCPC	;Store LH where routine can find it
	TLZ	T1,-1		;Clear out for indirect
	PUSH	P,T1		;Save on stack
IFN P-1,<PRINTX ? The code at NODDB+5 assumes that P=1>
	MOVE	17,.CPACA##	;Point to the saved AC block
	MOVE	0,0(17) 	;Load up S
	MOVSI	17,2(17)	;Source address for AC2
	HRRI	17,2		;One past P
	BLT	17,17		;Restore all ACs except for P
	PUSHJ	P,@(P)		;Call routine, 18 bits of data in LH of .CPCPC
	POP	P,T1		;Clean up the stack
	PUSHJ	P,CRLF##

NOTYPE: MOVSI	T1,(DF.RIP)	;Is RELOAD in progress on other CPU?
	TDNE	T1,DEBUGF##
	 JRST	NOCSB		;Yes, don't type out meaningless CSB
	MOVE	T1,.CPSTY##	;Get error type
	MOVE	T1,PRCTAB(T1)	;Get control bits
	TLNN	T1,(S%CSB)	;Output CSB?
	 JRST	NOCSB		;No, don't type CSB for trivial errors
;*;		.CREF DF.SBD	;(Cref the use of the sign bit)
	SKIPGE	DEBUGF##	;Want DDT?
	 JRST	DIERS0		;Yes, skip CSB typout and PUSHJ to processor
	PUSHJ	P,TYPCSB##	;Type CPU Status Block info on the CTY

NOCSB:	MOVE	T1,.CPSTY##	;Get error type
	HRRZ	T1,PRCTAB(T1)	;Address of routine to process it
	PUSHJ	P,(T1)		;One of RELOAD,ZAPJOB,BUGCHK,CPUSTP,CPOPJ

DIERS0: MOVE	T1,.CPSTY##	;Get error type
	HRRZ	T2,SCTTAB(T1)	;Address of the per CPU counter
	AOS	(T2)		;Increment stopcode count
	HLRZ	T2,SCTTAB(T1)	;Address of the system-wide counter
	AOS	(T2)		;Increment stopcode count
	MOVE	T2,PRCTAB(T1)	;Get control bits
	MOVEI	T1,BUGCON	;Point to "[Continuing System]"
	TLNN	T2,(S%EVNT)	;No message if EVENT
	 PUSHJ	P,CONMES##	;(TOPS-10 does a SEND ALL via CONMSG)
	POP	P,.CPTOA##	;Restore type out address
	POPJ	P,		;If SVPPC was called, resume primary protocol

SUBTTL	STOPCD -- Low level CTY output routines
;Here during INFO or EVENT stopcodes - use normal CTY output

;Need to change this when the CTY is a normal TTY
DIETYO: PUSH	P,U		;Preserve AC
;*;	HRRZ	U,.CPCTN##	;Get CTY terminal number
;*;	MOVE	U,LINTAB##(U)	;Point to its LDB
;*;	PUSHJ	P,CCTYO##	;Put character into the TTY chunks
IF2,<PRINTX [DIETYO+3: Cannot use CCTYO because CTY has no LDB]>
	pushj	p,ctywat##   ;*HACK*	;use routine that ignores U
	JRST	UPOPJ## 	;Restore U and continue

;SUBROUTINE TO SEND C(T2) BELLS
;CLOBBERS T1, T2, T3, T4
BELLEN: HRRZ	T1,.CPTOA##	;Get typeout routine
	CAIE	T1,DIETYO	;Using normal buffered typeout?
BELLS:: TDZA	T1,T1		;Noninterrupt routine - must delay
	 MOVEI	T1,1		;No delay for INFO or EVENT stopcodes
	PUSH	P,T1		;Save flag
	PUSH	P,T2		;Save count
BELOOP:	MOVEI	T3,"G"-100	;BELL
	PUSHJ	P,COMTYO##	;DING
	SOSG	(P)		;Decrement count of bells to output
	 JRST	TTPOPJ##	;Done
	SKIPE	-1(P)		;Need to delay?
	 JRST	BELOOP		;No delay for INFO or EVENT
IFCPU  (KL),<MOVSI T1,1> 	;Loop 2^18 times on a KL10
IFNCPU (KL),<MOVEI T1,200000>	;Loop 2^16 times for all others
	DMOVE	T2,BECODE	;Put delay in ACs to avoid erratic timing
	JRST	T2		; due to presence or absence of cache

BECODE: SOJG	T1,T2		;(T2) Decrement and loop
	JRST	BELOOP		;(T3) Output another bell when done
SUBTTL	STOPCD -- Routines for DEBUG, INFO, and EVENTs

;Here on a DEBUG stopcode

BUGCHK:	PUSHJ	P,STCLIM	;Has STOPCD limit been exceeded?
	  JRST	SCLEXC		;Yes
	MOVSI	T1,(DF.RDC)	;Want to Reload on Debug Codes?
	TDNE	T1,DEBUGF##
	 JRST	RELOAD		;Yes
	MOVSI	T1,(DF.DDC)	;Want to suppress Dump on Debug Codes?
	TDNN	T1,DEBUGF##
	 PUSHJ	P,CRSDMP	;Take a continuable dump
	POPJ	P,		;Return to DIERS0

BUGCON:	 ASCIZ /[Continuing system]
/


;Here on an INFO or EVENT stopcode

INFSTP:				;No dump on INFO or EVENT codes, no limit either
	POPJ	P,		;Return to DIERS0


;Here on a JOB stopcode

ZAPJOB:	PUSHJ	P,STCLIM	;Has STOPCD limit been exceeded?
	  JRST	SCLEXC		;Yes
	MOVSI	T1,(DF.RJE)	;Want to Reload on Job Error?
	TDNN	T1,DEBUGF##
	 SKIPE	S		; or is PI in progress?
	  JRST	RELOAD		;Yes, do not continue
	SKIPE	.CPJOB		;Can't stop the null job
	SKIPE	.CPISF##	;Can't stop a job if In Scheduler Flag is set
	 JRST	RELOAD
	MOVSI	T1,(DF.DJE)	;Want to suppress Dump on Job Errors?
	TDNN	T1,DEBUGF##
	 PUSHJ	P,CRSDMP	;Go take a continuable dump
	PUSHJ	P,INLMES##
	 ASCIZ /[Aborting job]
/
	PUSHJ	P,GIVLOK##	;Give back locks this CPU owns
	MOVEI	T1,BUGSTP	;Routine to kill off job (after PI reenabled)
	MOVEM	T1,.CPCPC##	;Store as continue PC
	POPJ	P,		;Return to DIERS0
SUBTTL	STOP and DSKCLN stopcodes, RELOAD routine

;Here if we exceeded one of the STOPCD-PER-UNIT-TIME limits.

SCLEXC:	PUSHJ	P,INLMES##	;Tell what happened
	 ASCIZ /?Stopcode limit exceeded
/
	JRST	RELOAD


;Here when a CPU type STOPCD is detected

CPUSTP:	PUSHJ	P,INLMES##
	 ASCIZ /CPU or hardware error - / ;Hardware other than the disks
	JRST	RELOAD

;Here from FILRIB.  STOPCD(NO)=<manual boots>+<manual once>+<full DSKCLN>

DSKDIE::PUSH	P,.CPSPC	;Store PC of STOPCD(NO)
	POP	P,NOCRS##	; in NOCRS
	PJSP	T1,CONMES##
	 ASCIZ /Disk is unsafe - requesting manual BOOTS with no dump
/

;Here when a DSKCLN type STOPCD is detected

DSKSTP:	HRROS	SLOCRS##	;Flag to do a full DSKCLN
	PFALL   RELOAD

;Here to reload the Monitor

	DF.RLD==DF.RIP
RELOAD:	MOVSI	T1,(DF.RLD)	;Indicate that reload was requested
	IORM	DEBUGF##	;For CRSCPY to notice
;*;	MOVE	T1,.CPSNM##	;Get stopcode name
;*;	MOVEM	T1,CRSWHY##	;Store in location 24 for ONCE to check
	PUSHJ	P,INLMES##
	 ASCIZ /Reload monitor

----------------------------------------------------
/
	MOVEI	T2,^D20		;20 BELLS
	PUSHJ	P,BELLS		;..
	MOVE	T1,.CPSPC##	;Get the stop PC
	MOVEM	T1,CRSHWD##	;Store location 30 for SYSTAT/X
	PJRST	REBOOT##	;Reload now
;Routine to type user name and store info in .GTSYS (GETTAB table 51)
;Call with job number in J, and nonzero in S if at interrupt level

;Job 2  TTY12  SMITHJOSEPH[3,31116] connected to (TYMCOM-P034)[3,42754]
;Running (FTSYS)FILDDT[1,315372]
;UUO is 043300,,000014 at exec PC 123456 called from MUUO at user PC 000331

WHATJB:	SKIPLE	J		;Check job number
	CAILE	J,JOBMAX##
	 JRST	WHATUU		;Output failing UUO for S..EUE with null job
	MOVEM	J,%SYSJN##	;Store job number in GETTAB table 51
	MOVEM	J,.CPSJN##
	HRRZ	T1,TTYTAB##(J)	;Get pointer to DDB (LH of TTYTAB has flags)
	MOVE	T1,(T1)		;Get name of controlling terminal
	MOVEM	T1,%SYSTN##
	MOVEM	T1,.CPSTN##
	MOVE	T1,JBTAUN##(J)	;Get user's logged-in PPN
	MOVEM	T1,%SYSPP##
	MOVEM	T1,.CPSPP##
	PUSHJ	P,PJOBX##	;Output job, TTY, username, PPN, crlf
	PUSHJ	P,INLMES##
	 ASCIZ /Running /
	MOVE	T1,JBTFPN##(J)	;Program directory
	MOVEM	T1,%SYSPD##
	MOVEM	T1,.CPSPD##
	PUSHJ	P,PRTDIR##	;Output directory name
	MOVE	T2,JBTPRG##(J)	;Program name
	MOVEM	T2,%SYSPN##
	MOVEM	T2,.CPSPN##
	PUSHJ	P,PRNAME
	MOVE	T2,JBTFPN##(J)	;Program directory
	PUSHJ	P,PRTPPN##	;Output directory number
	PUSHJ	P,CRLF##
	JUMPN	S,CPOPJ##	;No UUO if at interrupt level
	PFALL	WHATUU		;Else fall into WHATUU and return

;Routine to output UUO and PC of UUO.  Example:
;UUO is 043300,,000014 at exec PC 123456 called from MUUO at user PC 000331

WHATUU::MOVE	T2,%UPT+UPTMUU	;Most recent UUO or illegal instruction
	MOVEM	T2,%SYSUU##
	MOVEM	T2,.CPSUU##
	PUSHJ	P,INLMES##
	 ASCIZ /UUO is /
	MOVE	T1,.CPSUU##	;UUO or instruction causing Ill Mem Ref
	PUSHJ	P,HWDPNT	;Print as octal halfwords
	MOVE	T2,%UPT+UPTMUP	;Get PC of UUO or illegal instruction
	MOVEM	T2,%SYSUP##
	MOVEM	T2,.CPSUP##
	PUSHJ	P,PCP		;" at exec PC" or " at user PC"
	MOVE	T2,%UPT+UPTPDL	;Get user's top-level return PC
	SUBI	T2,1		;Back up to PC of MUUO
	CAMN	T2,%UPT+UPTMUP	;Same?
	 PJRST	CRLF##		;Yes
	PUSHJ	P,INLMES##	;No, nested UUOs
	ASCIZ /, called from MUUO/
	PUSHJ	P,PCP		;" at user PC 000000"
	PJRST	CRLF
SUBTTL	STOPCD -- BUGSTP and KILUSR

;This routine will be called for JOB stopcode after interrupts are re-enabled.
;Here to stop an ill fated user.

BUGSTP:	MOVE	J,.CPJOB	;Job number
	JRST	ERRMED		;Output "Monitor Error Detected" and halt job


;ROUTINE TO CHECK A DDB ADDRESS BEFORE USING IT TO TYPE FILE INFORMATION
;DURING DIE PROCESSING.
;CALL:	MOVEI	F,ADDRESS
;	PUSHJ	P,CHKDDB
;	  RETURN HERE IF ADDRESS IS ILLEGAL FOR SOME REASON
;	RETURN HERE IF ADDRESS IS OK

CHKDDB:	CAMGE	F,SYSSIZ##	;LARGER THAN THE LOW SEG?
	CAIG	F,1000		;OR TOO SMALL?
	 CAIA			;YES, MAY STILL BE IN FUNNY SPACE
	  JRST	CPOPJ1##	;GIVE SKIP RETURN
; TYMCOM-X does not put DDBs in funny space
;*;	CAIL	F,.FPMC		;LEGAL ADDRESS IN
;*;	CAIL	F,.FPMC+NWMCP	;  FUNNY SPACE?
;*;	 POPJ	P,		;NO, BAD DDB ADDRESS
	MAP	T1,(F)		;MAP THE ADDRESS
	PUSHJ	P,FLTCHK##	;WILL REFERENCE FAULT?
	  POPJ	P,		;YES, BAD ADDRESS
; TYMCOM-X does not have DEFSFD, use DEVATB instead
	MAP	T1,DEVATB##(F)	;LAST ADDRESS IN DDB REFERENCED BY PRTDDB
	PJRST	FLTCHK##	;CHECK ADDRESS AND RETURN
;ROUTINE TO SEE IF THIS STOPCD HAS CAUSED US TO EXCEED ON OF THE
;STOPCDS-PER-UNIT-TIME LIMITS.
;CALL:	PUSHJ	P,STCLIM
;	  RETURN HERE IF A LIMIT HAS BEEN EXCEEDED
;	  RETURN HERE IF NOT
; SCLTAB::XWD	^D60,  LIM1MS	;Period = 1 minute,  Limit = LIM1MS = 2
;	  XWD	^D480, LIM8MS	;Period = 8 minutes, Limit = LIM8MS = 4
;	  XWD	^D3600,LIM1HS	;Period = 1 hour,    Limit = LIM1HS = 8
; SCLTBL=3 (SCLTAB and SCCTAB defined in COMMON)

STCLIM:	SKIPGE	DEBUGF##	;IF DEBUGGING
	 JRST	CPOPJ1##	;THEN NO STOPCD LIMITS
	MOVSI	T1,-SCCTBL##	;BUILD AOBJN POINTER TO TABLE
STCLI1:	AOS	T2,SCCTAB##(T1)	;INCREMENT NEXT COUNT
	HRRZ	T3,SCLTAB##(T1)	;GET THE LIMIT
	CAIL	T2,(T3)		;EXCEED THE LIMIT?
	 POPJ	P,		;YES, GIVE ERROR RETURN
	AOBJN	T1,STCLI1	;NO, LOOP FOR NEXT
XP .SLDSC,1	;Sleep request to Decrement Stopcode Count
	HLRZ	T1,SCLTAB##+0	;GET PERIOD OF LOWEST ENTRY IN TABLE (60 SECONDS)
	HRLI	T1,(1B0+<.SLDSC>B6+0B18) ;Flag for seconds, call DECSCC, at 0
	IDPB	T1,CLOCK##	;Set to call DECSCC 60 seconds from now
	JRST	CPOPJ1##	;GIVE SKIP RETURN


;ROUTINE TO DECREMENT A STOPCD COUNT AND RESUBMIT A CLOCK QUEUE REQUEST
;FOR THE NEXT HIGHER COUNT, IF ONE EXISTS.
;CALL:	MOVEI	T1,INDEX INTO SCCTAB
;	PUSHJ	P,DECSCC
;	  RETURN HERE ALWAYS

;Called from CLOCK1 with data in T1
DECSCC::SOSGE	SCCTAB##(T1)	;DECREMENT COUNT
	 SETZM	SCCTAB##(T1)	;LEAVE ZERO IF IT WAS ZERO
	AOS	T1		;INCREMENT LEVEL
	CAIL	T1,SCCTBL##	;DONE THE LAST LEVEL?
	 POPJ	P,		;YES, RETURN NOW
	MOVE	T2,SCLTAB##(T1)	;GET WORD WITH NEW PERIOD
	SUB	T2,SCLTAB##-1(T1) ;SUBTRACT OLD PERIOD
	HLRZS	T2		;KEEP JUST DIFFERENCE IN SECONDS
	HRLI	T2,(1B0+<.SLDSC>B6) ;Flag for seconds, call DECSCC,
	DPB	T1,[POINT 7,T2,18]  ;Put current level in job number field
	SYSPIF			;TELL SLAVE CPU TO NOT INTERRUPT THE IDPB PAIR
	IDPB	T2,CLOCK##	;STORE REQUEST
	PJRST	ONPOPJ##	;RETURN INTERLOCK AND POPJ
;ROUTINES FOR STOPCODE MACRO TYPE OUT
;ALL ROUTINES WILL HAVE THE FORM DIE???::
;WHERE ??? ARE 3 LETTERS DESCRIPTIVE OF THE ROUTINE
;AN AUTOMATIC CARRIAGE RETURN/LINE FEED IS DONE BY CALLER


;ROUTINE TO TYPE OUT UNINAM(U) DURING STOPCD
DIEUNI::PUSHJ	P,INLMES##	;START THE OUTPUT
	ASCIZ	\Unit = \
	MOVE	T2,.CPACA##	;GET ADDRESS OF AC SET
	MOVE	T2,U(T2)	;GET "U" AT CRASH
	MOVE	T2,UNINAM##(T2)	;GET THE NAME
	PJRST	PRNAME		;PRINT OUT SIXBIT AND RETURN

; ROUTINE TO TYPE OUT STRNAM(P2) DURING A STOPCODE
DIESTR::PUSHJ	P,INLMES##	;TYPE INTRODUCTION
	ASCIZ	|Structure = |
	MOVE	T2,STRNAM##(P2)	;GET STR NAME
	PJRST	PRNAME		;TYPE IT AND RETURN

;Routine to type out additional data during BUGINF
;Called via:
;	JSP	T1,BGCTYP
;	SIXBIT /NAME/
;	EXP    ADDR
;	SIXBIT /NAME2/
;	EXP    ADDR2
;	EXP	0       ;Returns by POPJ at end

BGCTYP::MOVE	P1,T1		;Copy pointer to data
BUGTY1:	MAP	T1,(P1)		;Make sure location is accessible
	PUSHJ	P,FLTCHK##	;Make sure it won't fault
	  POPJ	P,		;Will fault, give up
	SKIPN	(P1)		;Hit zero at end?
	 POPJ	P,		;Yes
	TLO	P1,400000	;Remember that something was typed
	PUSHJ	P,INLMES##	;Space entries apart
	 ASCIZ /   /
	MOVE	T2,(P1)		;Get item name
	PUSHJ	P,PRNAME
	PUSHJ	P,INLMES##
	 ASCIZ /: /
	MAP	T1,1(P1)	;Make sure this won't fault
	PUSHJ	P,FLTCHK##
	  POPJ	P,		;Abort instead of faulting
	MOVE	T2,1(P1)	;Get the address of the item
	MAP	T1,(T2)		;Check if it is legal
	PUSHJ	P,FLTCHK##
	  POPJ	P,
	MOVE	T1,1(P1)	;Get address
	MOVE	T2,.CPACA##	;Address of saved ACs
	ADD	T2,T1		;Offset into the AC save block
	CAIG	T1,17		;Item in the crash ACs?
	 SKIPA	T1,(T2)		;Yes, fetch from proper location
	  MOVE	T1,(T1)		;No, get directly
	PUSHJ	P,HWDPNT	;Print as halfwords
	ADDI	P1,1		;Increment for doublewords
	AOJA	P1,BUGTY1	;Loop until 0 is found

;Routines to output the contents of one accumulator on the CTY
PRTT1::	PUSH	P,T1		;Routine to output the contents of T1
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Contents of T1 = /
PRTT0:	POP	P,T1		;Get saved value
	PUSHJ	P,HWDPNT	;Print as halfwords
	PJRST	CRLF##

PRTT2::	PUSH	P,T2		;Routine to output the contents of T2
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Contents of T2 = /
	PJRST	PRTT0

PRTT3::	PUSH	P,T3		;Routine to output the contents of T3
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Contents of T3 = /
	PJRST	PRTT0

PRTT4::	PUSH	P,T4		;Routine to output the contents of T4
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Contents of T4 = /
	PJRST	PRTT0

PRTP1::	PUSH	P,P1		;Routine to output the contents of P1
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Contents of P1 = /
	PJRST	PRTT0

PRTP1U::PUSH	P,U		;Routine to output the contents of P1
	PUSH	P,P1		; and U ::   P1(Msg-type) U(Port)
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Message type (P1) = /
	POP	P,T1		;Get saved value
	PUSHJ	P,HWDPNT	;Print as halfwords
	PUSHJ	P,INLMES##	;Then next part
	 ASCIZ /, Port # (U) = /
	PJRST	PRTT0		;Restore U, and fall into common code

PRTCRS::PUSH	P,KEY620##	;Routine to output the contents of
	PUSH	P,CRSHWD##	; CRSHWD and KEY620
	PUSHJ	P,INLMES##	;This routine called by STOPCD processor
	 ASCIZ /Contents of 30: /
	MOVE	T1,(P)		;Get saved value
	PUSHJ	P,HWDPNT	;Print as halfwords
	PUSHJ	P,INLMES##	;Some spacing
	 ASCIZ / '/
	POP	P,T2		;Restore CRSHWD
	PUSHJ	P,PRNAME	;Yes, print that too
	PUSHJ	P,INLMES##	;Then next part
	 ASCIZ /'   Key: /
	POP	P,T1		;Get Key value, that is
	LSH	T1,-^D20	; it's high order 16 bits and
	PUSHJ	P,PRTDI8	; print as an octal number.
	PJRST	CRLF##		;Finish the line.
;ROUTINE TO CALL BUGDMP TO TAKE A CONTINUABLE STOPCD DUMP
;AND THEN SET DF.RQC IN DEBUGF WHICH WILL CAUSE CRSCPY
;TO BE CALLED BY THE BOOT CPU AT THE NEXT TICK.  WE
;CAN'T CALL CRSCPY DIRECTLY BECAUSE THE SCNSER INTERLOCK
;MAY NOT BE FREE.
;ENTER AT FRCCPY TO JUST SET DF.RQC (FROM ADDSDL)
;CALL:	PUSHJ	P,CRSDMP
;	RETURN HERE ALWAYS

CRSDMP:	PUSH	P,JOBSYM##	;KEEP DAEMON FROM THINKING THIS IS A
	SETZM	JOBSYM##	; RELOAD BY ZEROING THE FLAG THAT IT LOOKS AT
;*;	PUSH	P,MBTCOM##	;DO THE SAME FOR THE SYSTEM
;*;	SETZM	MBTCOM##	; SLEEP COMMUNICATION WORD
	PUSHJ	P,BUGDMP##	;TAKE DUMP
	  JFCL			;IGNORE ERROR RETURN
;*;	POP	P,MBTCOM##	;RESTORE SYSTEM SLEEP COMMUNICATION WORD
	POP	P,JOBSYM##	;RESTORE SYMBOL TABLE POINTER

;Routine to set flag to run CRSCPY (called if BUGDMP is successful)

FRCCPY::MOVSI	T1,(DF.RQC)	;IF THE CRSCPY REQUEST HAS NOT BEEN
	MOVSI	T2,(DF.DCC)	; DISABLED VIA THE /NOCOPY STARTUP
	TDNN	T2,DEBUGF##	; SWITCH, SET DF.RQC IN DEBUGF WHICH
	 IORM	T1,DEBUGF##	; WILL CAUSE CRSCPY TO BE CALLED ON
	ANDCAM	T2,DEBUGF##	; THE NEXT CLOCK TICK
	POPJ	P,		;RETURN


;Routine to start up the CRASH-COPY program to copy SYS:CRASH.EXE
;Called from once-a-tick code if DF.RQC was set in DEBUGF

CRSCPY::SKIPGE	DEBUGF##	;DON'T DO ANYTHING
	 POPJ	P,		; IF DEBUGGING
	PUSHJ	P,FRCSET##	;SETUP TO STORE CHARACTERS IN FRCLIN
	MOVE	T2,CCPNAM##	;GET NAME OF PROGRAM TO RUN
	PUSHJ	P,PRNAME	;STORE NAME
	PJRST	CRLF##		;ADD CRLF AND RETURN

;;;;;;;;;;;;;;;;;;;;;;;;  End of DIE: STOPCD processor  ;;;;;;;;;;;;;;;;;;;;;;;;
SUBTTL	ROUTINE TO PRINT M PC AND STOP JOB
;IF IN USER MODE PC WILL PRINT AS "AT USER LOC XXX"
;IF IN EXEC MODE "AT EXEC LOC XXX; EXEC CALLED FORM EXEC/USER/ LOC YYY

UUOPCP:	MOVE T2,%UPT+UPTPDL	;PC of user's MUUO is at top of PDL
	SUBI	T2,1		;POINT TO THE ACTUAL UUO
	PUSHJ	P,PCP		;PRINT " AT EXEC XXX" OR " AT USER "
	TLNN	T2,PC.USR	;PC IN USER MODE?
	PJRST	ERRSCU		;NO, TELL HIM WHERE UUO IS
;	PJRST	TCLTTY		;CLEAR TTY INPUT BUFFER AND PUT IT IN MONITOR MODE

;ROUTINE TO CLEAR TTY INPUT BUFFER AND PUT IT IN MONITOR MODE.

TCLTTY:	PUSHJ	P,TTYFND	;GET ORIGINAL U AND F FROM C(J)
	JUMPE	U,CPOPJ		;IF NO LINE, FORGET IT.
TCLTT0:	PUSHJ	P,TSETBI	;CLEAR TYPE AHEAD
	PUSHJ	P,PRRSP1	;PRINT WATCH DATA AND CRLF
	PJRST	TTYSTC		;AND PUT TTY IN MONITOR MODE.

;ROUTINE TO RESET U TO JOB'S LDB IF ANY, PRINT WATCH DATA AND PERIOD,
; STOP TERMINAL, BUT DO NOT CLEAR TYPE AHEAD.
; USED BY EXIT AND EXIT 1, IF JOB IS NOT DETACHED. (SO NEVER COME
; IN WITH OPR'S LDB)

TNCTTY:	PUSHJ	P,CRLF
E1STTY:	PUSHJ	P,PRRSP3	;WATCH DATA, CRLF, PERIOD
	PJRST	TTYSTC		;AND PUT TTY IN COMMAND MODE.

;ROUTINE TO HANDLE TTY ON TIME LIMIT EXCEEDED
; IF DETACHED, PUT IT INTO
; TO WAIT. WHEN IT COMES OUT OF WAIT ON ATTACH,
; JOB WILL RESCHEDULE AND PRINT TIME LIMIT EXCEEDED NEXT TIME
; AROUND THRU RSCHED.
;ROUTINE TO STOP TELETYPE FOR TIME LIMIT EXCEEDED.
; ERRFNU MUST BE SET AS THE TTY FINDING ROUTINE.
; MUST ENTER WITH U SETUP TO LINE OR 0, F SETUP TO DDB ADDRESS OF
; TTY OR 0.

EXTERNAL TTYSOW,CIP6,PJBSTS,TTYFNU,TIOWQ,TTYSTC,PRRSP1,PRRSP3

TLETTY:	JUMPN	U,TCLTT0	;IF LDB, DO NORMAL THING.
	JUMPN	F,TLTOW		;NO LDB, IF DDB, PUT FRAME INTO TO WAIT
	POPJ	P,		;NOTHING, JUST RETURN.

;HERE IF NO LINE, PUT INTO IO WAIT IF THERE IS A DDB
TLTOW:	PUSHJ	P,TTYSOW	;SET OUTPUT WAIT IN SCNSER
	MOVSI	S,IOW	;PUT DDB INTO IOW
	IORM	S,DEVIOS(F)
	MOVEI	T1,TIOWQ
	DPB	T1,PJBSTS
	POPJ	P,		;AND RETURN.
;ROUTINE TO STOP JOB, BUT RETURN TO CALLER AND LET HIM GO THRU NORMAL USRXIT
; USED FOR BAD INTERRUPT ADDRESS

EXTERNAL KJSTOP,STOP1,USCHED

BISTOP:	PUSHJ	P,KJSTOP	;STOP THE JOB
	MOVEI	T1,CPOPJ	;RETURN WITH A POPJ FROM CLKTRP
	HRRM	T1,%UPT+UPTMUP	;
	JRST	KTRRET##

;ROUTINE TO STOP JOB CONTINUABLY

HISTOP:	PUSHJ	P,STOP1		;STOP JOB CONTINUABLY.
	PJRST	WSCHED		;AND CALL SCHEDULER. POPJ RETURN TO JRST ERR???

;ROUTINE TO STOP FOR EXIT 1,

E1STOP:	PUSHJ	P,STOP1		;STOP THE JOB (DON'T SET JERR, SO IT COMES BACK)
	JRST	USCHED		;AND CALL THE SCHEDULER.

;ROUTINE CALLED WHEN IT IS DESIRED TO STOP A FRAME AND INTERRUPT
; ITS PARENT OR TRAPHANDLER BUT NOT STORE AN EXIT CODE OR
; INCREMENT EXIT COUNT IN THE TARGET FRAME. USED FOR HALT COMMAND,
; HALT FRMOP.

TRHALT::PUSHJ	P,HLTTRP	;INTERRUPT TRAPHANDLER OR PARENT IF ANY
	  PJRST	STOP1		;WAS TRAPHANDLER OR PARENT
	PJRST	STOP1		;WAS NO TRAPHANDLER OR PARENT.
;ROUTINE TO TYPE A NUMBER AS HALFWORDS SEPARATED BY COMMAS.
;CALL:	MOVE	T1,NUMBER
;	PUSHJ	P,HWDPNT
;	RETURN

HWDPNT::PUSH	P,T1		;SAVE T1 FOR RH
	HLRZS	T1		;KEEP JUST LH
	PUSHJ	P,OCTPNT	;PRINT AS 6 OCTAL DIGITS
	PUSHJ	P,INLMES	;PRINT THE TWO COMMAS
	ASCIZ/,,/		;...
	POP	P,T1		;RESTORE T1 FOR RH
	PJRST	OCTPNT		;PRINT RH AND RETURN

;ROUTINE TO PRINT PC AS:
;1) "EXEC LOC XXX" OR "USER LOC XXX"
;CALL:	MOVE T2,PC TO PRINT(LH=PC FLAGS)
;	PUSHJ P,PCP

XMODE:	ASCIZ / at exec PC /
UMODE:	ASCIZ / at user PC /

PCP:	MOVEI	T1,XMODE	;ASSUME PC IN EXEC MODE
	TLNE	T2,PC.USR	;IS IT?
	MOVEI	T1,UMODE	;NO, USER MODE
	PUSHJ	P,CONMES	;PRINT ONE OR OTHER
	HRRZ	T1,T2		;PRINT RIGHT HALF IN OCTAL
				; FALL INTO OCTPNT

;ROUTINE TO PRINT 6 DIGIT OCTAL NUMBER
;CALL:	MOVEI U,U DATA BLOCK ADDRESS FOR TTY
;	HRR T1, OCTAL NUMBER
;	PUSHJ P,OCTPNT
;	RETURN T2,PRESERVED,T1 DESTROYED

OCTPNT::HRLZ	T1,T1		;MOVE TO LH FOR ROTATING
	TRO	T1,700000	;SETUP AN END FLAG

OCTP1:	ROT	T1,3		;GET NEXT OCTAL DIGIT
	TLNN	T1,777777	;WAS THAT FLAG?
	POPJ	P,		;YES, DO NOT PRINT IT
	PUSH	P,T1		;SAVE T1 OVER I/O ROUTINE
	PUSHJ	P,PRTNUM	;NO, PRINT OCTAL DIGIT
	POP	P,T1		;RESTORE T1
	HRRI	T1,0		;CLEAR RH
	JRST	OCTP1		;GET NEXT OCTAL DIGIT
;ROUTINE TO ADD 1 TO T1 AND PRINT DECIMAL
;SAME CALL AS OCTPNT

DECP1::	AOJA	T1,RADX10	;ADD 1 AND GO PRINT

;ROUTINE TO PRINT DECIMAL
;CALL:	SAME AS OCTPNT
;T2:	PRESERVED

RADX10::PUSH	P,T2		;SAVE T2
	PUSHJ	P,PRTDIG	;PRINT DECIMAL DIGITS
	PJRST	T2POPJ##	;RESTORE T2 AND RETURN

;RECURSIVE DECIMAL PRINT ROUTINE
;CALL:	MOVE T1,DECIMAL NO.
;	PUSHJ P,PRTDIG

PRTDIG::IDIVI	T1,12		;DIVIDE BY 10
	HRLM	T2,(P)		;RT ON PD LIST
	JUMPE	T1,.+2		;FINISHED?
	PUSHJ	P,PRTDIG	;NO, CALL S OR F
PRTNMM:	HLRZ	T1,(P)		;YES, GET LAST NUMBER
PRTNUM:	MOVEI	T3,"0"(T1)	;CONVERT TO ASCII
	PJRST	COMTYO##	;AND TYPE IT OUT

;RECURSIVE OCTAL PRINT ROUTINE
;CALL:	SAME AS PRTDIG

PRTDI8::IDIVI	T1,10		;DIVIDE BY 8
	HRLM	T2,(P)		;PUT ON STACK
	JUMPE	T1,PRTNMM	;FINISHED?
	PUSHJ	P,PRTDI8	;NO - LOOP
	PJRST	PRTNMM		;OUTPUT

;SUBROUTINE TO PRINT 22 BIT OCTAL ADDRESS
;CALL:	MOVE	T1,22 BIT ADDRESS
;	PUSHJ	P,PRT22A
;	ALWAYS RETURN

PRT22A::PUSH	P,T1		;SAVE 22 BIT ADDRESS
	HLRZ	T1,(P)		;GET HIGH ORDER HALF
	JUMPE	T1,PRT22B	;IS IT 0 (USUALLY EXCEPT BIG SYSTEMS)
	PUSHJ	P,PRTDI8	;NO, PRINT AS LEADING 0 SUPPRESSED OCTAL
PRT22B:	POP	P,T1		;GET LOW ORDER HALF
	PJRST	OCTPNT		;PRINT AS NON ZERO SUPPRESSED OCTAL (RH ONLY)
;ROUTINE TO PRINT "DEVICE XXX"
;	MOVEI F,<ADDRESS OF DEVICE NAME TO PRINT>
;	PUSHJ P,ERNAM

ERNAM::	PUSHJ	P,INLMES
	 ASCIZ /device /
	SKIPN	F	;IF NO F SETUP,
	 SKIPA	T2,[SIXBIT/??????/] ;THEN SAY DON'T KNOW
	MOVE	T2,DEVNAM(F)	;NO, GET DEVICE NAME
	PFALL	PR6BIT

PR6BIT::JUMPE	T2,PRSPC##	;Print a single space if whole word is blank
	TLNE	T2,770000	;Left justified?
	 JRST	PRNAME		;Yes
	LSH	T2,6		;No, make it
	JRST	PR6BIT

;ROUTINE TO PRINT SIXBIT NAME
;CALL	MOVE U,ADDRESS OF LDB
;	MOVE T2,NAME
;	PUSHJ P,PRNAME

PRNAME::JUMPE	T2,CPOPJ##
	MOVEI	T1,0
	LSHC	T1,6		;SHIFT IN NEXT CHAR.
	MOVEI	T3,40(T1)	;CONVERT SIXBIT TO ASCII
	PUSHJ	P,COMTYO	;OUTPUT CHARACTER
	JRST	PRNAME

;ROUTINE TO PRINT FILE NAME AND EXTENSION IF NONZERO.
; P3/ FILE NAME
; P4/ ZERO OR EXTENSTION TO PRINT


ERFNAM:	MOVE	T2,P3		;FIRST PRINT FILE NAME
	PUSHJ	P,PRNAME
	JUMPE	P4,CPOPJ	;IF NO EXTENSTION, JUST RETURN
	PUSHJ	P,PRPER##	;PRINT A DOT
	MOVE	T2,P4		;GET EXTENSTION
	PJRST	PRNAME		;PRINT EXTENSTION AND RETURN.

;ROUTINE TO PRINT OUT CRLF AND A QUESTION MARK FOR SEGCON ERRORS.

CRLFQ:	PJSP	T1,CONMES	;PRINT ? AND CRLF
	ASCIZ/
?/
	LIT
	END
    }KWH